# CLAUDE.md - Rash Development Guidelines

## Project Context
**Rash (bashrs)** is a bidirectional shell safety tool using REAL Rust (not a DSL):

### PRIMARY WORKFLOW (Production-Ready): Rust → Safe Shell
Write actual Rust code, test with standard Rust tooling, then transpile to provably safe, deterministic POSIX shell scripts.

**Why this is powerful**:
- Write REAL Rust code (not a DSL!)
- Use standard Rust tooling: cargo, rustc, clippy
- Test with `cargo test` BEFORE generating shell
- Get deterministic, idempotent shell output
- Guaranteed safe against injection attacks
- POSIX compliant (passes shellcheck)

### SECONDARY WORKFLOW (Recently Added): Bash → Rust → Purified Bash
Ingest messy bash scripts, convert to Rust with tests, then transpile to purified, safe bash.

**Purification pipeline**:
1. Parse legacy bash (with $RANDOM, timestamps, non-idempotent code)
2. Convert to Rust + generate comprehensive tests
3. Transpile to purified bash (deterministic, idempotent, safe)

This "cleans up" existing bash scripts by running them through the bashrs safety pipeline.

---

## Workflow 1: Rust → Shell (PRIMARY)

### Input: Real Rust Code
```rust
// install.rs - Write actual Rust code
use std::fs;

fn install_app(version: &str) -> Result<(), String> {
    let prefix = "/usr/local";

    println!("Installing version {}", version);

    // Use real Rust std library
    fs::create_dir_all(format!("{}/bin", prefix))
        .map_err(|e| e.to_string())?;

    fs::copy("myapp", format!("{}/bin/myapp", prefix))
        .map_err(|e| e.to_string())?;

    Ok(())
}

fn main() -> Result<(), String> {
    install_app("1.0.0")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_install_idempotent() {
        // Real Rust tests with cargo test
        assert!(install_app("1.0.0").is_ok());
        assert!(install_app("1.0.0").is_ok()); // Safe to re-run
    }
}
```

### Output: Safe POSIX Shell
```bash
#!/bin/sh
# Generated by Rash v1.0.0 - Provably safe and deterministic

install_app() {
    _version="$1"
    prefix="/usr/local"

    printf '%s\n' "Installing version ${_version}"

    # Idempotent operations (safe to re-run)
    mkdir -p "${prefix}/bin" || return 1
    cp myapp "${prefix}/bin/myapp" || return 1

    return 0
}

install_app "1.0.0"
```

**Quality Guarantees**:
- ✅ Deterministic (same input = same output)
- ✅ Idempotent (safe to re-run)
- ✅ POSIX compliant (shellcheck passes)
- ✅ No injection vectors (all vars quoted)
- ✅ Tested with real Rust tooling before generation

---

## Workflow 2: Bash → Rust → Purified Bash (SECONDARY)

### Input: Messy Bash
```bash
#!/bin/bash
# deploy.sh - PROBLEMATIC

# Non-deterministic
SESSION_ID=$RANDOM
RELEASE="release-$(date +%s)"

# Non-idempotent
mkdir /app/releases/$RELEASE
rm /app/current
ln -s /app/releases/$RELEASE /app/current
```

### Step 1: Parse to Rust
```rust
// deploy.rs - Generated from deploy.sh
use std::fs;

fn deploy_app(version: &str) -> Result<(), String> {
    // Purified: deterministic (not $RANDOM)
    let session_id = format!("session-{}", version);

    // Purified: deterministic (not timestamp)
    let release = format!("release-{}", version);

    // Purified: idempotent (mkdir -p)
    let release_dir = format!("/app/releases/{}", release);
    fs::create_dir_all(&release_dir)
        .map_err(|e| e.to_string())?;

    // Purified: idempotent (remove if exists)
    let _ = fs::remove_file("/app/current");

    // Purified: idempotent (symlink)
    std::os::unix::fs::symlink(&release_dir, "/app/current")
        .map_err(|e| e.to_string())?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_deploy_deterministic() {
        // Same version = same behavior
        assert!(deploy_app("1.0.0").is_ok());
        assert!(deploy_app("1.0.0").is_ok());
    }
}
```

### Step 2: Purified Bash Output
```bash
#!/bin/sh
# Purified by Rash v1.0.0

deploy_app() {
    _version="$1"

    # Deterministic (was $RANDOM)
    session_id="session-${_version}"

    # Deterministic (was timestamp)
    release="release-${_version}"

    # Idempotent (was mkdir)
    release_dir="/app/releases/${release}"
    mkdir -p "${release_dir}" || return 1

    # Idempotent (was rm)
    rm -f "/app/current"

    # Idempotent (was ln -s)
    ln -s "${release_dir}" "/app/current" || return 1
}

deploy_app "$1"
```

**Purification Report**:
```
Issues Fixed: 5
- $RANDOM → version-based ID
- $(date +%s) → fixed release tag
- mkdir → mkdir -p (idempotent)
- rm → rm -f (idempotent)
- ln -s → remove + ln -s (idempotent)

Quality: ✅ Deterministic, ✅ Idempotent, ✅ POSIX
```

---

## Key Point: REAL Rust, Not a DSL

**What Rash IS**:
- ✅ A transpiler from Rust to shell
- ✅ Uses actual Rust language (subset)
- ✅ Uses real Rust std library
- ✅ Tests with real `cargo test`
- ✅ Lints with real `cargo clippy`
- ✅ Uses real Rust toolchain

**What Rash is NOT**:
- ❌ NOT a custom DSL
- ❌ NOT a made-up language
- ❌ NOT a Rust-like language

You write REAL Rust code, and it gets transpiled to safe shell scripts.

---

## Development Principles

### 自働化 (Jidoka) - Build Quality In
- **Workflow 1**: Test Rust code with `cargo test` before transpiling
- **Workflow 2**: Generate tests when converting bash, validate purified output
- **Never ship incomplete code**: All transpiler outputs must be fully safe

### 現地現物 (Genchi Genbutsu) - Direct Observation
- **Test against real shells**: dash, ash, busybox sh, bash
- **Profile actual scenarios**: Bootstrap installers on Alpine containers
- **Verify purification**: Ensure purified bash behaves identically to original

### 反省 (Hansei) - Fix Before Adding
- **Current priorities**:
    1. Rust → Shell quality (primary workflow)
    2. Bash → Rust parsing completeness
    3. Purification accuracy (behavioral equivalence)

### 改善 (Kaizen) - Continuous Improvement
- **Quality baselines**: All generated shell must pass quality gates
- **Performance**: <100ms transpilation, <10MB memory
- **Test coverage**: >85% on all modules

## Critical Invariants

### Workflow 1 (Rust → Shell)
1. **POSIX compliance**: Every generated script must pass `shellcheck -s sh`
2. **Determinism**: Same Rust input must produce byte-identical shell output
3. **Safety**: No injection vectors in generated scripts
4. **Idempotency**: Operations safe to re-run

### Workflow 2 (Bash → Purified Bash)
1. **Behavioral equivalence**: Purified bash must behave same as original
2. **Determinism**: Remove all $RANDOM, timestamps, process IDs
3. **Idempotency**: Add -p, -f flags for safe re-run
4. **Test coverage**: >85% on converted Rust code

## Verification with paiml-mcp-agent-toolkit
```bash
# Verify transpiler correctness (Workflow 1)
pmat verify --spec rash.spec --impl target/debug/bashrs

# Test generated scripts
pmat test --shell-matrix "sh,dash,ash" --input examples/*.rs

# Verify purification (Workflow 2)
pmat analyze complexity --max 10
pmat quality-score --min 9.0
```

## Tools
- `cargo test` - Test actual Rust code
- `cargo build` - Build Rust code (before transpilation)
- `cargo clippy` - Lint Rust code
- `cargo llvm-cov` - Measure coverage (we use llvm, not tarpaulin)
- `cargo mutants` - Mutation testing
- `shellcheck` - Validate generated shell output
- `pmat` - Quality analysis with paiml-mcp-agent-toolkit

## Quality Standards

All outputs must meet:
- ✅ 100% shellcheck compliance (POSIX)
- ✅ 100% determinism tests pass
- ✅ 100% idempotency tests pass
- ✅ >85% code coverage
- ✅ Complexity <10
- ✅ Mutation score >80%
- ✅ Zero defects policy

