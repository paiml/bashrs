# Rash: Rust-to-Shell Transpiler

Rash transpiles a subset of Rust to POSIX-compliant shell scripts with formal correctness guarantees. The system targets write-once bootstrap installers (curl | sh patterns) where determinism, idempotency, and security are paramount.

## Features

- âœ… **Basic Rust-to-Shell transpilation** - Convert simple Rust functions to shell scripts
- âœ… **POSIX compliance** - Generated scripts work across all POSIX-compliant shells  
- âœ… **CLI interface** - Full command-line tool with build, check, init, and verify commands
- âœ… **Safety guarantees** - Built-in verification against command injection and other vulnerabilities
- âœ… **Embedded runtime** - Minimal runtime library injected into generated scripts
- ðŸš§ **Advanced type support** - Currently supports basic types (strings, numbers, booleans)
- ðŸš§ **Control flow** - Basic if/else statements (work in progress)
- ðŸš§ **SMT verification** - Formal verification using Z3 (planned)

## Quick Start

### Installation

```bash
git clone https://github.com/yourusername/rash
cd rash
cargo build --release
```

### Basic Usage

1. **Initialize a new project:**
```bash
./target/debug/rash init my-installer
cd my-installer
```

2. **Write your Rust installer:**
```rust
// src/main.rs
fn main() {
    let message = "Hello from Rash!";
    let version = "1.0.0";
    
    echo(message);
    echo(version);
}
```

3. **Transpile to shell:**
```bash
rash build src/main.rs --output install.sh
```

4. **Run the generated script:**
```bash
chmod +x install.sh
./install.sh
```

### Generated Output

The above Rust code generates this POSIX shell script:

```bash
#!/bin/sh
# Generated by Rash v0.1.0
# POSIX-compliant shell script

set -euf
IFS=$'\n\t'
export LC_ALL=C

# Rash runtime functions
rash_require() {
    if ! "$@"; then
        echo "FATAL: Requirement failed: $*" >&2
        exit 1
    fi
}

# Main script begins
main() {
    readonly message='Hello from Rash!'
    readonly version='1.0.0'
    echo "$message"
    echo "$version"
}

# Cleanup on exit
trap 'rm -rf "${TMPDIR:-/tmp}/rash.$$"' EXIT

# Execute main function
main "$@"
```

## CLI Commands

### `rash build`
Transpile Rust source to shell script:
```bash
rash build input.rs --output install.sh
rash build input.rs --emit-proof  # Generate verification proof
```

### `rash check`
Validate Rust source for Rash compatibility:
```bash
rash check input.rs
```

### `rash init`
Initialize a new Rash project:
```bash
rash init my-project
rash init my-project --name "My Installer"
```

### `rash verify`
Verify shell script matches Rust source:
```bash
rash verify input.rs generated.sh
```

## Verification Levels

Rash supports multiple verification stringency levels:

- `--verify none` - No verification (fastest)
- `--verify basic` - Basic safety checks  
- `--verify strict` - Strict verification (default)
- `--verify paranoid` - Maximum verification with formal proofs

## Target Dialects

Generate scripts for different shell dialects:

- `--target posix` - POSIX sh (default, maximum compatibility)
- `--target bash` - Bash-specific optimizations
- `--target dash` - Debian Almquist Shell
- `--target ash` - Alpine Shell

## Current Status

This is a working proof-of-concept implementation. Successfully implemented:

- âœ… Complete Rust workspace with multiple crates
- âœ… Rust AST parsing using syn crate
- âœ… Shell IR (intermediate representation) 
- âœ… POSIX shell code emission with proper escaping
- âœ… CLI with build, check, init, verify commands
- âœ… Basic verification framework
- âœ… Embedded shell runtime library

## Current Limitations

- **Type system**: Only basic types (bool, u32, &str) supported
- **Control flow**: Limited if/else support
- **Function calls**: Simple function calls only
- **Memory model**: No heap allocations or complex data structures
- **Standard library**: Custom runtime instead of std

## License

Licensed under either of:
- Apache License, Version 2.0
- MIT License

at your option.