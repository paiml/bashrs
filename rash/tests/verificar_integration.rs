//! Verificar integration tests
//!
//! Tests bashrs against synthetic bash programs generated by verificar.
//! This ensures bashrs handles all common bash patterns correctly.
//!
//! Run with: `cargo test --test verificar_integration`

#![allow(clippy::unwrap_used)]

use std::process::Command;

/// Synthetic bash programs from verificar's BashEnumerator
/// These cover core bash constructs: assignments, commands, control flow,
/// functions, arithmetic, and pipes.
const VERIFICAR_BASH_PROGRAMS: &[&str] = &[
    // Simple assignments
    "x=1",
    "x=0",
    "x=42",
    "x=hello",
    "x=world",
    "y=1",
    "result=42",
    // Echo commands
    r#"echo "$x""#,
    "echo hello",
    r#"echo "$HOME""#,
    // If statements
    r#"if [ $x -eq 0 ]; then
    echo yes
fi"#,
    r#"if [ $x -gt 0 ]; then
    echo yes
fi"#,
    r#"if [ $x -lt 0 ]; then
    echo yes
fi"#,
    // For loop
    r#"for i in 1 2 3; do
    echo $i
done"#,
    // While loop
    r#"while [ $x -gt 0 ]; do
    x=$((x - 1))
done"#,
    // Functions
    r#"greet() {
    echo hello
}"#,
    r#"main() {
    echo hello
}"#,
    // Arithmetic
    "result=$((1 + 2))",
    "result=$((1 - 2))",
    "result=$((1 * 2))",
    "result=$((1 / 2))",
    "result=$((1 % 2))",
    // Pipes
    "echo hello | wc -c",
    // Arrays
    "arr=(1 2 3)",
    // Command substitution (use deterministic command, not date)
    "result=$(echo hello)",
    // Variable expansion (POSIX modifiers - these should NOT trigger SC2299)
    r#"echo "${var:-default}""#,
    r#"echo "${var:+alternate}""#,
    r#"echo "${var:=assigned}""#,
    // Redirections
    "echo hello > /dev/null",
    "cat < /dev/null",
    // Complex patterns
    r#"if [[ $x == "hello" ]]; then
    echo match
fi"#,
    r#"case "$x" in
    yes) echo one;;
    no) echo two;;
esac"#,
];

/// Test that bashrs can lint all verificar-generated bash programs without errors
#[test]
fn test_verificar_programs_lint_without_errors() {
    let bashrs = env!("CARGO_BIN_EXE_bashrs");

    let mut passed = 0;
    let mut failed = 0;
    let mut failures = Vec::new();

    for (i, program) in VERIFICAR_BASH_PROGRAMS.iter().enumerate() {
        // Create temp file
        let temp_file = format!("/tmp/bashrs_verificar_test_{}.sh", i);
        std::fs::write(&temp_file, program).unwrap();

        // Run bashrs lint
        let output = Command::new(bashrs)
            .args(["lint", &temp_file])
            .output()
            .expect("Failed to run bashrs");

        let stdout = String::from_utf8_lossy(&output.stdout);
        let stderr = String::from_utf8_lossy(&output.stderr);
        let combined = format!("{}{}", stdout, stderr);

        // Check for errors (not warnings or info)
        let has_error = combined.contains("[error]")
            || combined
                .lines()
                .any(|line| line.contains("Summary:") && !line.contains("0 error"));

        // Extract error count from summary
        let error_count = combined
            .lines()
            .find(|line| line.contains("Summary:"))
            .and_then(|line| {
                line.split_whitespace()
                    .next()
                    .and_then(|s| s.parse::<u32>().ok())
            })
            .unwrap_or(0);

        if error_count == 0 && !has_error {
            passed += 1;
        } else {
            failed += 1;
            failures.push((i, program.lines().next().unwrap_or(""), combined.clone()));
        }

        // Cleanup
        let _ = std::fs::remove_file(&temp_file);
    }

    // Report failures
    if !failures.is_empty() {
        eprintln!("\nVerificar integration test failures:");
        for (i, first_line, output) in &failures {
            eprintln!("  Test {}: {}", i, first_line);
            for line in output.lines().filter(|l| l.contains("[error]")) {
                eprintln!("    {}", line);
            }
        }
    }

    assert!(
        failed == 0,
        "Verificar integration: {} passed, {} failed out of {}",
        passed,
        failed,
        VERIFICAR_BASH_PROGRAMS.len()
    );
}

/// Test that bashrs correctly identifies issues in verificar programs
#[test]
fn test_verificar_programs_issue_detection() {
    let bashrs = env!("CARGO_BIN_EXE_bashrs");

    // Programs that should have warnings (unquoted variables)
    let programs_with_warnings = [
        ("echo $x", "SC2086"),                               // Unquoted variable
        ("for i in 1 2 3; do\n    echo $i\ndone", "SC2086"), // Unquoted in loop
    ];

    for (program, expected_rule) in programs_with_warnings {
        let temp_file = "/tmp/bashrs_verificar_warning_test.sh";
        std::fs::write(temp_file, program).unwrap();

        let output = Command::new(bashrs)
            .args(["lint", temp_file])
            .output()
            .expect("Failed to run bashrs");

        let combined = format!(
            "{}{}",
            String::from_utf8_lossy(&output.stdout),
            String::from_utf8_lossy(&output.stderr)
        );

        assert!(
            combined.contains(expected_rule),
            "Expected {} for program: {}\nGot: {}",
            expected_rule,
            program.lines().next().unwrap_or(""),
            combined
        );

        let _ = std::fs::remove_file(temp_file);
    }
}

/// Test that non-deterministic commands are properly detected
#[test]
fn test_non_deterministic_detection() {
    let bashrs = env!("CARGO_BIN_EXE_bashrs");

    // These should trigger DET002 (non-deterministic)
    let non_deterministic_programs = [("result=$(date)", "DET002"), ("now=$(date +%s)", "DET002")];

    for (program, expected_rule) in non_deterministic_programs {
        let temp_file = "/tmp/bashrs_nondet_test.sh";
        std::fs::write(temp_file, program).unwrap();

        let output = Command::new(bashrs)
            .args(["lint", temp_file])
            .output()
            .expect("Failed to run bashrs");

        let combined = format!(
            "{}{}",
            String::from_utf8_lossy(&output.stdout),
            String::from_utf8_lossy(&output.stderr)
        );

        assert!(
            combined.contains(expected_rule),
            "Expected {} for non-deterministic program: {}\nGot: {}",
            expected_rule,
            program,
            combined
        );

        let _ = std::fs::remove_file(temp_file);
    }
}

/// Test that POSIX parameter modifiers don't trigger SC2299
#[test]
fn test_posix_modifiers_no_sc2299() {
    let bashrs = env!("CARGO_BIN_EXE_bashrs");

    // These should NOT trigger SC2299
    let posix_modifier_programs = [
        r#"echo "${var:-default}""#,
        r#"echo "${var:+alternate}""#,
        r#"echo "${var:=assigned}""#,
        r#"echo "${var:?error}""#,
        r#"x="${PROPTEST_THREADS:-$(nproc)}""#, // Real-world pattern from Makefile
    ];

    for program in posix_modifier_programs {
        let temp_file = "/tmp/bashrs_posix_modifier_test.sh";
        std::fs::write(temp_file, program).unwrap();

        let output = Command::new(bashrs)
            .args(["lint", temp_file])
            .output()
            .expect("Failed to run bashrs");

        let combined = format!(
            "{}{}",
            String::from_utf8_lossy(&output.stdout),
            String::from_utf8_lossy(&output.stderr)
        );

        assert!(
            !combined.contains("SC2299"),
            "SC2299 should NOT trigger for POSIX modifier: {}\nGot: {}",
            program,
            combined
        );

        let _ = std::fs::remove_file(temp_file);
    }
}
