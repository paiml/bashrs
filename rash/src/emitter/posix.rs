use super::escape::{escape_command_name, escape_shell_string, escape_variable_name};
use crate::ir::{Command, ShellIR, ShellValue};
use crate::models::{Config, Result};
use std::fmt::Write;

pub struct PosixEmitter {
    #[allow(dead_code)]
    config: Config,
}

impl PosixEmitter {
    pub fn new(config: Config) -> Self {
        Self { config }
    }

    pub fn emit(&self, ir: &ShellIR) -> Result<String> {
        let mut output = String::new();

        // Write the POSIX shell header
        self.write_header(&mut output)?;

        // Write the main content
        self.emit_ir(&mut output, ir, 0)?;

        // Write the footer
        self.write_footer(&mut output)?;

        Ok(output)
    }

    fn write_header(&self, output: &mut String) -> Result<()> {
        writeln!(output, "#!/bin/sh")?;
        writeln!(output, "# Generated by Rash v{}", env!("CARGO_PKG_VERSION"))?;
        writeln!(output, "# POSIX-compliant shell script")?;
        writeln!(output)?;

        // Set strict error handling
        writeln!(output, "set -euf")?;
        writeln!(output, "IFS=$'\\n\\t'")?;
        writeln!(output, "export LC_ALL=C")?;
        writeln!(output)?;

        // Include runtime functions if needed
        if self.needs_runtime() {
            self.write_runtime(output)?;
        }

        writeln!(output, "# Main script begins")?;
        writeln!(output, "main() {{")?;

        Ok(())
    }

    fn write_footer(&self, output: &mut String) -> Result<()> {
        writeln!(output, "}}")?;
        writeln!(output)?;
        writeln!(output, "# Cleanup on exit")?;
        writeln!(output, "trap 'rm -rf \"${{TMPDIR:-/tmp}}/rash.$$\"' EXIT")?;
        writeln!(output)?;
        writeln!(output, "# Execute main function")?;
        writeln!(output, "main \"$@\"")?;

        Ok(())
    }

    fn write_runtime(&self, output: &mut String) -> Result<()> {
        writeln!(output, "# Rash runtime functions")?;
        writeln!(output, "rash_require() {{")?;
        writeln!(output, "    if ! \"$@\"; then")?;
        writeln!(output, "        echo \"FATAL: Requirement failed: $*\" >&2")?;
        writeln!(output, "        exit 1")?;
        writeln!(output, "    fi")?;
        writeln!(output, "}}")?;
        writeln!(output)?;

        writeln!(output, "rash_download_verified() {{")?;
        writeln!(output, "    local url=\"$1\" dst=\"$2\" checksum=\"$3\"")?;
        writeln!(output, "    ")?;
        writeln!(output, "    if command -v curl >/dev/null 2>&1; then")?;
        writeln!(
            output,
            "        curl -fsSL --proto '=https' --tlsv1.2 \"$url\" -o \"$dst\""
        )?;
        writeln!(output, "    elif command -v wget >/dev/null 2>&1; then")?;
        writeln!(output, "        wget -qO \"$dst\" \"$url\"")?;
        writeln!(output, "    else")?;
        writeln!(
            output,
            "        echo \"FATAL: Neither curl nor wget found\" >&2"
        )?;
        writeln!(output, "        return 1")?;
        writeln!(output, "    fi")?;
        writeln!(output, "    ")?;
        writeln!(output, "    if command -v sha256sum >/dev/null 2>&1; then")?;
        writeln!(
            output,
            "        echo \"$checksum  $dst\" | sha256sum -c >/dev/null"
        )?;
        writeln!(output, "    elif command -v shasum >/dev/null 2>&1; then")?;
        writeln!(
            output,
            "        echo \"$checksum  $dst\" | shasum -a 256 -c >/dev/null"
        )?;
        writeln!(output, "    else")?;
        writeln!(
            output,
            "        echo \"FATAL: No checksum utility found\" >&2"
        )?;
        writeln!(output, "        return 1")?;
        writeln!(output, "    fi")?;
        writeln!(output, "}}")?;
        writeln!(output)?;

        Ok(())
    }

    fn needs_runtime(&self) -> bool {
        // For now, always include runtime - later we can analyze the IR to determine if it's needed
        true
    }

    fn emit_ir(&self, output: &mut String, ir: &ShellIR, indent: usize) -> Result<()> {
        match ir {
            ShellIR::Let { name, value, .. } => {
                let indent_str = "    ".repeat(indent + 1);
                let var_name = escape_variable_name(name);
                let var_value = self.emit_shell_value(value)?;
                writeln!(output, "{}readonly {}={}", indent_str, var_name, var_value)?;
            }

            ShellIR::Exec { cmd, .. } => {
                let indent_str = "    ".repeat(indent + 1);
                let command_str = self.emit_command(cmd)?;
                writeln!(output, "{}{}", indent_str, command_str)?;
            }

            ShellIR::If {
                test,
                then_branch,
                else_branch,
            } => {
                let indent_str = "    ".repeat(indent + 1);
                let test_expr = self.emit_test_expression(test)?;
                writeln!(output, "{}if {}; then", indent_str, test_expr)?;

                self.emit_ir(output, then_branch, indent + 1)?;

                if let Some(else_ir) = else_branch {
                    writeln!(output, "{}else", indent_str)?;
                    self.emit_ir(output, else_ir, indent + 1)?;
                }

                writeln!(output, "{}fi", indent_str)?;
            }

            ShellIR::Exit { code, message } => {
                let indent_str = "    ".repeat(indent + 1);
                if let Some(msg) = message {
                    let escaped_msg = escape_shell_string(msg);
                    writeln!(output, "{}echo {} >&2", indent_str, escaped_msg)?;
                }
                writeln!(output, "{}exit {}", indent_str, code)?;
            }

            ShellIR::Sequence(items) => {
                for item in items {
                    self.emit_ir(output, item, indent)?;
                }
            }

            ShellIR::Noop => {
                // Emit a comment for no-ops to maintain structure
                let indent_str = "    ".repeat(indent + 1);
                writeln!(output, "{}# noop", indent_str)?;
            }
        }

        Ok(())
    }

    pub fn emit_shell_value(&self, value: &ShellValue) -> Result<String> {
        match value {
            ShellValue::String(s) => Ok(escape_shell_string(s)),
            ShellValue::Bool(b) => Ok(if *b {
                "true".to_string()
            } else {
                "false".to_string()
            }),
            ShellValue::Variable(name) => Ok(format!("\"${}\"", escape_variable_name(name))),
            ShellValue::Concat(parts) => {
                let mut result = String::new();
                result.push('"');
                for part in parts {
                    match part {
                        ShellValue::String(s) => result.push_str(s),
                        ShellValue::Bool(b) => result.push_str(if *b { "true" } else { "false" }),
                        ShellValue::Variable(name) => {
                            result.push_str(&format!("${{{}}}", escape_variable_name(name)));
                        }
                        ShellValue::CommandSubst(cmd) => {
                            let cmd_str = self.emit_command(cmd)?;
                            result.push_str(&format!("$({})", cmd_str));
                        }
                        ShellValue::Concat(_) => {
                            // Nested concatenation - flatten it
                            let nested = self.emit_shell_value(part)?;
                            // Remove quotes from nested value and add content
                            if nested.starts_with('"') && nested.ends_with('"') {
                                result.push_str(&nested[1..nested.len() - 1]);
                            } else {
                                result.push_str(&nested);
                            }
                        }
                    }
                }
                result.push('"');
                Ok(result)
            }
            ShellValue::CommandSubst(cmd) => {
                let cmd_str = self.emit_command(cmd)?;
                Ok(format!("\"$({})\"", cmd_str))
            }
        }
    }

    fn emit_command(&self, cmd: &Command) -> Result<String> {
        let mut result = escape_command_name(&cmd.program);

        for arg in &cmd.args {
            result.push(' ');
            result.push_str(&self.emit_shell_value(arg)?);
        }

        Ok(result)
    }

    pub fn emit_test_expression(&self, test: &ShellValue) -> Result<String> {
        match test {
            ShellValue::Bool(true) => Ok("true".to_string()),
            ShellValue::Bool(false) => Ok("false".to_string()),
            ShellValue::Variable(name) => {
                // Test if variable is non-empty
                Ok(format!("test -n \"${}\"", escape_variable_name(name)))
            }
            ShellValue::String(s) => {
                if s == "true" || s == "0" {
                    Ok("true".to_string())
                } else {
                    Ok("false".to_string())
                }
            }
            other => {
                // For complex expressions, evaluate them and test the result
                let value = self.emit_shell_value(other)?;
                Ok(format!("test -n {}", value))
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::ir::{Command, ShellIR, ShellValue};
    use crate::models::Config;

    #[test]
    fn test_emit_simple_let() {
        let config = Config::default();
        let emitter = PosixEmitter::new(config);

        let ir = ShellIR::Let {
            name: "test_var".to_string(),
            value: ShellValue::String("hello world".to_string()),
            effects: Default::default(),
        };

        let result = emitter.emit(&ir).unwrap();
        assert!(result.contains("readonly test_var='hello world'"));
    }

    #[test]
    fn test_emit_command() {
        let config = Config::default();
        let emitter = PosixEmitter::new(config);

        let cmd = Command {
            program: "echo".to_string(),
            args: vec![ShellValue::String("hello".to_string())],
        };

        let ir = ShellIR::Exec {
            cmd,
            effects: Default::default(),
        };

        let result = emitter.emit(&ir).unwrap();
        assert!(result.contains("echo hello"));
    }

    #[test]
    fn test_emit_if_statement() {
        let config = Config::default();
        let emitter = PosixEmitter::new(config);

        let ir = ShellIR::If {
            test: ShellValue::Bool(true),
            then_branch: Box::new(ShellIR::Exec {
                cmd: Command {
                    program: "echo".to_string(),
                    args: vec![ShellValue::String("true branch".to_string())],
                },
                effects: Default::default(),
            }),
            else_branch: None,
        };

        let result = emitter.emit(&ir).unwrap();
        assert!(result.contains("if true; then"));
        assert!(result.contains("echo 'true branch'"));
        assert!(result.contains("fi"));
    }
}
