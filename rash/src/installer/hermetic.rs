//! Hermetic Build Mode for Installer Framework (#109)
//!
//! Provides lockfile-based reproducible installations with:
//! - Pinned artifact versions and hashes
//! - SOURCE_DATE_EPOCH for deterministic timestamps
//! - Lockfile drift detection
//!
//! # Usage
//!
//! ```bash
//! # Generate lockfile
//! bashrs installer lock ./my-installer
//!
//! # Run in hermetic mode
//! bashrs installer run ./my-installer --hermetic
//! ```

use crate::models::{Error, Result};
use std::collections::HashMap;
use std::path::Path;

/// Lockfile format version
pub const LOCKFILE_VERSION: &str = "1.0.0";

/// Lockfile for hermetic builds
#[derive(Debug, Clone)]
pub struct Lockfile {
    /// When the lockfile was generated
    pub generated_at: u64,
    /// Generator version
    pub generator: String,
    /// Hash of the lockfile content for verification
    pub content_hash: String,
    /// Locked artifacts
    pub artifacts: Vec<LockedArtifact>,
    /// Captured environment for reproducibility
    pub environment: LockfileEnvironment,
}

impl Lockfile {
    /// Create a new lockfile
    pub fn new() -> Self {
        Self {
            generated_at: current_timestamp(),
            generator: format!("bashrs-installer/{}", env!("CARGO_PKG_VERSION")),
            content_hash: String::new(),
            artifacts: Vec::new(),
            environment: LockfileEnvironment::capture(),
        }
    }

    /// Add a locked artifact
    pub fn add_artifact(&mut self, artifact: LockedArtifact) {
        self.artifacts.push(artifact);
    }

    /// Compute and update content hash
    pub fn finalize(&mut self) {
        self.content_hash = self.compute_hash();
    }

    /// Compute hash of lockfile content
    fn compute_hash(&self) -> String {
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};

        let mut hasher = DefaultHasher::new();

        // Hash all artifact data
        for artifact in &self.artifacts {
            artifact.id.hash(&mut hasher);
            artifact.version.hash(&mut hasher);
            artifact.sha256.hash(&mut hasher);
            artifact.url.hash(&mut hasher);
        }

        // Hash environment
        self.environment.source_date_epoch.hash(&mut hasher);

        format!("sha256:{:016x}", hasher.finish())
    }

    /// Verify lockfile integrity
    pub fn verify(&self) -> Result<()> {
        let computed = self.compute_hash();
        if computed != self.content_hash {
            return Err(Error::Validation(format!(
                "Lockfile integrity check failed: expected {}, got {}",
                self.content_hash, computed
            )));
        }
        Ok(())
    }

    /// Save lockfile to path
    pub fn save(&self, path: &Path) -> Result<()> {
        let toml = self.to_toml();
        std::fs::write(path, toml).map_err(|e| {
            Error::Io(std::io::Error::new(
                e.kind(),
                format!("Failed to write lockfile: {}", e),
            ))
        })
    }

    /// Load lockfile from path
    pub fn load(path: &Path) -> Result<Self> {
        let content = std::fs::read_to_string(path).map_err(|e| {
            Error::Io(std::io::Error::new(
                e.kind(),
                format!("Failed to read lockfile: {}", e),
            ))
        })?;

        Self::from_toml(&content)
    }

    /// Convert to TOML string
    pub fn to_toml(&self) -> String {
        let mut toml = String::new();

        toml.push_str("# Lockfile for hermetic builds\n");
        toml.push_str("# Generated by bashrs installer\n\n");

        toml.push_str("[lockfile]\n");
        toml.push_str(&format!("version = \"{}\"\n", LOCKFILE_VERSION));
        toml.push_str(&format!("generated_at = {}\n", self.generated_at));
        toml.push_str(&format!("generator = \"{}\"\n", self.generator));
        toml.push_str(&format!("content_hash = \"{}\"\n", self.content_hash));
        toml.push('\n');

        toml.push_str("[environment]\n");
        toml.push_str(&format!(
            "source_date_epoch = {}\n",
            self.environment.source_date_epoch
        ));
        toml.push_str(&format!("lc_all = \"{}\"\n", self.environment.lc_all));
        toml.push_str(&format!("tz = \"{}\"\n", self.environment.tz));
        toml.push('\n');

        for artifact in &self.artifacts {
            toml.push_str("[[locked.artifact]]\n");
            toml.push_str(&format!("id = \"{}\"\n", artifact.id));
            toml.push_str(&format!("version = \"{}\"\n", artifact.version));
            toml.push_str(&format!("url = \"{}\"\n", artifact.url));
            toml.push_str(&format!("sha256 = \"{}\"\n", artifact.sha256));
            toml.push_str(&format!("size = {}\n", artifact.size));
            toml.push_str(&format!("fetched_at = {}\n", artifact.fetched_at));
            toml.push('\n');
        }

        toml
    }

    /// Parse from TOML string
    pub fn from_toml(content: &str) -> Result<Self> {
        let mut lockfile = Lockfile::new();
        let mut in_lockfile = false;
        let mut in_environment = false;
        let mut in_artifact = false;
        let mut current_artifact: Option<LockedArtifact> = None;

        for line in content.lines() {
            let line = line.trim();

            if line.is_empty() || line.starts_with('#') {
                continue;
            }

            if line == "[lockfile]" {
                in_lockfile = true;
                in_environment = false;
                in_artifact = false;
                continue;
            }

            if line == "[environment]" {
                in_lockfile = false;
                in_environment = true;
                in_artifact = false;
                continue;
            }

            if line == "[[locked.artifact]]" {
                if let Some(artifact) = current_artifact.take() {
                    lockfile.artifacts.push(artifact);
                }
                current_artifact = Some(LockedArtifact::default());
                in_lockfile = false;
                in_environment = false;
                in_artifact = true;
                continue;
            }

            if let Some((key, value)) = parse_toml_line(line) {
                if in_lockfile {
                    match key {
                        "generated_at" => {
                            lockfile.generated_at = value.parse().unwrap_or(0);
                        }
                        "generator" => {
                            lockfile.generator = value.to_string();
                        }
                        "content_hash" => {
                            lockfile.content_hash = value.to_string();
                        }
                        _ => {}
                    }
                } else if in_environment {
                    match key {
                        "source_date_epoch" => {
                            lockfile.environment.source_date_epoch = value.parse().unwrap_or(0);
                        }
                        "lc_all" => {
                            lockfile.environment.lc_all = value.to_string();
                        }
                        "tz" => {
                            lockfile.environment.tz = value.to_string();
                        }
                        _ => {}
                    }
                } else if in_artifact {
                    if let Some(ref mut artifact) = current_artifact {
                        match key {
                            "id" => artifact.id = value.to_string(),
                            "version" => artifact.version = value.to_string(),
                            "url" => artifact.url = value.to_string(),
                            "sha256" => artifact.sha256 = value.to_string(),
                            "size" => artifact.size = value.parse().unwrap_or(0),
                            "fetched_at" => artifact.fetched_at = value.parse().unwrap_or(0),
                            _ => {}
                        }
                    }
                }
            }
        }

        // Don't forget the last artifact
        if let Some(artifact) = current_artifact {
            lockfile.artifacts.push(artifact);
        }

        Ok(lockfile)
    }

    /// Get artifact by ID
    pub fn get_artifact(&self, id: &str) -> Option<&LockedArtifact> {
        self.artifacts.iter().find(|a| a.id == id)
    }
}

impl Default for Lockfile {
    fn default() -> Self {
        Self::new()
    }
}

/// A locked artifact with pinned version and hash
#[derive(Debug, Clone, Default)]
pub struct LockedArtifact {
    /// Artifact identifier
    pub id: String,
    /// Pinned version
    pub version: String,
    /// Download URL
    pub url: String,
    /// SHA256 hash of content
    pub sha256: String,
    /// Size in bytes
    pub size: u64,
    /// When the artifact was fetched
    pub fetched_at: u64,
}

impl LockedArtifact {
    /// Create a new locked artifact
    pub fn new(id: &str, version: &str, url: &str, sha256: &str, size: u64) -> Self {
        Self {
            id: id.to_string(),
            version: version.to_string(),
            url: url.to_string(),
            sha256: sha256.to_string(),
            size,
            fetched_at: current_timestamp(),
        }
    }
}

/// Captured environment for reproducibility
#[derive(Debug, Clone)]
pub struct LockfileEnvironment {
    /// Fixed timestamp for all operations
    pub source_date_epoch: u64,
    /// Locale setting
    pub lc_all: String,
    /// Timezone
    pub tz: String,
}

impl LockfileEnvironment {
    /// Capture current environment
    pub fn capture() -> Self {
        Self {
            source_date_epoch: std::env::var("SOURCE_DATE_EPOCH")
                .ok()
                .and_then(|s| s.parse().ok())
                .unwrap_or_else(current_timestamp),
            lc_all: std::env::var("LC_ALL").unwrap_or_else(|_| "C.UTF-8".to_string()),
            tz: std::env::var("TZ").unwrap_or_else(|_| "UTC".to_string()),
        }
    }

    /// Create a deterministic environment for hermetic builds
    pub fn deterministic(source_date_epoch: u64) -> Self {
        Self {
            source_date_epoch,
            lc_all: "C.UTF-8".to_string(),
            tz: "UTC".to_string(),
        }
    }
}

impl Default for LockfileEnvironment {
    fn default() -> Self {
        Self::capture()
    }
}

/// Hermetic execution context
#[derive(Debug, Clone)]
pub struct HermeticContext {
    /// Lockfile for this execution
    pub lockfile: Lockfile,
    /// Whether to fail on lockfile drift
    pub strict: bool,
    /// Cached artifact hashes (for verification)
    artifact_cache: HashMap<String, String>,
}

impl HermeticContext {
    /// Create a new hermetic context from a lockfile
    pub fn from_lockfile(lockfile: Lockfile) -> Result<Self> {
        lockfile.verify()?;

        let artifact_cache = lockfile
            .artifacts
            .iter()
            .map(|a| (a.id.clone(), a.sha256.clone()))
            .collect();

        Ok(Self {
            lockfile,
            strict: true,
            artifact_cache,
        })
    }

    /// Load hermetic context from lockfile path
    pub fn load(lockfile_path: &Path) -> Result<Self> {
        let lockfile = Lockfile::load(lockfile_path)?;
        Self::from_lockfile(lockfile)
    }

    /// Get the SOURCE_DATE_EPOCH for this context
    pub fn source_date_epoch(&self) -> u64 {
        self.lockfile.environment.source_date_epoch
    }

    /// Verify an artifact matches the lockfile
    pub fn verify_artifact(&self, id: &str, sha256: &str) -> Result<()> {
        let expected = self
            .artifact_cache
            .get(id)
            .ok_or_else(|| Error::Validation(format!("Artifact '{}' not found in lockfile", id)))?;

        if expected != sha256 {
            return Err(Error::Validation(format!(
                "Artifact '{}' hash mismatch: lockfile={}, actual={}",
                id, expected, sha256
            )));
        }

        Ok(())
    }

    /// Check if an artifact is in the lockfile
    pub fn has_artifact(&self, id: &str) -> bool {
        self.artifact_cache.contains_key(id)
    }
}

/// Parse a TOML key = value line
fn parse_toml_line(line: &str) -> Option<(&str, &str)> {
    let mut parts = line.splitn(2, '=');
    let key = parts.next()?.trim();
    let value = parts.next()?.trim();

    // Remove quotes from string values
    let value = value.trim_matches('"');

    Some((key, value))
}

/// Get current timestamp
fn current_timestamp() -> u64 {
    use std::time::{SystemTime, UNIX_EPOCH};
    SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .map(|d| d.as_secs())
        .unwrap_or(0)
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    // =========================================================================
    // EXTREME TDD Tests for Hermetic Builds (#109)
    // =========================================================================

    #[test]
    fn test_HERMETIC_109_lockfile_create() {
        let lockfile = Lockfile::new();
        assert!(lockfile.artifacts.is_empty());
        assert!(!lockfile.generator.is_empty());
    }

    #[test]
    fn test_HERMETIC_109_lockfile_add_artifact() {
        let mut lockfile = Lockfile::new();
        let artifact = LockedArtifact::new(
            "docker-ce",
            "24.0.7",
            "https://example.com/docker.deb",
            "abc123",
            12345678,
        );

        lockfile.add_artifact(artifact);
        lockfile.finalize();

        assert_eq!(lockfile.artifacts.len(), 1);
        assert!(!lockfile.content_hash.is_empty());
    }

    #[test]
    fn test_HERMETIC_109_lockfile_get_artifact() {
        let mut lockfile = Lockfile::new();
        lockfile.add_artifact(LockedArtifact::new("test", "1.0", "url", "hash", 100));

        assert!(lockfile.get_artifact("test").is_some());
        assert!(lockfile.get_artifact("nonexistent").is_none());
    }

    #[test]
    fn test_HERMETIC_109_lockfile_toml_roundtrip() {
        let mut lockfile = Lockfile::new();
        lockfile.add_artifact(LockedArtifact::new(
            "pkg-1",
            "1.0.0",
            "https://example.com/pkg-1.tar.gz",
            "sha256:abc123",
            1024,
        ));
        lockfile.add_artifact(LockedArtifact::new(
            "pkg-2",
            "2.0.0",
            "https://example.com/pkg-2.tar.gz",
            "sha256:def456",
            2048,
        ));
        lockfile.finalize();

        let toml = lockfile.to_toml();
        let parsed = Lockfile::from_toml(&toml).unwrap();

        assert_eq!(parsed.artifacts.len(), 2);
        assert_eq!(parsed.artifacts[0].id, "pkg-1");
        assert_eq!(parsed.artifacts[1].id, "pkg-2");
        assert_eq!(parsed.content_hash, lockfile.content_hash);
    }

    #[test]
    fn test_HERMETIC_109_lockfile_persistence() {
        let temp_dir = TempDir::new().unwrap();
        let lockfile_path = temp_dir.path().join("installer.lock");

        // Create and save
        {
            let mut lockfile = Lockfile::new();
            lockfile.add_artifact(LockedArtifact::new("test", "1.0", "url", "hash", 100));
            lockfile.finalize();
            lockfile.save(&lockfile_path).unwrap();
        }

        // Load and verify
        {
            let lockfile = Lockfile::load(&lockfile_path).unwrap();
            assert_eq!(lockfile.artifacts.len(), 1);
            assert_eq!(lockfile.artifacts[0].id, "test");
        }
    }

    #[test]
    fn test_HERMETIC_109_lockfile_verify_integrity() {
        let mut lockfile = Lockfile::new();
        lockfile.add_artifact(LockedArtifact::new("test", "1.0", "url", "hash", 100));
        lockfile.finalize();

        // Valid lockfile should verify
        assert!(lockfile.verify().is_ok());

        // Tampered lockfile should fail
        lockfile.artifacts[0].sha256 = "tampered".to_string();
        assert!(lockfile.verify().is_err());
    }

    #[test]
    fn test_HERMETIC_109_context_create() {
        let mut lockfile = Lockfile::new();
        lockfile.add_artifact(LockedArtifact::new("test", "1.0", "url", "hash123", 100));
        lockfile.finalize();

        let context = HermeticContext::from_lockfile(lockfile).unwrap();
        assert!(context.has_artifact("test"));
        assert!(!context.has_artifact("nonexistent"));
    }

    #[test]
    fn test_HERMETIC_109_context_verify_artifact() {
        let mut lockfile = Lockfile::new();
        lockfile.add_artifact(LockedArtifact::new(
            "test",
            "1.0",
            "url",
            "correct-hash",
            100,
        ));
        lockfile.finalize();

        let context = HermeticContext::from_lockfile(lockfile).unwrap();

        // Correct hash should pass
        assert!(context.verify_artifact("test", "correct-hash").is_ok());

        // Wrong hash should fail
        assert!(context.verify_artifact("test", "wrong-hash").is_err());

        // Unknown artifact should fail
        assert!(context.verify_artifact("unknown", "any").is_err());
    }

    #[test]
    fn test_HERMETIC_109_environment_capture() {
        let env = LockfileEnvironment::capture();
        assert!(!env.lc_all.is_empty());
        assert!(!env.tz.is_empty());
    }

    #[test]
    fn test_HERMETIC_109_environment_deterministic() {
        let env = LockfileEnvironment::deterministic(1234567890);
        assert_eq!(env.source_date_epoch, 1234567890);
        assert_eq!(env.lc_all, "C.UTF-8");
        assert_eq!(env.tz, "UTC");
    }

    #[test]
    fn test_HERMETIC_109_source_date_epoch() {
        let mut lockfile = Lockfile::new();
        lockfile.environment = LockfileEnvironment::deterministic(1700000000);
        lockfile.finalize();

        let context = HermeticContext::from_lockfile(lockfile).unwrap();
        assert_eq!(context.source_date_epoch(), 1700000000);
    }
}

#[cfg(test)]
mod property_tests {
    use super::*;
    use proptest::prelude::*;

    proptest! {
        /// Property: Lockfile hash is deterministic
        #[test]
        fn prop_lockfile_hash_deterministic(
            id in "[a-z][a-z0-9-]{0,20}",
            version in "[0-9]+\\.[0-9]+\\.[0-9]+",
        ) {
            let mut lockfile1 = Lockfile::new();
            lockfile1.environment = LockfileEnvironment::deterministic(1000);
            lockfile1.add_artifact(LockedArtifact::new(&id, &version, "url", "hash", 100));
            lockfile1.finalize();

            let mut lockfile2 = Lockfile::new();
            lockfile2.environment = LockfileEnvironment::deterministic(1000);
            lockfile2.add_artifact(LockedArtifact::new(&id, &version, "url", "hash", 100));
            lockfile2.finalize();

            prop_assert_eq!(lockfile1.content_hash, lockfile2.content_hash);
        }

        /// Property: Different artifacts produce different hashes
        #[test]
        fn prop_lockfile_hash_unique(
            id1 in "[a-z][a-z0-9-]{1,10}",
            id2 in "[a-z][a-z0-9-]{1,10}",
        ) {
            if id1 != id2 {
                let mut lockfile1 = Lockfile::new();
                lockfile1.environment = LockfileEnvironment::deterministic(1000);
                lockfile1.add_artifact(LockedArtifact::new(&id1, "1.0", "url", "hash", 100));
                lockfile1.finalize();

                let mut lockfile2 = Lockfile::new();
                lockfile2.environment = LockfileEnvironment::deterministic(1000);
                lockfile2.add_artifact(LockedArtifact::new(&id2, "1.0", "url", "hash", 100));
                lockfile2.finalize();

                prop_assert_ne!(lockfile1.content_hash, lockfile2.content_hash);
            }
        }

        /// Property: TOML roundtrip preserves data
        #[test]
        fn prop_toml_roundtrip(
            id in "[a-z][a-z0-9]{0,15}",
            version in "[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}",
        ) {
            let mut lockfile = Lockfile::new();
            lockfile.environment = LockfileEnvironment::deterministic(1000);
            lockfile.add_artifact(LockedArtifact::new(&id, &version, "https://example.com", "hash123", 100));
            lockfile.finalize();

            let toml = lockfile.to_toml();
            let parsed = Lockfile::from_toml(&toml).unwrap();

            prop_assert_eq!(parsed.artifacts.len(), 1);
            prop_assert_eq!(&parsed.artifacts[0].id, &id);
            prop_assert_eq!(&parsed.artifacts[0].version, &version);
        }
    }
}
