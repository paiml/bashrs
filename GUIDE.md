# The Rash Guide

A comprehensive guide to using Rash‚Äîthe Rust-to-Shell transpiler.

## Table of Contents

1. [Why Rash Exists](#why-rash-exists)
2. [Installation](#installation)
3. [Your First Transpilation](#your-first-transpilation)
4. [Understanding the Safe Subset](#understanding-the-safe-subset)
5. [Real Example: Python Installer](#real-example-python-installer)
6. [Understanding Validation Rules](#understanding-validation-rules)
7. [Advanced Patterns](#advanced-patterns)
8. [Debugging Failed Transpilations](#debugging-failed-transpilations)
9. [Performance Tuning](#performance-tuning)
10. [Contributing](#contributing)

## Why Rash Exists

### The Problem with Shell Scripts

Shell scripts are everywhere‚Äîfrom `curl | sh` installers to CI/CD pipelines. But they're dangerous:

```bash
# Common mistakes that cause security issues
FILE=$1                    # Unquoted - breaks with spaces
rm -rf $HOME/$FILE        # Command injection if FILE="; sudo rm -rf /"
curl $URL | sh            # No verification
```

Every unquoted variable is a potential security hole. Every unchecked command is a failure waiting to happen.

### The Rash Solution

Write your scripts in Rust's type-safe environment, then deploy as shell:

```rust
// Rust catches errors at compile time
fn install(file: &str) {
    // Type system prevents injection
    let path = format!("{}/{}", env::var("HOME")?, file);
    
    // Error handling is required
    fs::remove_file(&path)?;
    
    // Verification is built-in
    download_and_verify(URL, "sha256:...")?;
}
```

Rash transpiles this to safe shell with all variables quoted, all errors handled, and all inputs validated.

## Installation

### Quick Install (Recommended)

```bash
# Our self-hosted installer (yes, it's transpiled from Rust!)
curl --proto '=https' --tlsv1.2 -sSf https://github.com/rash-sh/rash/releases/latest/download/install.sh | sh
```

### Package Managers

```bash
# Cargo (Rust developers)
cargo install rash

# Homebrew (macOS/Linux)
brew install rash-sh/tap/rash

# APT (Debian/Ubuntu)
echo "deb https://rash.sh/apt stable main" | sudo tee /etc/apt/sources.list.d/rash.list
sudo apt update && sudo apt install rash

# Nix
nix-env -iA nixpkgs.rash
```

### Build from Source

```bash
git clone https://github.com/rash-sh/rash
cd rash
cargo build --release
sudo cp target/release/rash /usr/local/bin/
```

### Verify Installation

```bash
$ rash --version
rash 0.1.0 (17b4a23 2025-01-04)

$ rash --help
Rust-to-Shell transpiler for deterministic bootstrap scripts

Usage: rash <COMMAND>

Commands:
  build    Transpile Rust source to shell script
  check    Check Rust source for Rash compatibility
  init     Initialize new Rash project
  verify   Verify shell script matches Rust source
  help     Print this message or the help of the given subcommand(s)
```

## Your First Transpilation

### Step 1: Initialize a Project

```bash
$ rash init hello-installer
‚úì Created hello-installer/
‚úì Generated Cargo.toml with Rash configuration
‚úì Created src/main.rs with example installer
‚úì Added .rash.toml for transpiler settings

Next steps:
  cd hello-installer
  rash build              # Transpile to install.sh
  ./install.sh --help     # Run generated script
```

### Step 2: Examine the Generated Code

```rust
// src/main.rs
use std::env;
use std::fs;
use std::process::{Command, exit};

const VERSION: &str = "0.1.0";
const BINARY_NAME: &str = "myapp";

fn main() {
    println!("{} installer v{}", BINARY_NAME, VERSION);
    
    // Parse arguments
    let args: Vec<String> = env::args().collect();
    if args.contains(&"--help".to_string()) {
        print_help();
        return;
    }
    
    // Installation logic here
    let prefix = env::var("PREFIX").unwrap_or("/usr/local".to_string());
    install_binary(&prefix)?;
}
```

### Step 3: Transpile to Shell

```bash
$ rash build
‚úì Validated 47 lines of Rust
‚úì Generated POSIX-compliant shell (312 lines)
‚úì ShellCheck validation passed (0 warnings)
‚úì Written to install.sh (4.7KB, -rwxr-xr-x)

Transpilation completed in 12ms (3.9MB/s)
```

### Step 4: Examine Generated Shell

```bash
#!/bin/sh
# Generated by Rash 0.1.0
# DO NOT EDIT - Generated from src/main.rs

set -euf
IFS=$'\n\t'

VERSION="0.1.0"
BINARY_NAME="myapp"

main() {
    echo "$BINARY_NAME installer v$VERSION"
    
    # All variables properly quoted
    if [ "$#" -gt 0 ] && [ "$1" = "--help" ]; then
        print_help
        return 0
    fi
    
    prefix="${PREFIX:-/usr/local}"
    install_binary "$prefix" || exit 1
}

# Execute main with all arguments
main "$@"
```

## Understanding the Safe Subset

Rash transpiles a **subset** of Rust designed for shell script scenarios:

### ‚úÖ Supported Features

```rust
// Variables and constants
let name = "value";
const VERSION: &str = "1.0";

// Basic types
let text: &str = "hello";
let number: i32 = 42;
let flag: bool = true;

// String operations
let path = format!("{}/bin", prefix);
let message = format!("Installing {}", name);

// Environment variables
let home = env::var("HOME")?;
let custom = env::var("PREFIX").unwrap_or("/usr/local".to_string());

// File operations
fs::create_dir_all(&path)?;
fs::write("config.txt", contents)?;
fs::remove_file("old.txt").ok(); // Ignore errors

// Process execution
Command::new("curl")
    .args(&["-o", "file.tar.gz", url])
    .status()?;

// Control flow
if condition {
    // if block
} else {
    // else block
}

for item in items {
    process(item);
}

// Error handling
download(url)?;  // Propagate errors
install().unwrap_or_else(|e| {
    eprintln!("Failed: {}", e);
    exit(1);
});

// Functions
fn helper(arg: &str) -> Result<String, Error> {
    Ok(format!("processed: {}", arg))
}
```

### ‚ùå Not Supported

```rust
// No heap allocation
let vec = Vec::new();        // ‚ùå No dynamic allocation
let boxed = Box::new(42);    // ‚ùå No heap

// No complex types
struct Config { ... }        // ‚ùå No custom types
enum Status { ... }          // ‚ùå No enums

// No async/threads
async fn download() { ... }  // ‚ùå No async
thread::spawn(|| { ... });   // ‚ùå No threads

// No external crates
use reqwest::get;            // ‚ùå No dependencies
use serde_json::Value;       // ‚ùå Core features only

// No unsafe
unsafe { ... }               // ‚ùå No unsafe blocks
```

### Why These Restrictions?

These restrictions ensure:
1. **Direct mapping to shell**: Every Rust construct maps to simple shell
2. **No runtime needed**: Generated scripts have zero dependencies
3. **Predictable output**: Easier to audit and verify
4. **Security**: No complex types means no complex vulnerabilities

## Real Example: Python Installer

Let's build a real installer that downloads, verifies, and installs Python:

```rust
// install-python.rs
use std::{env, fs, process::{Command, exit}};
use std::io::Write;

const PYTHON_VERSION: &str = "3.11.7";
const PYTHON_SHA256: &str = "abcd1234..."; // Real hash here

fn main() -> Result<(), Box<dyn Error>> {
    println!("Python {} Installer", PYTHON_VERSION);
    println!("====================");
    
    // Parse command line
    let args: Vec<String> = env::args().collect();
    let prefix = parse_prefix(&args)?;
    
    // Check prerequisites
    check_prerequisites()?;
    
    // Download Python
    let url = format!(
        "https://www.python.org/ftp/python/{}/Python-{}.tar.xz",
        PYTHON_VERSION, PYTHON_VERSION
    );
    
    println!("Downloading Python {}...", PYTHON_VERSION);
    download_file(&url, "python.tar.xz")?;
    
    // Verify checksum
    println!("Verifying checksum...");
    verify_sha256("python.tar.xz", PYTHON_SHA256)?;
    
    // Extract
    println!("Extracting...");
    Command::new("tar")
        .args(&["xf", "python.tar.xz"])
        .status()?;
    
    // Configure and build
    env::set_current_dir(format!("Python-{}", PYTHON_VERSION))?;
    
    println!("Configuring with prefix {}...", prefix);
    Command::new("./configure")
        .args(&[
            "--prefix", &prefix,
            "--enable-optimizations",
            "--with-ensurepip=install",
        ])
        .status()?;
    
    println!("Building (this may take a while)...");
    let cpus = num_cpus()?;
    Command::new("make")
        .arg(format!("-j{}", cpus))
        .status()?;
    
    println!("Installing...");
    Command::new("make")
        .arg("install")
        .status()?;
    
    // Cleanup
    env::set_current_dir("..")?;
    fs::remove_dir_all(format!("Python-{}", PYTHON_VERSION))?;
    fs::remove_file("python.tar.xz")?;
    
    println!("\n‚úì Python {} installed successfully!", PYTHON_VERSION);
    println!("  Binary: {}/bin/python3", prefix);
    println!("  To use: export PATH={}:$PATH", prefix);
    
    Ok(())
}

fn parse_prefix(args: &[String]) -> Result<String, String> {
    for i in 0..args.len() - 1 {
        if args[i] == "--prefix" {
            return Ok(args[i + 1].clone());
        }
    }
    Ok(env::var("PREFIX").unwrap_or("/usr/local".to_string()))
}

fn check_prerequisites() -> Result<(), String> {
    // Check for required tools
    for tool in &["gcc", "make", "tar", "curl"] {
        Command::new("which")
            .arg(tool)
            .status()
            .map_err(|_| format!("{} not found", tool))?;
    }
    Ok(())
}

fn download_file(url: &str, dest: &str) -> Result<(), String> {
    let status = Command::new("curl")
        .args(&[
            "--proto", "=https",
            "--tlsv1.2",
            "-sSfL",
            "-o", dest,
            url,
        ])
        .status()
        .map_err(|e| format!("Download failed: {}", e))?;
    
    if !status.success() {
        return Err("Download failed".to_string());
    }
    Ok(())
}

fn verify_sha256(file: &str, expected: &str) -> Result<(), String> {
    let output = Command::new("sha256sum")
        .arg(file)
        .output()
        .map_err(|e| format!("sha256sum failed: {}", e))?;
    
    let hash = String::from_utf8_lossy(&output.stdout);
    let actual = hash.split_whitespace().next().unwrap_or("");
    
    if actual != expected {
        return Err(format!(
            "Checksum mismatch!\nExpected: {}\nActual: {}",
            expected, actual
        ));
    }
    Ok(())
}

fn num_cpus() -> Result<usize, String> {
    let output = Command::new("nproc")
        .output()
        .or_else(|_| Command::new("sysctl")
            .args(&["-n", "hw.ncpu"])
            .output())
        .map_err(|_| "Could not determine CPU count".to_string())?;
    
    String::from_utf8_lossy(&output.stdout)
        .trim()
        .parse()
        .map_err(|_| "Invalid CPU count".to_string())
}
```

This transpiles to a production-ready installer that:
- Downloads from HTTPS only with TLS 1.2+
- Verifies SHA256 checksums
- Handles errors properly
- Cleans up on failure
- Works on Linux, macOS, BSD

## Understanding Validation Rules

Rash enforces ShellCheck rules at compile time. Here are the most important:

### SC2086: Quote Variables

```rust
// Rust input
let file = env::var("FILE")?;
fs::remove_file(file)?;

// BAD shell output (would fail validation)
rm $FILE  # Breaks with spaces, enables injection

// GOOD shell output (what Rash generates)
rm "$FILE"  # Always safe
```

### SC2046: Quote Command Substitution

```rust
// Rust input  
let count = Command::new("wc").arg("-l").output()?;
println!("Lines: {}", count);

// BAD shell output
echo Lines: $(wc -l)  # Unquoted

// GOOD shell output
echo "Lines: $(wc -l)"  # Quoted
```

### SC2164: Check cd Success

```rust
// Rust input
env::set_current_dir("/tmp")?;

// BAD shell output  
cd /tmp  # Continues even if cd fails

// GOOD shell output
cd /tmp || exit 1  # Exit on failure
```

### Custom Validation

Add your own rules in `.rash.toml`:

```toml
[validation]
level = "strict"
custom_rules = ["no-curl-pipe-sh"]

[[validation.custom_rules.no-curl-pipe-sh]]
pattern = 'curl.*\|.*sh'
message = "Never pipe curl directly to sh"
severity = "error"
```

## Advanced Patterns

### Pattern 1: Multi-Platform Support

```rust
fn detect_platform() -> &'static str {
    if cfg!(target_os = "linux") {
        if cfg!(target_arch = "x86_64") {
            "linux-amd64"  
        } else {
            "linux-arm64"
        }
    } else if cfg!(target_os = "macos") {
        if cfg!(target_arch = "aarch64") {
            "darwin-arm64"
        } else {
            "darwin-amd64"
        }
    } else {
        panic!("Unsupported platform");
    }
}
```

### Pattern 2: Robust Downloads

```rust
fn download_with_retry(url: &str, dest: &str, max_retries: u32) -> Result<(), String> {
    for attempt in 1..=max_retries {
        println!("Download attempt {}/{}...", attempt, max_retries);
        
        if download_file(url, dest).is_ok() {
            return Ok(());
        }
        
        if attempt < max_retries {
            // Exponential backoff
            let delay = 2_u32.pow(attempt);
            Command::new("sleep")
                .arg(delay.to_string())
                .status()?;
        }
    }
    
    Err(format!("Download failed after {} attempts", max_retries))
}
```

### Pattern 3: Atomic Installation

```rust
fn install_atomically(src: &str, dest: &str) -> Result<(), String> {
    let temp = format!("{}.tmp.{}", dest, process::id());
    
    // Copy to temp location
    fs::copy(src, &temp)?;
    
    // Set permissions
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let mut perms = fs::metadata(&temp)?.permissions();
        perms.set_mode(0o755);
        fs::set_permissions(&temp, perms)?;
    }
    
    // Atomic rename
    fs::rename(&temp, dest)?;
    
    Ok(())
}
```

### Pattern 4: Signal Handling

```rust
fn setup_cleanup() {
    // Register cleanup on exit
    let temp_dir = env::var("TMPDIR").unwrap_or("/tmp".to_string());
    let work_dir = format!("{}/installer.{}", temp_dir, process::id());
    
    // This becomes trap in shell
    cleanup_on_exit(work_dir);
}

fn cleanup_on_exit(path: String) {
    // Rash converts this to shell trap
    // trap 'rm -rf /tmp/installer.$$' EXIT INT TERM
}
```

## Debugging Failed Transpilations

### Common Errors and Solutions

#### Error: "Unsupported Rust construct"

```rust
// Problem
let mut vec = Vec::new();  // Dynamic allocation not supported

// Solution  
let items = ["item1", "item2", "item3"];  // Use arrays
```

#### Error: "Type not supported"

```rust
// Problem
struct Config {
    path: String,
}

// Solution
// Use simple variables instead
let config_path = "/etc/myapp";
```

#### Error: "External crate not allowed"

```rust
// Problem
use reqwest;

// Solution
// Use Command to call curl
Command::new("curl").args(&[url]).output()?;
```

### Debugging Tips

1. **Use rash check frequently**
   ```bash
   rash check src/main.rs
   ```

2. **Enable verbose output**
   ```bash
   rash build -v src/main.rs
   ```

3. **Inspect generated IR**
   ```bash
   rash build --emit-ir src/main.rs
   ```

4. **Validate incrementally**
   ```bash
   rash build --validation-level=none  # See raw output
   rash build --validation-level=minimal  # Add basic checks
   rash build --validation-level=strict  # Full validation
   ```

## Performance Tuning

### Minimize Binary Size

```toml
# .rash.toml
[output]
optimize_size = true
strip_comments = true
compress_runtime = true
```

### Speed Up Transpilation

```toml
[transpiler]
# Skip validation for trusted code
validation_level = "minimal"
# Don't verify external commands
skip_command_verification = true
```

### Optimize Generated Scripts

```toml
[optimization]
# Inline small functions
inline_threshold = 20
# Remove dead code
eliminate_dead_code = true
# Combine sequential echos
merge_outputs = true
```

## Contributing

We welcome contributions! Here's how to get started:

### Development Setup

```bash
git clone https://github.com/rash-sh/rash
cd rash
cargo build
cargo test
```

### Running Tests

```bash
# Unit tests
cargo test

# Integration tests  
cargo test --test '*'

# Fuzzing
cargo +nightly fuzz run transpiler

# Benchmarks
cargo bench
```

### Code Style

We follow standard Rust conventions:
- `cargo fmt` before committing
- `cargo clippy` must pass
- Document public APIs
- Write tests for new features

### Submitting PRs

1. Fork the repository
2. Create a feature branch
3. Write tests
4. Update documentation
5. Submit PR with clear description

See [CONTRIBUTING.md](CONTRIBUTING.md) for detailed guidelines.

---

This guide covered the essentials of using Rash. For more:
- [API Documentation](https://docs.rs/rash)
- [Examples](https://github.com/rash-sh/rash/tree/main/examples)
- [Discord Community](https://discord.gg/rash)

Happy transpiling! ü¶Ä ‚Üí üêö