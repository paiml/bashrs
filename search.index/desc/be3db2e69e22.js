rd_("Bb-ge: numeric greater than or equal0Ai-gt: numeric greater than0AcIf/else conditionallIf statementAeConditional execution210jI/O errors0Ao-le: numeric less than or equal0Af-lt: numeric less than0AjContains the success value000000000000000hPOSIX sh0AbExecute cd command0BiUnique identifier for this transformation0BaI/O Streams for WASM Bash RuntimekI/O streams1CnIntermediate representation for transpilation Intermediate \xe2\x80\xa60BiExecute tr command (translate characters)0AoExecute wc command (word count)0j: addition0AbLogical operationsAaLogical operators10CnCommand-line argument access: $1, $2, $@, etc. Sprint 27b: \xe2\x80\xa60AhAlmquist Shell (BusyBox)0l/ : division0AhContains the error value000000000000000B`A suggested fix for a diagnostic0hFor loopBhFor loop: for VAR in LIST; do BODY; doneAcFor loop with range210jKorn shell0BbLet binding (variable declaration)BhVariable assignment: readonly NAME=VALUE10AlLow - style or best practiceAlOptional: Minor improvementsBlLow-importance events (fine-grained details)210j% : modulo0A`: multiplication0jOCI format0kString type0m: subtraction0Ag32-bit unsigned integer0iZsh shell0AiAdd an effect to this setA`Add a diagnostic10AnJavaScript API for bashrs WASM0BiAbstract syntax tree types and validationAoThe original AST being verifiedlPurified ASTAiBash Abstract Syntax Tree2BlAST (Abstract Syntax Tree) for GNU Makefiles2410BaCommand-line interface for bashrs0AiCurrent working directory00oEnd byte offset0C`Environment variables (name -&gt; value mapping)AeEnvironment variables1BmEnable auto-fix suggestions (SAFE fixes only)CaApply fixes in-place (creates timestamped backup)BjApply fixes in-place (creates .bak backup)AeApply automatic fixes1AfOptional suggested fix432120C`Get the number of events currently in the buffer0BdMinimum coverage percentage required0AiCreate new capture writerAhCreate new bash executorCnCreate new virtual filesystem with standard Unix directory \xe2\x80\xa6BjCreate a new Bash parser from source code.BbCreate a new empty coverage reportCaCreate a new formatter with default configurationAlCreate new empty test reportBcCreate new Dockerfile quality scoreBnCreate a new configuration with default valuesAhCreate new quality scoreBnCreate a new test generator with given optionsCeCreate a new abstract state with basic initializationB`Create a new empty transform logAgCreate a new source mapAaCreate a new spanAoCreate a new SAFE fix (default)AgCreate a new diagnosticAfCreate an empty resultAgCreate default metadataAlCreate empty recipe metadataBbCreate a span with specific values:BmCreate a new breakpoint at the specified lineBeCreate a new empty breakpoint managerCiCreates a new <code>ReplState</code> with default values.DbCreates a new <code>ReplConfig</code> with custom resource limits.B`Create a new determinism checkerCbCreate a new replay verifier with default settingsB`Create a new idempotency checkerCnCreate a new idempotency verifier with default settings (3 \xe2\x80\xa6BgCreate a new transformation explanationAfCreate empty rationaleAfCreate new alternativeCcCreate a new ReplCompleter with default completionsAhCreate a new stack frameBnCreate a new debug session from script contentAhCreate a new explanationClCreate a new circular trace buffer with default capacity \xe2\x80\xa6CmCreate a new trace manager with default buffer size (1024 \xe2\x80\xa6CkCreate a new transpiler builder with default configuration.AiCreate new capture writerAhCreate new bash executorCnCreate new virtual filesystem with standard Unix directory \xe2\x80\xa6BjCreate a new Bash parser from source code.BbCreate a new empty coverage reportCaCreate a new formatter with default configurationAlCreate new empty test reportBcCreate new Dockerfile quality scoreBnCreate a new configuration with default valuesAhCreate new quality scoreBnCreate a new test generator with given optionsCeCreate a new abstract state with basic initializationB`Create a new empty transform logAgCreate a new source mapAaCreate a new spanAoCreate a new SAFE fix (default)AgCreate a new diagnosticAfCreate an empty resultAgCreate default metadataAlCreate empty recipe metadataBbCreate a span with specific values:BmCreate a new breakpoint at the specified lineBeCreate a new empty breakpoint managerCiCreates a new <code>ReplState</code> with default values.DbCreates a new <code>ReplConfig</code> with custom resource limits.B`Create a new determinism checkerCbCreate a new replay verifier with default settingsB`Create a new idempotency checkerCnCreate a new idempotency verifier with default settings (3 \xe2\x80\xa6BgCreate a new transformation explanationAfCreate empty rationaleAfCreate new alternativeCcCreate a new ReplCompleter with default completionsAhCreate a new stack frameBnCreate a new debug session from script contentAhCreate a new explanationClCreate a new circular trace buffer with default capacity \xe2\x80\xa6CmCreate a new trace manager with default buffer size (1024 \xe2\x80\xa6CkCreate a new transpiler builder with default configuration.AcExecute pwd command0BhVirtual Filesystem for WASM Bash RuntimeAbVirtual filesystem1BcAuto-detect (let ShellCheck decide)0AdBash shell (default)AcBash (version 3.2+)10lBoolean typeCcBoolean value (converted to \xe2\x80\x9ctrue\xe2\x80\x9d/\xe2\x80\x9cfalse\xe2\x80\x9d)10CaCase statement: case WORD in PATTERN) BODY;; esacBfCase statement (for match expressions)10AbDash shell (180KB)AeDebian Almquist Shell10BcEcho a value (for function returns)0AaCommand execution0nExit with code0AdExpression statement0AhTest failed with message0AiRegular file with contentAfText file with content10AcGlob pattern: *.txt0BdHigh - reduces build reproducibilityChShould fix: Prevents serious operational or security \xe2\x80\xa6BoHigh-importance events (actual transformations)210kHTML report000Acifeq ($(VAR),value)0BmInformational message (style, best practices)AmInfo - informational message.10AkInitialize new Rash project0kJSON formatkJSON report1hJSON AST2222222120222222kLCOV format0CcLint shell scripts or Rust source for safety issuesB`Lint Makefile for quality issuesCcLint Dockerfile for issues (existing functionality)AmLint shell configuration fileBnLint error - code quality or safety violation.CeLint mode - show linting results and safety warnings.543210CbMakefile parsing, purification, and transformation0BaNo verification (not recommended)0eNo-op0AbSuggestion or note0kTest passed0BgPerformance anti-pattern (not critical)0BbPure computation (no side effects)0CgInteractive REPL with integrated debugger (NEW in v7.0)0CcRisk: potential runtime failure (context-dependent)0BfSAFE: Semantic preservation guaranteed0A`Test was skipped0BdSource code span for error reportingBhSource span with start and end positionsAkA source code location spanAkSource location informationBdSource code span (line:column range)03421BaStatement types in restricted AST0AiTest expression: [ expr ]CkRun bash script tests (NEW in v6.10.0 - Bash Quality Tools)10AcHuman-readable text0Abassert!(condition)0AnType system for restricted AST0AkVoid type (no return value)0B`List of literal string argumentsAbFunction arguments10jMatch arms0AhFunction body statementsAdLoop body statements0AmThe actual test function bodyAmFunction body (lines of code)3221CbDiagnostic code (e.g., \xe2\x80\x9cSC2086\xe2\x80\x9d, \xe2\x80\x9cBP1001\xe2\x80\x9d)BlThe actual code that triggered the detection0BlError code (e.g., \xe2\x80\x9cDET001\xe2\x80\x9d, \xe2\x80\x9cP001\xe2\x80\x9d).2110AeCons of this approach0BbCore Test Generator Infrastructure0AdExecute echo command0BoEmit shell code from IR based on target dialectBjEmit POSIX shell code from a tiny AST node10B`Update state for exiting heredocAoSource file path (if available)0AoReturns the argument unchanged.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000B`Get recovery hint for this errorAkSuggested fix or workaround10AjInitialize the WASM module0BaCalls <code>U::from(self)</code>.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000AcIterator expressionCnGet an iterator over events in chronological order (oldest \xe2\x80\xa610BaLine number where test is definedAgLine number (1-indexed)AjLine number (if available)BoLine number where pattern was found (1-indexed)BoLine number where difference occurs (1-indexed)CaLine number where operation was found (1-indexed)AhLine number (1-indexed).CcLine number where this frame was called (1-indexed)76543210AnReturns the current REPL mode.0AbCurrent REPL mode.mFunction namenParameter namemVariable nameCgTest function name (e.g., \xe2\x80\x9ctest_my_function_basic\xe2\x80\x9d)lProject nameBiVariable name (valid POSIX variable name)ChTarget name (e.g., \xe2\x80\x9cbuild\xe2\x80\x9d, \xe2\x80\x9ctest\xe2\x80\x9d, \xe2\x80\x9cclean\xe2\x80\x9d)4CdFunction name (e.g., \xe2\x80\x9cwildcard\xe2\x80\x9d, \xe2\x80\x9cpatsubst\xe2\x80\x9d)AoName of the function or context8765432610lThe AST node0BcGet explanatory note for this errorAnAdditional context/explanation10AaProject directoryB`Absolute or simple relative pathAkHash path from leaf to rootAdFile path to includeAgPath to the script file43210AePros of this approach0BjCreate a pure effect set (no side effects)0B`Push a new event into the buffer0BiInteractive REPL with integrated debugger0nRoot directoryBdPurification rule that detected this0AeOutput from first run0AfOutput from second run0AeOutputs from each run000BoScan bash script for non-deterministic patternsBnScan bash script for non-idempotent operations10BfGet the source span for this statementoSource location0000000AbLocation in source2111111110AgExecute one line (step)0BnUTF-8 normalized text, zero-copy when possibleBcComment text (without the # prefix)10CaThe preprocessed text with continuations resolvedAiTHEN clause from comments0AnWebAssembly Support for bashrs0AiWHEN clause from comments0AoArray/list: (item1 item2 item3)nCompound types10CjRun comprehensive quality audit (NEW in v6.12.0 - Bash \xe2\x80\xa60AhBasic safety checks only0CkBenchmark shell script(s) with scientific rigor (NEW in \xe2\x80\xa60oBreak statement000BeTranspile Rust source to shell script0BhCheck Rust source for Rash compatibility0lDebug formatCeDebug mode - step-by-step execution with breakpoints.10CfError redirection: 2&gt; file Redirects stderr to fileCcError (definite syntax or semantic error, must fix)AfError - must be fixed.210Acassert!(!condition)0AeHuman-readable format0AeHuman-readable report111AoHuman-readable format (default)2212220iifdef VAR0Adifneq ($(VAR),value)0CmInput redirection: &lt; file Redirects file contents to stdin0AbInteger comparison0A`JUnit XML format0BcMatch expression (pattern matching)0B`Works in bash/zsh/ksh but not sh0Ae-eq: numeric equality0Ag-ne: numeric inequality0AeParse Makefile to ASTBjParse error - syntax error in bash script.10B`POSIX sh - maximum compatibility0lSARIF formatBgSARIF format (for GitHub Code Scanning)CiSARIF format (Static Analysis Results Interchange Format)210ClScore bash script quality (NEW in v6.11.0 - Bash Quality \xe2\x80\xa60BmShell assignment (!=) - execute shell command0Ab=: string equality0Ae!=: string inequality0AlToken with type and position0BhInternal engine events (structural only)0BhUnion types for shell\xe2\x80\x99s dynamic nature0CmUntil loop: until CONDITION; do BODY; done Note: Purified \xe2\x80\xa60jWhile loop00000B`~/.zshrc - Zsh interactive shell0AjBuild the final source map0B`Change current working directory0CkCheck if the given Rust code is valid for transpilation \xe2\x80\xa6CeCheck if files are formatted without applying changesCmCheck for sed usage that could be replaced with parameter \xe2\x80\xa6AlCheck for useless use of catCbCheck for deprecated backtick command substitutionC`Check for wrong quoting in printf format stringsCdCheck for echo with escape sequences without -e flagBkCheck for variables assigned but never usedBoCheck for useless for loops with single elementBkCheck for find in for loops without -print0AiCheck for ls in for loopsCaCheck for unquoted command substitutions (SC2046)BmCheck for unquoted $* that should be \xe2\x80\x9c$@\xe2\x80\x9dCgCheck for constant comparisons (missing $ on variables)CfCheck for unquoted variables in [[ \xe2\x80\xa6 ]] conditionalsDeCheck for unquoted array expansions ($@, $<em>, ${array[@]}, </em>\xe2\x80\xa6CjCheck for implicit string length tests that should use \xe2\x80\xa6CeCheck for string comparison operators used on numbersC`Check for decimal numbers in arithmetic contextsCaCheck for quoted regex patterns in =~ comparisonsCeCheck for variable/command expansion in single quotesBoCheck for unquoted variable expansions (SC2086)ChCheck for useless echo in command substitutions (SC2116)BgCheck for array reference without indexBoCheck for variables referenced but not assignedAnCheck for read without -r flagBcCheck for cd without error handlingBmCheck for string assignment to array variableBaCheck for indirect $? comparisonsBhCheck for associative array without keysCcCheck for space between = and ( in array assignmentBiCheck for deprecated egrep/fgrep commandsBgCheck for $RANDOM usage in shell scriptBiCheck for timestamp usage in shell scriptBbCheck for unordered wildcard usageAoCheck for mkdir without -p flagAlCheck for rm without -f flagBcCheck for ln -s without rm -f firstBdCheck for command injection via evalCbCheck for unquoted variables in dangerous commandsBcCheck for unquoted {} in find -execC`Check for disabled TLS verification in wget/curlAkCheck for hardcoded secretsBhCheck for unsafe temporary file creationB`Check for unsafe sudo operationsBbCheck for curl/wget piped to shellBoCheck for unordered wildcard usage in MakefilesChCheck for non-idempotent mkdir usage in Makefile recipesCjCheck for unquoted variable expansions in Makefile recipesBeCheck for missing .PHONY declarationsCjCheck for recursive variable assignments with $(shell \xe2\x80\xa6)BkCheck for targets with missing dependenciesBoCheck for echo/printf commands without @ prefixC`Check for spaces instead of tabs in recipe linesBfCheck for hardcoded installation pathsCcCheck for missing error handling in recipe commandsBaCheck for dangerous pattern rulesBdCheck for recursive make invocationsClCheck for missing .SUFFIXES to disable built-in implicit \xe2\x80\xa6BgCheck for inefficient shell invocationsCaCheck for missing .DELETE_ON_ERROR special targetBmCheck for unquoted variables in prerequisitesBeCheck for missing .ONESHELL directiveBaCheck for parallel-unsafe targetsBgCheck for unnecessary export statementsCkCheck for missing include guards in Makefiles meant for \xe2\x80\xa6CkCheck for missing USER directive in non-scratch DockerfilesCkCheck if the given Rust code is valid for transpilation \xe2\x80\xa6CeCheck if files are formatted without applying changesCmCheck for sed usage that could be replaced with parameter \xe2\x80\xa6AlCheck for useless use of catCbCheck for deprecated backtick command substitutionC`Check for wrong quoting in printf format stringsCdCheck for echo with escape sequences without -e flagBkCheck for variables assigned but never usedBoCheck for useless for loops with single elementBkCheck for find in for loops without -print0AiCheck for ls in for loopsCaCheck for unquoted command substitutions (SC2046)BmCheck for unquoted $* that should be \xe2\x80\x9c$@\xe2\x80\x9dCgCheck for constant comparisons (missing $ on variables)CfCheck for unquoted variables in [[ \xe2\x80\xa6 ]] conditionalsDeCheck for unquoted array expansions ($@, $<em>, ${array[@]}, </em>\xe2\x80\xa6CjCheck for implicit string length tests that should use \xe2\x80\xa6CeCheck for string comparison operators used on numbersC`Check for decimal numbers in arithmetic contextsCaCheck for quoted regex patterns in =~ comparisonsCeCheck for variable/command expansion in single quotesBoCheck for unquoted variable expansions (SC2086)ChCheck for useless echo in command substitutions (SC2116)BgCheck for array reference without indexBoCheck for variables referenced but not assignedAnCheck for read without -r flagBcCheck for cd without error handlingBmCheck for string assignment to array variableBaCheck for indirect $? comparisonsBhCheck for associative array without keysCcCheck for space between = and ( in array assignmentBiCheck for deprecated egrep/fgrep commandsBgCheck for $RANDOM usage in shell scriptBiCheck for timestamp usage in shell scriptBbCheck for unordered wildcard usageAoCheck for mkdir without -p flagAlCheck for rm without -f flagBcCheck for ln -s without rm -f firstBdCheck for command injection via evalCbCheck for unquoted variables in dangerous commandsBcCheck for unquoted {} in find -execC`Check for disabled TLS verification in wget/curlAkCheck for hardcoded secretsBhCheck for unsafe temporary file creationB`Check for unsafe sudo operationsBbCheck for curl/wget piped to shellBoCheck for unordered wildcard usage in MakefilesChCheck for non-idempotent mkdir usage in Makefile recipesCjCheck for unquoted variable expansions in Makefile recipesBeCheck for missing .PHONY declarationsCjCheck for recursive variable assignments with $(shell \xe2\x80\xa6)BkCheck for targets with missing dependenciesBoCheck for echo/printf commands without @ prefixC`Check for spaces instead of tabs in recipe linesBfCheck for hardcoded installation pathsCcCheck for missing error handling in recipe commandsBaCheck for dangerous pattern rulesBdCheck for recursive make invocationsClCheck for missing .SUFFIXES to disable built-in implicit \xe2\x80\xa6BgCheck for inefficient shell invocationsCaCheck for missing .DELETE_ON_ERROR special targetBmCheck for unquoted variables in prerequisitesBeCheck for missing .ONESHELL directiveBaCheck for parallel-unsafe targetsBgCheck for unnecessary export statementsCkCheck for missing include guards in Makefiles meant for \xe2\x80\xa6CkCheck for missing USER directive in non-scratch DockerfilesB`Clear all events from the bufferAnClear all events in the buffer10BdGet the number of active breakpoints0AaEnable debug modeBcEnable debug mode (default: false).10ChCreate a dummy span (for testing or when location is \xe2\x80\xa60AkCreate an empty Merkle tree0BaUpdate state for entering heredocAdThe underlying errorBhEnhanced error types for Makefile parser10AhExact character position0AjGIVEN clause from comments0AgOverall grade (A+ to F)000BeInfer dialect with confidence scoring0AlPath to the Rust source fileoInput Rust file0CaInput AST file (JSON) or inline AST specificationBhInput file (shell script or Rust source)AfInput bash script file0000CcInput config file (.bashrc, .zshrc, .profile, etc.)AaInput config file0nInput Makefile00A`Input Dockerfile0AmSet the input Rust file path.9887655555433222110CbAll items in the Makefile (targets, variables, \xe2\x80\xa60CfGet a human-readable label for this significance level0jBash LexerAcLexer for Makefiles01BbLines of the script being debuggedClMerge with another configuration, preferring non-default \xe2\x80\xa6BbMerge another result into this one10A`Create directory0AdAvailable mode namesBkParse the tokenized script into a Bash AST.BiParse mode from string (case-insensitive)BkParse Rust source code into a RestrictedAst210BgWhether this target is marked as .PHONY0B`Create a span for a single point0BlOptional SMT proof for semantic preservationBaSMT formula asserting equivalence10AhSuppress progress output0CkFilter by specific rules (comma-separated: MAKE001,MAKE003)BnFilter by specific rules (comma-separated: \xe2\x80\xa610BdLint rules for shell script analysis0AjNumeric score (0.0 - 10.0)000AaStart byte offset0AlGet statistics about the logB`Get statistics about the mappingAeGet buffer statisticsCfGet buffer statistics (retention rate, capacity, etc.)3210oExecution steps0AdAll discovered tests0BaBrief title of the transformationAfTitle of the construct10BgCore type definitions for the formatter0BhUnification algorithm for type inferenceAeUnion two effect sets0mInitial valueAdLiteral string valuenVariable value210CnAppend redirection: &gt;&gt; file Redirects stdout to file \xe2\x80\xa6BcAppend (+=) - add to existing value10Bb~/.bashrc - Bash interactive shell0AdString concatenationAcConcatenated values10CaShell configuration file management (NEW in v7.0)0BhConfiguration options for transpilation.0AnFeature is directly compatible0mDocker format0CmEnvironment variable expansion: ${VAR} or ${VAR:-default} \xe2\x80\xa60Alassert_eq!(actual, expected)0CiFormat bash scripts (NEW in v6.14.0 - Bash Quality Tools)0jifndef VAR0AhMedium - potential issueCaRecommended: Improves robustness and reduces riskBkMedium-importance events (rule evaluations)210CgNormal mode - execute bash commands directly (default).0mOptional type0CjOutput redirection: &gt; file Redirects stdout to file \xe2\x80\xa60ChPurify bash scripts (determinism + idempotency + safety)BkPurify Makefile (determinism + idempotency)CkPurify Dockerfile (auto-fix security and best practices \xe2\x80\xa6CjPurify shell configuration file (fix issues automatically)CnPurify mode - show purified, deterministic version of bash \xe2\x80\xa643210A`$RANDOM variable0BfResult type with ok and error variants0BdReturn statement with optional valueA`Return statement10BoRule identifier (e.g., IDEM001, DET003, SEC002)0BiPrevents injection, race conditions, etc.0AfPOSIX sh only (strict)0CiSimple assignment (:=) - expanded immediately (PREFERRED)0BaStrict verification (recommended)0oPrimitive typesnString literal10AcSyntax/parse errors0BfA target with prerequisites and recipe0BhUNSAFE: Semantic transformation required0BgVerify shell script matches Rust source0AlArrays (name -&gt; elements)AgGet mode name as string0AoRash - Rust to Shell TranspilerBjANSI color codes for terminal highlightingAlColumn number (if available)AjColumn number (1-indexed).AjConfig management for WASMAkTranspilation configurationAeConfiguration optionsBdSet the transpilation configuration.CjShell configuration file management and analysis Shell \xe2\x80\xa6BlCompressed span deltas for memory efficiencyBgDET001: Non-deterministic $RANDOM usageBiDET002: Non-deterministic timestamp usageB`DET003: Unordered wildcard usageAfEnable this breakpointBnNormalization engine for syntax transformationAhAny errors that occurredBcEvent storage (circular FIFO queue)AdCheck if path existsAbCount failed testsBjExecute until the current function returnsBcVariable flavor (=, :=, ?=, +=, !=)CcFormal verification and proof generation Formal \xe2\x80\xa6AaFormat a bash ASTmOutput format00000000mReport format101BbFormat the load result for displayBgFormat the execution result for displayAnFormat explanation for displayAmGet current working directoryBlTree height (log2 of leaf count, rounded up)AiInput bash script file(s)AbLength of the spanBbLength of the problematic section.CiShell script linting with ShellCheck-equivalent rules \xe2\x80\xa6CkMinimal runtime loader for embedded scripts This module \xe2\x80\xa6AjREPL Script Loading ModuleBnMedian Absolute Deviation (robust to outliers)BfConfiguration types and error handlingAhOutput shell script fileB`Output file (defaults to stdout)AbOutput binary pathAmOutput file for fixed content2B`Output file for HTML/LCOV formatBcOutput file (for single input file)AkOutput results to JSON fileCiOutput file (defaults to stdout, or in-place with \xe2\x80\x93fix)ChOutput file (defaults to stdout or in-place with \xe2\x80\x93fix)BnOutput file (defaults to in-place with \xe2\x80\x93fix)1BaSet the output shell script path.BbOutput formatters for lint resultsAcFunction parameterskBash ParseroMakefile parserAbCount passed testsBeCONFIG-002: Quote Variable ExpansionsC`Recipe lines (commands to execute, tab-indented)lRecipe linesBcShow detailed transformation report00AiReport of transformationsAiSafety score (0.0 - 10.0)0CjSC2001: See if you can use ${variable//search/replace} \xe2\x80\xa6AjSC2002: Useless use of catBnSC2006: Use $(\xe2\x80\xa6) instead of legacy backticksBfSC2008: Echo doesn\xe2\x80\x99t read from stdinCjSC2009: Consider using pgrep instead of grepping ps outputCiSC2010: Don\xe2\x80\x99t use ls | grep. Use a glob or find insteadCiSC2011: Use find -print0 | xargs -0 instead of ls | xargsCcSC2012: Use find instead of ls to better handle \xe2\x80\xa6CmSC2013: To read lines rather than words, pipe/redirect to \xe2\x80\xa6CgSC2014: This will expand before brace expansion happensBnSC2027: Wrong quoting in printf format stringsBlSC2028: Echo may not expand escape sequencesBhSC2034: Variable assigned but never usedCnSC2043: Use direct command instead of for loop with single \xe2\x80\xa6CmSC2044: Use find with -print0 and read -d \xe2\x80\x98\xe2\x80\x99 for safe \xe2\x80\xa6BkSC2045: Don\xe2\x80\x99t use ls output for iterationCgSC2046: Quote command substitutions to prevent word \xe2\x80\xa6CfSC2048: Use \xe2\x80\x9c$@\xe2\x80\x9d (with quotes) to prevent word \xe2\x80\xa6CmSC2050: This expression is constant. Did you forget the $ \xe2\x80\xa6ClSC2066: Quote variables in [[ \xe2\x80\xa6 ]] to prevent globbing \xe2\x80\xa6CmSC2068: Double quote array expansions to prevent globbing \xe2\x80\xa6BiSC2070: Use -n/-z for string length testsChSC2071: Use arithmetic comparison, not string comparisonCkSC2072: Decimal numbers not supported in arithmetic contextCfSC2076: Don\xe2\x80\x99t quote right-hand side of =~ (regex \xe2\x80\xa6ClSC2081: Expressions don\xe2\x80\x99t expand in single quotes, use \xe2\x80\xa6CkSC2086: Double quote to prevent globbing and word splittingCeSC2116: Useless echo wrapping in command substitutionCnSC2128: Expanding an array without an index only gives the \xe2\x80\xa6BlSC2154: Variable referenced but not assignedBoSC2162: read without -r will mangle backslashesBkSC2164: Use cd \xe2\x80\xa6 || exit in case cd failsCmSC2178: Variable was used as an array but is now assigned \xe2\x80\xa6CmSC2181: Check exit code directly with e.g. \xe2\x80\x98if mycmd;\xe2\x80\x99\xe2\x80\xa6CkSC2190: Elements in associative arrays need index, e.g. \xe2\x80\xa6CmSC2191: The = here is literal. To assign by index, use ( [\xe2\x80\xa6CmSC2196: egrep is deprecated and non-standard. Use grep -E \xe2\x80\xa6BbSEC001: Command Injection via evalBdSEC002: Unquoted Variable in CommandBfSEC003: Unquoted find -exec {} PatternBjSEC004: wget/curl Without TLS VerificationAiSEC005: Hardcoded SecretsBfSEC006: Unsafe Temporary File CreationCcSEC007: Running Commands as Root Without ValidationBlSEC008: Using <code>curl | sh</code> PatternBiCreate an effect set with a single effectAmRust source code to transpileoCaptured stderrAaGet stderr outputAeStandard error buffernStandard errorAoStandard error from the commandBbStandard library function mappingsoCaptured stdoutAaGet stdout outputAfStandard output bufferoStandard outputB`Standard output from the commandBeEnable strict mode (fail on warnings)0C`Enable quality gates (lint + determinism checks)BnWhether to enable strict mode (default: false)AdTarget shell dialectBjTarget shell dialect for generated scriptsAkGet all effects as a vectorAmVerification stringency levelCcLevel of verification to apply during transpilationCcVerify determinism by running script multiple timesCcVerify script idempotency by running multiple timesCdVerify that the given IR satisfies safety propertiesAkNumber of warmup iterationsBkAnalyze shell configuration file for issuesCaRoot AST node representing a complete bash scriptAa$BASHPID variableAeWorks in bash and zshoBusybox (900KB)AlByte position in source textAbCase statement armBaCharacter position in source textBcCommand execution: echo \xe2\x80\x9chello\xe2\x80\x9dC`Normal command context: collapse to single spaceC`Command error - unknown or invalid REPL command.BeComment (preserved for documentation)nA comment lineAiComment for documentationAlCompile to standalone binaryAmReading environment variablesCkExplain mode - educational explanations of bash constructs.AdGeneric shell scriptBaGeneric transformation (fallback)AoHere-document: preserve exactlyAdAn include directiveBnGenerate formal verification inspection reportnString literalBnRoot AST node representing a complete MakefileAjMinimal interpreter (50KB)BhNon-null constraint: variable is definedAn~/.profile - POSIX login shellAeQuality check resultsBbRuntime error - execution failure.AjScript loaded successfullymSymbolic linkBaThe tiny subset of rash AST nodesAlType variables for inferenceAgVirtual filesystem nodeB`Warning (likely bug, should fix)AjWarning - should be fixed.AjZsh-specific features onlyAhAdd a con (disadvantage)AeAdd a pro (advantage)BiCONFIG-003: Consolidate Duplicate AliasesBiAnalyze test suite and calculate coverageBkAuto-fix application for linter diagnosticsAdBash Code GenerationBkCode Generation for Bash-to-Rash TranspilerBdMonoid composition with optimizationBoCompose semantic deltas (associative operation)CeSource code context showing where the error occurred.BiDefault significance is MEDIUM (balanced)AdDetailed explanationC`Shell dialect detection and compatibility systemAhWhether the lines differAgDisable this breakpointBcGet a human-readable representationBbShow diff without applying changesBdDry run (show what would be changed)BlShow changes without applying (dry-run mode)BkDry-run mode (don\xe2\x80\x99t actually modify file)CbGet all effects from this IR node and its childrenC`Get elapsed time since trace manager was createdAoEmit a change directory commandAjShell script code emissionBfFormal emitter for the tiny AST subsetAfEnd column (1-indexed)AjAll transformation entriesBeCode example showing this alternativemExample usageAiExecute a builtin commandAeExecute a bash scriptCfB+ tree for forward mapping (original -&gt; formatted)AkGet an environment variableBaGet an environment variable valueBgReturns a slice of all history entries.BoCommand history (for up/down arrow navigation).AmIDEM001: Non-idempotent mkdirAjIDEM002: Non-idempotent rmAjIDEM003: Non-idempotent lnBlGenerate a comprehensive verification reportAnCheck if buffer is at capacityB`Check if this effect set is pureCcCheck if this IR node is pure (has no side effects)ChCheck if this fix can be applied with <code>--fix</code>CdTransform logging with Merkle tree for integrity \xe2\x80\xa6CfMAKE001: Non-deterministic wildcard usage in MakefilesCaMAKE002: Non-idempotent mkdir in Makefile recipesCfMAKE003: Unsafe variable expansion in Makefile recipesChMAKE004: Missing .PHONY declaration for non-file targetsCcMAKE005: Recursive variable assignment in MakefilesBdMAKE006: Missing target dependenciesC`MAKE007: Silent recipe errors (missing @ prefix)BlMAKE008: Tab vs spaces in recipes (CRITICAL)BgMAKE009: Hardcoded paths (non-portable)BkMAKE010: Missing error handling (|| exit 1)B`MAKE011: Dangerous pattern rulesBjMAKE012: Recursive make considered harmfulBnMAKE013: Missing .SUFFIXES (performance issue)BeMAKE014: Inefficient shell invocationBaMAKE015: Missing .DELETE_ON_ERRORBkMAKE016: Unquoted variable in prerequisitesAjMAKE017: Missing .ONESHELLCbMAKE018: Parallel-unsafe targets (race conditions)BgMAKE019: Environment variable pollutionAnMAKE020: Missing include guardAfHuman-readable messageAaIssue descriptionAcMain error message.oOk variant typeChP-value (probability of observing this difference by \xe2\x80\xa6AeLoop variable patternAoRun only tests matching patternCgCharacter-level precision with token boundary awarenessAeResults for each testCfB+ tree for reverse mapping (formatted -&gt; original)lRuntime typeAdBash Quality ScoringAlShell script(s) to benchmarkAkSet an environment variableAcCount skipped testsAkCode snippet (if available)BmSpeedup factor (baseline_mean / current_mean)0B`Whether execution was successfulAjTesting score (0.0 - 10.0)AcBash Test FrameworkB`Timeout in seconds (default: 30)CeExecution timeout for commands (default: 30 seconds).BaSave configuration to a TOML fileAiGet result as JSON stringBdConvert configuration to TOML stringBdConvert to TOML configuration formatCdTracing infrastructure for diagnostics and debuggingAeEnable verbose outputAbGet bashrs versionCiArgument count: $# Sprint 27b: Command-Line Arguments \xe2\x80\xa6AiExpression-level AST nodeAjWrapper type for AST nodesAkBash-specific features onlyAhStatement-level AST nodeBbA discovered test in a bash scriptBcUnique identifier for a code branchAfBash built-in commandsDbCombined redirection: &amp;&gt; file (bash-specific) Redirects \xe2\x80\xa6AbContinue statement0AfContract specificationCkGenerate coverage report (NEW in v6.13.0 - Bash Quality \xe2\x80\xa6BlCritical - breaks determinism or idempotencyChMust fix: Prevents catastrophic failures or critical \xe2\x80\xa6C`Critical events (conflicts, security violations)CgExit code of last command: $? Sprint 27c: Exit Code \xe2\x80\xa6AbReading from filesBcFile type affects suppression rulesBnExecution completed without hitting breakpointAcFunction definition0BfFunction declaration in restricted ASTAhInternal compiler errorsBgStatistics about the transformation logCjMakefile constructs (targets, variables, conditionals, \xe2\x80\xa6oMarkdown reportoMarkdown format1AnMaximum verification (slowest)AoPatterns for variable detectionCnPipeline: cmd1 | cmd2 | cmd3 Chains multiple commands with \xe2\x80\xa6CgPurifies bash AST to ensure idempotency and determinismCgRedirection operator Represents I/O redirection for \xe2\x80\xa6CiREPL execution modes for different command processing \xe2\x80\xa6B`Sequential execution of commandsAfSequence of operationsAbViolation severityAnSeverity level of a diagnosticBgSeverity level for errors and warnings.AaString comparisonAkTerminal output with colorsAmTest expression (conditional)AbA single unit testBbVariable reference: $VAR or ${VAR}AbVariable referenceAeA variable assignmentAm~/.zprofile - Zsh login shellBaShell configuration file analyzerBbBrief description of this approachAjThe AST node being emittedBhbuild.rs integration with auto-discoveryBgBuilt-in Bash Commands for WASM RuntimeBgGet the maximum capacity of this bufferB`Maximum capacity (default: 1024)BlError category (for grouping similar errors)AjCategory of transformationBeChild annotations for composite nodesBdList of commands to execute in orderB`REPL commands (without : prefix)AlComments and their positionsChRust compiler integration for transpilation Compiler \xe2\x80\xa6CcCheck if this effect set contains a specific effectCiContract system for shell-specific type inference and \xe2\x80\xa6AnCoverage Tracking and AnalysisAgInclude detailed tracesAjShow detailed test resultsAnShow detailed dimension scoresAkShow detailed check resultsB`Show detailed coverage breakdownBoCreate a disabled trace manager (zero overhead)AmDoctest Generation (Sprint 3)AdEnd line (1-indexed)AbError variant typeBeBash Script Executor for WASM RuntimeAmREPL Command Execution ModuleAmWhether execution is completeAgConvert AST to Shell IRBjGenerate complete test suite from bash ASTA`Get node at pathBlCreate identity mapping for unchanged sourceCdTrue if purified code has no critical violations \xe2\x80\xa6AlCheck if the buffer is emptyBiCheck if character at position is a quoteAnCheck if the AST node is validAnList all environment variablesBkGet the location information for this errorlLog metadataC`Semantic annotations preserved across transformsAkMetadata about the MakefileBhOptimize Shell IR based on configurationAmEnable IR optimization passesBoWhether to optimize the output (default: false)BcWhether this is optional (-include)AeOriginal code snippetAbOriginal bash lineBjEnable parallel processing for large filesBeTranslation Patterns for Bash-to-RashAlPurified version of the lineBaShell configuration file purifierAiMain REPL loop for bashrs0AkSecurity score (0.0 - 10.0)AnSemantic Analysis for Bash ASTBbSemantic analysis for Makefile ASTAlParser and compiler servicesAcSets the REPL mode.nSeverity level00BfSeverity level (Error, Warning, Info).AhShow raw iteration timesBjGet a snapshot of the current trace bufferBoTiny subset of rash AST for formal verificationAnType environment for variablesCkUse tabs instead of spaces for indentation (default: false)CbValidate that an AST conforms to Rash restrictionsCgValidates the configuration and returns an error if \xe2\x80\xa6BnOutput verification and shellcheck integrationBnWalk an AST and call the visitor for each nodeCmWalk a directory recursively and apply a function to each \xe2\x80\xa6BaAny warnings during transpilationAcAdd a suggested fixAoActive whitespace context stackCbAdded a flag to command (e.g., mkdir \xe2\x86\x92 mkdir -p)AeArithmetic expressionAdTest assertion typesChUnique identifier for AST nodes (cheap to copy, 8 bytes)CjB+ tree for O(log n) point queries, O(k + log n) range \xe2\x80\xa6AhWorking directory changeAgDirectory with childreniDirectoryDbFile descriptor duplication: 2&gt;&amp;1 Duplicates from_fd to \xe2\x80\xa6AjELF structures for parsingAkEnvironment variable changeBjError type categorization for REPL errors.B`File not found or cannot be readA`Writing to filesAhResult of applying fixesBjPattern for translating bash if statementsAnI/O streams for bash executionnLinting eventsAiLogical OR (||) operationAlassert_ne!(actual, expected)BdFunction parameter in restricted ASTB`A PATH entry found in the configo$$ (process ID)BmRecursive assignment (=) - expanded when usedBaMutable state for a REPL session.BeOutput from a single script executionBiTracks variable scopes and their metadataBhShell-specific type system for contractsAeSupported shell typesBlCharacter-level bidirectional source mappingBlCompressed span deltas for memory efficiencyBddate command or timestamp generationBbToken type for syntax highlightingBoTransformations form a monoid under compositionAfType error informationBhWorks in all shells (bash, zsh, sh, ksh)AkVariable assignment flavorsA`Linter violationAnAdd a new transformation entryAbAdd token boundaryBdGet captured content as UTF-8 stringAeClear all breakpointsAdCondition expressionnLoop conditionnCondition typeAjBuild distroless containerAmContainer and sandbox supportBaDetected contracts/specificationsCaDOCKER001: Missing USER directive (security risk)ClDOCKER002: Unpinned base image (security/reproducibility \xe2\x80\xa6CbDOCKER003: Missing apt-get cleanup (image size \xe2\x80\xa6CjDOCKER004: Invalid COPY \xe2\x80\x93from reference (multi-stage \xe2\x80\xa6CkDOCKER005: Missing \xe2\x80\x93no-install-recommends (image size \xe2\x80\xa6CbDOCKER006: Use COPY instead of ADD (best practice)BiEvaluate a rash AST node in a given statenLast exit codeiExit codemGet exit codeAmExit code of the last command2AgExit code (0 = success)CkShell script formatting Pre-flight Formatter ImplementationBgGet priority for a diagnostic rule codeBcLoad configuration from a TOML fileCdDetermine file type from path extension and filenameBaDetect config type from file pathBcLoad configuration from TOML stringBiDefined functions (name -&gt; definition)B`List of functions in the programAdFunction definitionsBhFunction names extracted from the scriptAaGet stdin contentCeCheck if variable already has an index (like $var[0])BgApply syntax highlighting to bash inputCeProof inspection and intermediate artifact generationCiCheck if match is inside quotes (odd number of quotes \xe2\x80\xa6BnCheck if this fix should never be auto-appliedBfLint bash input and return diagnosticsBfMaximum recursion depth (default: 100)BgMaximum recursion depth (default: 100).CbMinimum grade required (A+, A, B+, B, C+, C, D, F)BbDon\xe2\x80\x99t create backup (dangerous!)BnDon\xe2\x80\x99t create backup with \xe2\x80\x93fix (dangerous!)CeGet the node type as a string (for tracing/debugging)BeMain normalization with full trackingAlDescription of the operationBfWhether the script parsed successfullyBmPop the most recent frame from the call stackBmPreserved byte ranges (e.g., string literals)AlReasoning for the generationC`Get the current root hash for integrity checkingAeRoot hash of the treeCkNumber of verification runs to perform (default: 3, min: 2)AhNumber of runs performedAnRun all tests in a bash scriptAjEnable sandboxed executionCmCreates a sandboxed configuration with restrictive limits \xe2\x80\xa6BlEnable sandboxed execution (default: false).AhExpression being matchedCbOperational semantics for rash AST and POSIX shellBaSet stdin content (for pipelines)BaShow help for the specified topicBnDon\xe2\x80\x99t add USER directive (for special cases)AhStart column (1-indexed)CfExecute to next line at same call depth (skip over \xe2\x80\xa6AfStreaming I/O for WASMB`Time span of all transformationsBiTimestamp when transformation was appliedAgEnd of containing tokenBcThe transformation that was appliedCaTranspile Rust source code to POSIX shell script.CaTranspile this job using the default output path.BkTranspile the input file to a shell script.AoVariable declarations and usageBmReturns a reference to all session variables.BlSession variables (persist across commands).AaSession variablesBaAdd comment suggesting manual fixCaInternal tokens for arithmetic expression parsingAoArithmetic expansion: $((expr))BlArithmetic expression: remove all whitespaceBdArithmetic operation (for $((expr)))AnVariable assignment: VAR=valueCeLine-based breakpoint with optional condition and \xe2\x80\xa6BjComparison operation (for test conditions)AhConfiguration file typesAaA lint diagnosticBjEnhanced diagnostic information for errorsCdDockerfile purification and linting (NEW in v6.36.0)CaResult of evaluating an AST node or shell commandjFile testsB`Options for auto-fix applicationBfPattern for translating bash for loopsAbJSON output formatAnOutput format for lint resultsAnCollection of lint diagnosticsAeln -s without -f flagAjResult of loading a scriptBbLogical AND (&amp;&amp;) operationAiLogical NOT (!) operationBjMerkle tree for log integrity verificationAgScript has parse errorsnParsing eventsAlQuote state for a bash inputCiConfiguration for the bashrs REPL (Read-Eval-Print Loop).Abrm without -f flagBeSMT proof representation (simplified)AoA stack frame in the call stackCnStatistics for benchmark results (Issue #12: Enhanced with \xe2\x80\xa6AkSuggested fix for an error.BfInformation about a parsed target lineAeTest execution reportAoResult of running a single testAeCore trace event enumBaStatistics about the trace bufferClBuilder for transpiling Rust files to shell scripts with \xe2\x80\xa6AaValidation errorsAiCheck if all tests passedBkGet an ANSI color code for terminal displayoANSI reset codeCbCheck if this rule applies to the given shell typeCcGet the current call depth (number of stack frames)AjGet the current call stackBfCall stack for tracking function callsAmComplexity score (0.0 - 10.0)0CkCreate fix by replacing hardcoded /usr/local with $(PREFIX)CbCreate a fix by suggesting a more specific patternCiCreate fix by suggesting include directive instead of \xe2\x80\xa6CfCreate a fix by replacing inefficient pattern with \xe2\x80\xa6CiCreate fix by adding .DELETE_ON_ERROR: at top of MakefileCjCreate a fix by adding quotes around the unquoted variableBnCreate a fix by removing \xe2\x80\x9cexport \xe2\x80\x9c keywordAfLog creation timestampAhWorking directory changeAoPatterns detected in the scriptAmIssues detected in the scriptAlDiagnostic types for lintingCaDirection indicators (true = right, false = left)BgUse Dockerfile-specific quality scoringBbOptional statements in else branchBkItems in the \xe2\x80\x9celse\xe2\x80\x9d branch (if present)AbEmit a parse eventAgEmit verification proofBjWhether to emit formal verification proofsBkError type (Parse, Lint, Command, Runtime).CfEvaluate a POSIX shell command string in a given stateCoAbstract filesystem representation (path -&gt; content) For \xe2\x80\xa6AkVirtual Filesystem for WASMBfFilter environment variables by prefixAkFixed code (if applicable).BfCheck if a flag was added to a commandAnFormat AST for display in REPLBnCreate a diagnostic from an error with contextAbFilesystem changesB`Code generators for Makefile ASTBcGet captured stderr as UTF-8 stringBcGet captured stdout as UTF-8 stringAoRecursive glob pattern matchingAmCheck if there are any errorsBjCheck if Makefile has any ifndef directiveBbCheck if mkdir already has -p flagAmHash a single transform entryjInner typeAoCheck if a command is a builtinCcCheck if trimmed line starts with the given commandAjCheck if line is a commentAkCheck if tracing is enabledAoCheck if word is a bash keywordAmNumber of measured iterationsB`Index of the leaf being verifiednGet line countAmNumber of lines in the sourceAmNumber of lines in the scriptBoLint a shell script and return all diagnostics.BiMaximum memory usage in MB (default: 100)BoMaximum memory usage in bytes (default: 100MB).ClCreate an UNSAFE fix (provides suggestions, no automatic \xe2\x80\xa6nParameter typeAoParse bash input and return ASTCbParse expression: term ((\xe2\x80\x98+\xe2\x80\x99 | \xe2\x80\x98-\xe2\x80\x99) term)*DaParse term: factor ((\xe2\x80\x98<em>\xe2\x80\x99 | \xe2\x80\x98/\xe2\x80\x99 | \xe2\x80\x98%\xe2\x80\x99) factor)</em>BdPush a new frame onto the call stackBoStep-by-step execution trace for rash semanticsAfRun number (1-indexed)CbSet the original source text for ignore directivesCiCharacter-level bidirectional mapping with interval treesBmSource mapping with character-level precisionAfStart line (1-indexed)AlSuggested fix (if available)mSuggested fixBkSuggested fix with optional corrected code.BeCreate a test state with common setupAiStatements in then branchAnItems in the \xe2\x80\x9cthen\xe2\x80\x9d branchCdAppend-only log for verification context propagationBnTransform algebra and normalization operationsBjBuilder API for programmatic transpilationAdUnit Test GenerationBfShellCheck-compatible validation levelAiAST and output validationCaEnables debug mode for detailed execution traces.BgGenerate test suite for purified scriptBiGenerate test suite for purified MakefileChAdded quotes around variable (e.g., $foo \xe2\x86\x92 \xe2\x80\x9c$foo\xe2\x80\x9d)CaA single alternative approach to a transformationDcAppend error redirection: 2&gt;&gt; file Appends stderr to file \xe2\x80\xa6B`Metadata about the parsed scriptBb~/.bash_profile - Bash login shellAaBuffer statisticsBdCase pattern: preserve for alignmentBgA conditional block (ifeq, ifdef, etc.)CiConditional assignment (?=) - only if not already definedAlA single configuration issueBdA specific issue found in the configCkCore shell dialects for scoring (excludes Inferred variant)CaMakes code produce consistent results across runsAdEnvironment metadataB`Explanation for a bash constructCkPriority for applying fixes when multiple fixes overlap \xe2\x80\xa6AjStored function definitionBnMakes code safe to re-run without side effectsBjInterval set for tracking preserved rangesBfContext for lint suppression decisionsAfLint penalty breakdownBeMetadata about the transformation logBnMerkle proof for verifying log entry integritynA pattern ruleAaProcess executionAcPurification eventsClMatch recipe lines (lines starting with tab after target \xe2\x80\xa6AkRemoved a flag from commandBhSARIF output format (simplified version)o#[should_panic]BcStatistics from streaming operationlString testsCbMatch target declarations (word followed by colon)BcTarget with its shared state writesB`Unique identifier for transformsAjContext for type inferenceAfAdd failure eliminatedAnAdds a command to the history.CfAdd a mapping between original and formatted positionsBkApply fixes from lint result to source codeCkAssumptions required for this fix (for SafeWithAssumptions)BdBackup file path (if backup created)CnBash script parsing and AST generation Bash-to-Rash Parser \xe2\x80\xa6AbBreakpoint managerkClear stdinAkCompare working directoriesAiType constraints to solveBbTest description from TEST commentAnGet human-readable description00BaDescription of the suggested fix.AaBrief descriptionAdGet mode descriptionBnGet a human-readable description of this eventAnDeterminism score (0.0 - 10.0)BeDeterminism checking for bash scriptsAeAll diagnostics foundBhAll diagnostics (for detailed reporting)CeLines that differ between runs (if non-deterministic)CbLines that differ between runs (if non-idempotent)BdTotal execution time in millisecondsBdWhether to enable SIMD optimizationsCgName of the entry point function (typically \xe2\x80\x9cmain\xe2\x80\x9d)AlEnvironment variable changesAnReturns the total error count.BkError count (for debugging and statistics).C`Get the number of events currently in the bufferAjHuman-readable explanation0BnDetailed explanation of why this is a problem.kFinal stateAdFormat an expressionAbFormat a statementAfFormat test expressionBcCreate Merkle tree from leaf hashesBgGets a specific history entry by index.C`Extract the keyword (exit or return) from a lineB`Check if script has shebang lineBbHash command output for comparisonAdRelated help topics.BfReturns the number of history entries.CgPut \xe2\x80\x98then\xe2\x80\x99 on same line as \xe2\x80\x98if\xe2\x80\x99 (default: true)BcCheck if line ends a case statementCjCheck if this value is a constant (doesn\xe2\x80\x99t depend on \xe2\x80\xa6AnCheck if execution is finishedAiCheck if line ends a loopAnGet the number of issues foundAiGet issues as JSON stringBcAll leaf hashes (one per log entry)CeOriginal line breaks in the recipe (indices where \xe2\x80\xa6CbOptional line number where transformation occurredBbLint results for the purified codeAnLoad a bash script from a fileAgMake indentation stringBaMakefile parsing and purificationBhMaximum history entries (default: 1000).B`Maximum number of threads to useBfMerkle tree for integrity verificationBkCreate new I/O streams with capture buffersAeDisable optimizationsCfOptional output path (if None, modifies file in-place)CiSet the file permissions for the output file (Unix only).C`Step-by-step execution trace for POSIX semanticsCePurify bash input and return purified AST with reportAlQuote a value for assignmentAdThe replacement textBcResulting span after transformationkReturn typeA`Rust source fileAfInput Rust source fileBgFlag indicating exit command was calledAmChecks if exit was requested.AoSource file path (if available)BfSource code line containing the error.BkSource span affected by this transformationBjStarting position delta from previous spanAeState after this stepkStep numberBhEnable strict POSIX mode (no extensions)AgImprovement suggestions0AeWelch\xe2\x80\x99s t-statisticAiStart of containing tokenCkTotal lines in the script (excluding comments and empty \xe2\x80\xa6AiGet total number of linesAhTransformed code snippetAkUse existing bashrs_runtimeAoGet buffer utilization (% full)AlWhen to prefer this approachB`Create metadata with line breaksC`Create a new formatter with custom configurationAfSet impact descriptionBeNumber of transformations with proofsAnEnable tracing for this parserAlHuman-readable output formatBgAST annotated with semantic informationBlMinimal diff representation (not full clone)BcComprehensive quality audit resultsAdBash script executorAaBenchmark optionsBbBracket/brace/paren depth trackingC`Command substitution: $(cmd) or <code>cmd</code>AdCommand substitutionChDebug session for step-by-step execution of bash scriptsCkDefault value expansion: ${VAR:-default} If variable is \xe2\x80\xa6AdDetect $RANDOM usageClError if unset expansion: ${VAR:?message} If variable is \xe2\x80\xa6CdStructured error message with source context and \xe2\x80\xa6BgConfiguration for formatting operationsoA function callAeHeredoc state trackerAgFeature is incompatibleBaInformation about a loaded scriptAdLoader configurationBbMetadata about the parsed MakefileAnOutput format for lint resultsBcSimple POSIX command representationAoQuality score for a bash scriptBlString literal: preserve internal whitespaceCkRemove prefix expansion: ${VAR#pattern} Remove shortest \xe2\x80\xa6CkRemove suffix expansion: ${VAR%pattern} Remove shortest \xe2\x80\xa6AmResult of replay verificationBfOutput format for purification reportsBkRule metadata including shell compatibilityBj$SRANDOM (cryptographic random, Bash 5.1+)BiShared writer that wraps Arc&lt;Mutex&gt;BoShell dialect variants with version informationBkTarget shell dialect for generated scripts.CjString length expansion: ${#VAR} Get the length of the \xe2\x80\xa6CiTrace manager coordinates event collection across all \xe2\x80\xa6CkAppend-only log for transformation verification context \xe2\x80\xa6CjA transpilation job representing a single Rust file to \xe2\x80\xa6BhPattern for translating bash while loopsAmWrap pattern with $(sort \xe2\x80\xa6)BcAdd a contract to the current scopeBbAdd a function to loaded functionsBeAlternative approaches (REPL-013-003)CaCreate an annotated AST with semantic informationAhAuto-fix available flag.AgBase timeout in secondsCnBash quality tools (test generation, coverage, formatting, \xe2\x80\xa6BoBuild configuration based on complexity metricsBiCommand name from a restricted allow-listChGet the current line number (1-indexed for user display)AoCurrent line number (0-indexed)BdCONFIG-001: Deduplicate PATH entriesBoDisplay original and purified bash side-by-sideB`Get display name for the dialectAeEmit a simple commandAjGenerated POSIX shell codeBgExecute a command in the abstract stateAnExecute a single test functionAhExplain a bash constructAlFormat arithmetic expressionCeFormats an error message for display in the terminal.CaGet set of built-in/environment variables to skipAhGet mutable node at pathBbGet tee flag for redirect operatorB`Gets a session variable by name.AdGet a variable valueCjCheck if Makefile has .ONESHELL directive (case-sensitive)CdCheck if line contains a pipeline (| outside quotes)AlCheck if line has a redirectCnCheck if line contains a subshell (standalone parentheses, \xe2\x80\xa6CjCheck if Makefile has .SUFFIXES directive (case-sensitive)AoCheck if there are any warningsCbCustom history file path (default: None, uses ~\xe2\x80\xa6ClNumber of spaces per indentation level (default: 2, bash \xe2\x80\xa6CmCheck if input is already in canonical form (23% hit rate \xe2\x80\xa6AlCheck if path is a directoryCbCheck if glob is safe (prefixed with ./ or / or $)CiCheck if position in line is inside quotes (double or \xe2\x80\xa6BoCheck if this effect set is a subset of anotherBcNumber of issues successfully fixedBfGet the highest severity level presentCiParse factor: \xe2\x80\x98(\xe2\x80\x99 expr \xe2\x80\x98)\xe2\x80\x99 | \xe2\x80\x98-\xe2\x80\x99 factor | \xe2\x80\xa6BaType of non-deterministic patternBfPre-condition state (before execution)CnProcess a line and update heredoc state, returning true if \xe2\x80\xa6BhPurification Transforms for Bash ScriptsAlRecords an error occurrence.CeNumber of replay runs to perform (default: 2, min: 2)AjRequests the REPL to exit.CaResolve path (handle . and .., relative/absolute)AhSafety level of this fixAoScore a bash script for qualityBnHelper to get status emoji for dimension scoreAhSets a session variable.AdSet a variable valueCiEscape a string for safe use in shell scripts (public \xe2\x80\xa6AaShell script fileAlGenerated POSIX shell scriptCjEvaluate the condition (if any) against provided variablesBjCalculate significance of this trace eventAfState before this stepBaTarget mutation score (0.0 - 1.0)AjRun tests in a bash scriptAjFormat as Rust test moduleAlConvert to Rust doctest codeAiConvert to Rust test codeAnConvert to Rust assertion codeBmGet total events recorded (including evicted)BiTotal events recorded (including evicted)BcTransform ID that created this spanBmTranspile this job to a specific output path.CnParse all Makefile items (first pass) Try to parse and add \xe2\x80\xa6BnVerify a Merkle proof against the current rootAeVerify a Merkle proofCkWelch\xe2\x80\x99s t-test for comparing two samples with unequal \xe2\x80\xa6BdDetailed description of what changedBaAdd an example to the explanationBhSets the execution timeout for commands.oWrite to stderroWrite to stdoutBkAbstract representation of the system stateCfAssign default value expansion: ${VAR:=default} If \xe2\x80\xa6CiStopped at a breakpoint on the specified line (1-indexed)CbWriter that captures output to an in-memory bufferBfFeature compatibility between dialectsBeTypes of non-deterministic constructsAlWorking directory comparisonBlDetect bashisms (non-POSIX shell constructs)BdDialect scoring system for inferenceAoTracks side effects of commandsB`Environment variables comparisonAeSingle execution stepCaFormally verified emitter for the tiny AST subsetAaGeneration eventsCbVariables that commonly should NOT be exported \xe2\x80\xa6BkIssue severity levels for semantic analysisCgConditional types in Makefiles Makefile conditional \xe2\x80\xa6Aemkdir without -p flagnNetwork accessBmCommon non-file targets that should be .PHONYAfQuality metrics reportCgQuote variables (SC2086) Applied LAST (lowest priority)CcCentral registry of all linter rules with their \xe2\x80\xa6AmMain formatter implementationClRemove useless constructs (SC2116: useless echo) Applied \xe2\x80\xa6BeTab completion helper for bashrs REPLBkRestricted AST for transpilable Rust subsetBnSemantic changes introduced by transformationsB`Semantic issue found in MakefileBgSource code context for error messages.B`Main test generator orchestratorBhTest generator for purified bash scriptsAdIR generation errorsBaRepresents an uncovered code pathBcAll functions defined in the scriptBgAnnotated AST with semantic informationBfCheck if current line has a breakpointAbBackup file suffixBbMain benchmark command entry pointCiCalculate Median Absolute Deviation (MAD) - robust to \xe2\x80\xa6AkClears all command history.CnGet mode name completions (for <code>:mode &lt;tab&gt;</code>)BeLines that were executed during testsBhCreate backup file before applying fixesCnDetect non-deterministic $RANDOM or $(shell echo $$RANDOM) \xe2\x80\xa6B`Documentation score (0.0 - 10.0)AkEmit a sequence of commandsCbGet number of events evicted due to capacity limitBnNumber of events evicted due to capacity limitAgNumber of fixes appliedBmGet scoring weights appropriate for file typeAoFormat scan results for displayB`Format replay result for displayBfFormat verification result for displayBeFormat a bash script from source textAeFilesystem comparisonAcFunction signaturesAfGenerate an expressionBcGenerate text for a single MakeItemAiGet the current hit countBaCheck if variable has a subscriptBcInitial state used for verificationmInitial stateBeCheck if line starts a case statementBmCheck if this type is compatible with anotherBcParse a Makefile string into an ASTBoCheck if two states are semantically equivalentBoCheck if script is idempotent (no issues found)BjWhether all runs produced identical outputChDetects if a bash input line is incomplete and needs \xe2\x80\xa6AkCheck if line starts a loopBeCheck if line is a .PHONY declarationBfCheck if delta is semantics-preservingBmWhether a performance regression was detectedAnCheck if coverage meets targetBeCheck if content is valid bash syntaxCiCheck if read command is part of while read (which is \xe2\x80\xa6CaGet events filtered by minimum significance levelCeLine-by-line coverage map (line number -&gt; covered)BjLint a Makefile and return all diagnosticsAkFresh type variable counterAjParse an include directiveAjParse time in millisecondsBfPost-condition state (after execution)ChList of prerequisites (targets or files this depends on)AfThe purified bash codeCaThe purified code (even though it has violations)BaPurify a shell configuration file0BfCalculate quality score for this errorBdCalculate quality score (0.0 to 1.0)AoScore a bash script for qualityChCheck if a file path should be ignored based on patternsAjCheck if two spans overlapBdStream output to JavaScript callbackBkTokenize a word (command, keyword, or text)AiTruncate path for displayCgCreate a new circular trace buffer with custom capacityCbCreate a trace manager with custom buffer capacitylSet severityBjWrite lint results in the specified formatCkCommand-line argument with default value: ${1:-default} \xe2\x80\xa6BePattern for translating bash commandsAoRuntime options for compilationBhAnalysis result for a configuration fileAlResult of continue executionBlContract-based type system for shell scriptsBaCoverage report for a bash scriptBmExecute a simple command with fixed argumentsAlStep-by-step execution traceAdShell-specific typesChFix safety level (following APR research best practices)CgLine comparison result for purification-aware debuggingBiEnhanced error types for Makefile parsingCgPosition mapping result with token boundary informationC`Special marker for positional arguments from \xe2\x80\xa6ChProof inspector for generating detailed verification \xe2\x80\xa6CkMetadata about recipe formatting (line continuations, etc.)CnVerifies determinism by running scripts multiple times and \xe2\x80\xa6BbSeverity level for safety concernsBhScoring weights for different file typesBoSource location information for error reportingChStatistics about source map memory usage and performanceAhStdlib function metadataBiConfiguration options for test generationBcIndividual transformation log entryAoType of transformation to applyBkType constraint: variable has specific typeCeAbstract state representation for formal verificationBgAdd a span delta for compressed storageBbAnalyze a shell configuration file0CiAnalyze script to find all executable lines and functionsBaWhether the states are equivalentCjAuto-discover and transpile all Rust files in a directory.BfCalculate span for variable assignmentAmCalculate span for diagnosticCmBLAKE3-256 for content addressing (measured 89% cache hit \xe2\x80\xa6CfPerformance change percentage (-20.0 means 20% slower)AiCheck a specific contractAfCompare output streamsAjAny special considerationsAoCreate fix replacement with tabAlWorking directory comparisonAgGet DET violations onlyAgCount of DET violationsBcDiscover all tests in a bash scriptBlDetailed comparison of environment variablesBeExecute a bash script in WASM runtimeBfExecute bash script and capture outputBiExit requested flag (for clean shutdown).BgGet expected shell for this config typeBjExtract bounds from conditional statementsCiExtract subdirectory from make -C or \xe2\x80\x93directory commandAbGet function countBiGenerate a proof for a specific log entryBkGenerate a Merkle proof for a specific leafBiGenerate test suite for a purified scriptBkGenerate test suite for a purified MakefileBlGenerate unit tests for all functions in ASTAhThe generated POSIX codeBeHandle dry-run mode (preview changes)BgApply syntax highlighting to bash inputBjEnable character-by-character highlightingBoInternal node hashes for efficient verificationBhCheck if this breakpoint has a conditionAoCheck if value is a pure numberCcWhether the difference is statistically significantCdCheck if character is a single pipe (not part of ||)AnCheck if line defines a targetCnCheck if line is a target definition (contains \xe2\x80\x98:\xe2\x80\x99 and \xe2\x80\xa6CnCheck if line is a target line (contains \xe2\x80\x98:\xe2\x80\x99 and not a \xe2\x80\xa60AnCheck if line is a target ruleAbList all variablesBhOptional maximum iterations (for safety)0AoMaximum test cases per propertyBmMeasure memory usage (requires /usr/bin/time)CjCONFIG-004: Detect and Remove Non-Deterministic ConstructsB`Type of non-idempotent operationChParse and evaluate arithmetic expression with proper \xe2\x80\xa6AkParse a variable assignmentBjGenerate property-based tests (100+ cases)000BcProperty Test Generation (Sprint 2)CiPurified version of the script lines (if purification \xe2\x80\xa6BeQuote a command argument if necessaryCbOperational semantics for the tiny rash AST subsetBkReport final results and exit appropriatelyBoCalculate retention rate (% of events retained)AgGet SEC violations onlyAgCount of SEC violationsBdSemantic changes introduced (if any)BgCompute semantic delta for verificationBfSet a breakpoint at the specified lineCbSet a breakpoint at the specified line (1-indexed)DdSplit line into separate commands (by &amp;&amp;, ||, ;, |) This \xe2\x80\xa6CkSplit pipeline into individual commands (respecting quotes)B`Target pattern (e.g., \xe2\x80\x9c%.o\xe2\x80\x9d)CkTest case generation from shell scripts Test Generation \xe2\x80\xa6BfTest Generation for Purified MakefilesBiTest Generation for Purified Bash ScriptsB`State transformation descriptionBhReturns the number of session variables.AjGet the count of variablesC`Explanation of why this change improves the codeBcCreate a new conditional breakpointBaCreate a new hit-count breakpointBaSets the maximum recursion depth.CaCreate verifier with custom run count (minimum 2)CbRepresents an alias definition found in the sourceBaAssignment RHS: context-dependentCiComplete benchmark output (with JSON schema support - \xe2\x80\xa6A`Benchmark resultAgSingle benchmark resultAlChange the current directoryBhTracks code coverage for generated testsBfCustom predicate with shell expressionAjDetect process ID $$ usageCbDetect non-deterministic timestamp ($(shell date))AlBash script execution resultA`Execution resultBbResult of executing a bash commandB`Entry in the abstract filesystemChResult of formatting operations with full provenance \xe2\x80\xa6BhConfiguration for bash script formattingBfPattern for translating bash functionsBiHardcoded paths that should use variablesCmQuote command substitutions (SC2046) Applied SECOND after \xe2\x80\xa6AmEmbedded Rash runtime libraryBkRange constraint: numeric variable in rangeBhPatterns that indicate hardcoded secretsBhCommands that should typically be silentBnDetailed safety rationale for a transformationCaPattern for translating bash variable assignmentsBdAnalyze source for alias definitionsBgCommon bash constructs for explain modeCkBash script transpilation and purification Bash-to-Rash \xe2\x80\xa6BdCalculate branch coverage percentageBbCalculate grade from numeric scoreBlCalculate grade based on score and file typeAjClear all loaded functionsAmClears all session variables.AcClear all variablesB`Collect all targets for analysisAcGet coverage reportBlCreate regex patterns for variable detectionBlDetect bashisms (non-POSIX shell constructs)CmDetect outliers using MAD-based method Returns indices of \xe2\x80\xa6CfDetect non-deterministic $(wildcard) patterns in a \xe2\x80\xa6BdDisplay benchmark results to consoleAjEmit a variable assignmentoErrors producedBfExecute a single command (or pipeline)BaExecute a bash command in a shellCkApply fixes with assumptions (requires \xe2\x80\x93fix, includes \xe2\x80\xa6BmCreate comparison from two Statistics objectsBdGenerate mutation test configurationBdWhether to generate transform proofsCbWhether to generate SMT proofs for transformationsB`Generate a human-readable reportCaGenerate human-readable report of transformationsBoGenerate a target with prerequisites and recipeAoGet all breakpoint line numbersAmExtract script name from pathBbCheck if Makefile has .NOTPARALLELBnHighlight a single token with ANSI color codesAhGet IDEM violations onlyAhCount of IDEM violationsCeIgnore files matching these patterns (default: empty)AlCheck if a line is a comment0000000000000AjCheck if line is a comment1110CbCheck if variable is a common environment variableAoCheck if line is a function endAmCheck if line is function endAmCheck if line ends a functionBnCheck if character at position is quoted afterCiCheck if a ShellValue represents a string type (not a \xe2\x80\xa6BlLint a Dockerfile and return all diagnosticsBbMaintainability score (0.0 - 10.0)BnMakefile recipe preprocessing for bash lintingBlMaximum consecutive blank lines (default: 2)BhMaximum line length (default: unlimited)BfMaximum line length (None = unlimited)BeModified source code (if not dry-run)CaMutation Test Configuration Generation (Sprint 3)AlIndices of detected outliersoOutput producedChCheck if a pattern matches a value (glob-style matching)BnOperational semantics for POSIX shell commandsAePrerequisite patternsBnPurify bash input and lint the purified outputCjPurify a Makefile AST by fixing non-deterministic patternsBmQuote all variable expansions (default: true)BfQuote all unquoted variables in sourceCeRecipe formatting metadata (line continuations, etc.)0AkRemoves a session variable.AkReset the hit count to zeroBjReverse mapping from formatted to originalBoCreate self-extracting script instead of binaryAhSet total lines to trackBjCheck if target should be marked as .PHONYBkSuggest similar command using edit distanceBbTarget coverage percentage (0-100)BkTokenize a string (single or double quoted)CiTransform an AST by calling a function on each expressionAjGet uncovered line numbersAhGet uncovered code pathsCaCheck if function body uses arithmetic operationsAoCreate metadata with line countBgSets the maximum memory usage in bytes.CiRestricted list of allowed commands for bootstrap scriptsCnAlternative value expansion: ${VAR:+alt_value} If variable \xe2\x80\xa6CmComparison result between two benchmarks (Issue #12 Phase \xe2\x80\xa6BlA single non-deterministic pattern detectionAaFilesystem changeBkA single non-idempotent operation detectionBdOutput format for inspection reportsBhOutput format for Makefile parse resultsAmMemory measurement statisticsAaOutput comparisonAkDifference between two runsAjPerformance issue detectedBoRegression detection result (Issue #12 Phase 2)AhRemoved $RANDOM variableAmReplaced an argument at indexAdAll stdlib functionsBmSemantic metadata preserved during formattingCbBuilder for constructing source maps incrementallyAnOutput format for test resultsCiUnique identifier for transformations (for dependency \xe2\x80\xa6CcRepresents an unquoted variable found in the sourceBaActive contracts in current scopeAmAdd a character-level mappingBjAnalyze a Makefile AST for semantic issuesBaApply a single fix to source codeCjBuild diagnostic for variable assignment in shebang scriptBfBuild diagnostic for unquoted variableCcBuild diagnostic for invalid break/continue in caseBlBuild diagnostic for recipe line with spacesBlCategorize error and provide helpful contextBdChange the current working directoryCcGet command completions (for lines starting with :)AkGet complexity score (0-10)A`Container formatBcGet count of issues by pattern typeBfCreate a directory (mkdir -p behavior)CeCreate fix by adding include guard around entire fileBoDetect shell from file path (extension or name)BmDiscover Rust source files for transpilation.BeEnable fast path for canonical inputsBoExecute script and measure time in millisecondsCfExecute a for loop Returns (end_line_index, exit_code)BfExecute a pipeline: cmd1 | cmd2 | cmd3CnExecute a subshell (isolated scope) Subshells create a new \xe2\x80\xa6A`Exit code changeCjExpand parameter expressions: arr[0], arr[@], #arr[@], \xe2\x80\xa6BfParse and expand variables in a stringBdExpand variables in a command stringChExtract variable name from export statement e.g., \xe2\x80\x9c\xe2\x80\xa6BaFind differences between two runsBfFormat a list of functions for displayBjFormat a single statement with indentationAbGenerate a commentAmGenerate an include directiveAeGet history file pathBiGrade thresholds for different file typesBkHarmonic mean (better for rates/throughput)ChCheck if line has array syntax (parentheses or brackets)AnCheck if line has curl or wgetAeType inference engineCfCheck if a line is a closing token (}, fi, done, esac)CbCheck if script is deterministic (no issues found)BjWhether all runs produced identical outputBeCheck if quote at position is escapedBbCheck if a line is a function callCkCheck if a word is a function call (exact match or with \xe2\x80\xa6BgCheck if backticks are in an assignmentAoCheck if match is inside quotesBbCheck if position is inside quotesBjCheck if position in line is inside quotesBnCheck if a position in a line is inside quotes0CnCheck if a position in the line is inside single or double \xe2\x80\xa6ClCheck if a position in a line is inside single or double \xe2\x80\xa6CfCheck if a name is a known shell builtin or common \xe2\x80\xa6C`Check if character at position is already quotedCbCheck if a string is safe to use unquoted in shellAdGet loaded functionsBhFunctions extracted from loaded scripts.CfCheck if variable name looks like an array (heuristic)CeNegate a condition for until \xe2\x86\x92 while transformationBfCheck if line is a variable assignmentBgParse a variable assignment from a lineAnParse targets from .PHONY lineBgParse stage name from FROM \xe2\x80\xa6 AS  lineBhDetailed safety rationale (REPL-013-002)AnScore a Dockerfile for qualityC`Select mutation operators based on code patternsBnCheck if group should be added (count &gt;= 2)CbCheck if line should be skipped (empty or comment)CgCheck if line should be skipped (comment or [[ ]] test)CiCheck if line should be skipped (comments or assignments)CfCheck if a line should be skipped (comments, heredocs)CdCheck if line should be skipped (comments or .PHONY)CiCheck if a line should be skipped (comment, empty, or \xe2\x80\xa6CkCheck if a line should be skipped (not a target definition)AmShould skip this line (empty)BcDon\xe2\x80\x99t purify bash in RUN commandsBeStrip ANSI escape codes from a stringBnCheck if this dialect supports a given featureBlToken boundaries for precise error reportingBmTokenize bash input into a sequence of tokensAoTotal number of transformationsBnValidate that a command is in the allowed listAjValidate benchmark optionsAkShellCheck validation levelBmSet line number where transformation occurredAoOutput format for audit resultsCfBreakpoint manager - manages collection of breakpointsBhCommands that should have error handlingBoContract condition expressed as logical formulaAbContract violationBfDetect missing set -e in shell scriptsBkFunction signature with pre/post conditionsBbResult of idempotency verificationClError returned when purified output fails zero-tolerance \xe2\x80\xa6BiRecommend .ONESHELL for multiline recipesCdRecommend adding .SUFFIXES: to disable builtin rulesBcReplaced timestamp with fixed valueAoOutput format for score resultsAoTrace event significance levelsBgGenerates unit tests for bash functionsCcLevel of verification applied during transpilation.AlIn-memory virtual filesystemAlVirtual filesystem interfaceBeContext-dependent whitespace handlingAhAdd attack vector closedAcAdd a range mappingAkAdd vulnerability preventedBiAnalyze a single statement for complexityCkApply fixes with assumptions (SAFE + SAFE-WITH-ASSUMPTIONS)BhInitialize with built-in shell functionsCaCalculate appropriate timeout based on complexityCdCheck a recipe line for echo/printf without @ prefixCeCalculate compression ratio compared to naive mappingAmCount diagnostics by severityBiFunctions that were executed during testsCeCreate diagnostic for unquoted ssh variable expansionBmCreate diagnostic for subshell variable usageAnCreate a diagnostic for SC2096CgDetect performance regression with default 5% thresholdChDetect non-deterministic $(shell date) patterns in a \xe2\x80\xa6ChDetect non-deterministic $(shell find) patterns in a \xe2\x80\xa6BlDetect shell type from file path and contentClExpand arithmetic expressions: $((expr)) -&gt; evaluated \xe2\x80\xa6BjExtract function names from AST statementsCnCreates an error message for lint violations (code quality \xe2\x80\xa6ClGenerate coverage report by analyzing script and running \xe2\x80\xa6AoGenerate doctests from commentsBdGenerate doctests from bash commentsAnGenerate a variable assignmentBkGeometric mean (better for ratios/speedups)AoExtract Makefile name from pathBnGet next position after operator from iteratorBbGet the current type of a variableAoCheck if line has opening braceAoCheck if line has quoted stringCaCheck if a variable at position is already quotedAnCheck if RHS is already quotedBcCheck if variable is already quotedCeCheck if there\xe2\x80\x99s a breakpoint at the specified lineAoCheck if line starts a for loopBjCheck if line starts a function definitionAoCheck if line starts a function0BjCheck if command is a known output commandAlCheck if line pipes to shellBjCheck if line is top-level executable codeAkGet all mappings in a rangeAnMark line as covered in reportBfMaximum nesting depth before giving upAaOutput comparisonB`Parse else branch of conditionalCcParse a target line and extract target name and \xe2\x80\xa6CdParse a target rule starting at the given line indexAlWhether to preserve commentsAmRegister a function signatureBiRemove a breakpoint at the specified lineAoResets the error count to zero.CjRun linter and optionally filter results by specific rulesAkRun quality gates on scriptCjCheck if a rule should be applied for the given shell typeCmCheck if line should be processed (has unsafe command and \xe2\x80\xa6CkCheck if line should be analyzed (has backticks and quotes)BmCheck if line should be checked (has [ and =)CmCheck if line should be checked (has single brackets, not \xe2\x80\xa6CgCheck if Makefile should have an include guard (has \xe2\x80\xa6ChCheck if a match should be skipped (already properly \xe2\x80\xa6BhShow lint results without applying fixesBbLinker flags for size optimizationAjSolve all type constraintsDnTokenize an operator (|, &amp;, ;, &lt;, &gt;, &amp;&amp;, ||, &gt;&gt;, etc.)BlTokenize a variable ($VAR, ${VAR}, $?, etc.)CjTry to enter a heredoc, returning the marker if successfulAiTry to parse comment lineAnTry to parse include directiveAoSet alternatives (REPL-013-003)B`Sets a custom history file path.BbSet number of replay runs (min: 2)AiWrite JSON output to fileBaOutput format for config commandsAhContainer format optionsCfDangerous commands that should never have unquoted \xe2\x80\xa6BcDangerous pattern rules (too broad)CbDetects non-deterministic patterns in bash scriptsAdExit code comparisonAmComplete generated test suiteCaDetects non-idempotent operations in bash scriptsCkCore formatter trait for pre-flight syntactic normalizationBnReport of purification transformations appliedAnResult of purification processBiResult of purifying and linting bash codeAfReplaced an expressionBjShell compatibility level for linter rulesBnSuggest pattern rule instead of explicit rulesAnSystem calls that modify stateAiUnsupported Rust featuresClDetailed verification report containing all intermediate \xe2\x80\xa6BbResult of verifying a Merkle proofAkOverall verification resultAnAdd token boundary informationCbAnalyze code complexity to determine configurationAgApply type substitutionCaGet the string representation for constant valuesCdProcess a single test command for unquoted variablesCkCompare two benchmark samples and return comparison resultsAbCompare exit codesCjGet file path completions (for :load and :source commands)CmContinue execution until a breakpoint is hit or execution \xe2\x80\xa6BeGet count of issues by operation typeAmDetect sed -i (GNU extension)BfDockerfile Quality Scoring (Issue #10)ChEvaluate a condition (handles both [ \xe2\x80\xa6 ] tests and \xe2\x80\xa6ChExecute a while loop Returns (end_line_index, exit_code)BgFind all .PHONY targets in the MakefileChFormat parse error for display in REPL with enhanced \xe2\x80\xa6CjCreates an error message for parse errors (syntax errors).CbFormat replay verification differences for displayCiGenerate a condition expression (for if/while statements)AkGenerate a single statementAhGenerate test expressionBdGet the character before equals signBbHandle in-place fixing with backupCkHandle redirection with file descriptor (2&gt;&amp;1, etc.)BfCheck if line contains double brackets0BkCheck if line contains double bracket [[ ]]B`Check if line has error handlingCaCheck if a recipe line already has error handlingChCheck if this effect set has any system modification \xe2\x80\xa6AeImpact if NOT appliedBdCheck if line uses append (&gt;&gt;)CiCheck if this significance level should be visible in \xe2\x80\xa6DcCheck if two characters form a double operator (&amp;&amp;, ||, \xe2\x80\xa6CdCheck if backticks are in safe context (echo/printf)ChCheck if line is a simple redirect (exactly one &gt; \xe2\x80\xa6CnCheck if variable is in a special context where quoting is \xe2\x80\xa6BmCheck if a function name is a stdlib functionCdCheck if character at position is an unescaped quoteBnCheck if a variable is already properly quoted7AfGet last loaded scriptCkLast loaded script path (for <code>:reload</code> command).BeLayer optimization score (0.0 - 10.0)C`Mark targets as .PHONY if declared (second pass)BgCheck if performance meets requirementsAoGet human-readable memory usageChParse array access syntax: arr[index] -&gt; (arr, index)CeParse command line into words (simple space-based \xe2\x80\xa6CjParse a command line into words (simplified shell parsing)CaParse a comment line and create MakeItem::CommentChParse a define\xe2\x80\xa6endef block for multi-line variable \xe2\x80\xa6BdPerform comparison based on operatorCnProcess a single braced variable capture within arithmetic \xe2\x80\xa6BaQuote variables in a command lineAkSet total branches to trackBfCheck if line should exit recipe stateBlSkip multi-line consolidation transformation0C`Add space before function braces (default: true)CfEnforce strict idempotency (fail on non-idempotent \xe2\x80\xa6CiConvert to a displayable error message with note and helpB`Convert to ShellCheck shell nameAfTrack all side effectsB`Try to parse variable assignmentBcValidate contracts in current scopeBgVerify script produces identical outputCcVerify that the IR represents idempotent operationsBiCircular trace buffer with fixed capacityBeDetect shared directory creation raceBjDetect race condition in shared file writeCfDetect shell-specific features (source, declare, etc.)BdDetect silent failures with @ prefixAmAnalysis of state equivalenceCmVerifies script idempotency by running multiple times and \xe2\x80\xa6BhConfidence scoring for dialect inferenceBlData structure for external log verificationCbMain normalization engine with zero-copy fast pathCdResult of preprocessing with metadata about line \xe2\x80\xa6AnConfiguration for purificationCkRemove longest prefix expansion: ${VAR##pattern} Remove \xe2\x80\xa6CkRemove longest suffix expansion: ${VAR%%pattern} Remove \xe2\x80\xa6CfSAFE-WITH-ASSUMPTIONS: Semantic preservation under \xe2\x80\xa6BjDescription of how a state was transformedBmType inference engine with constraint solvingBhAdd group to list if count threshold metBfAnalyze equivalence between two statesBdAnalyze quote state throughout inputCeApply fixes in-place to the original file with backupAeApply fixes to a fileCkApproximate p-value from t-statistic and degrees of freedomAoBenchmark streaming performanceCnCheck compatibility between source and target dialects for \xe2\x80\xa6CjCollect all stage names defined in FROM \xe2\x80\xa6 AS  directivesAcCompare filesystemsChConsolidate duplicate aliases, keeping only the last \xe2\x80\xa6BbConvert LintFormat to OutputFormatCdCheck if line has unquoted variable and count issuesBbCalculate line coverage percentageBoGet count of critical violations (DET/IDEM/SEC)AnDetect shell from shebang lineBiEscape a command name for shell executionBmEscape a string for safe use in shell scriptsBaEvaluate an arithmetic expressionCmExecute a brace group (shared scope) Brace groups execute \xe2\x80\xa6CkExecute a range of lines with control flow support (for \xe2\x80\xa6AnExplain redirection constructsBnExplain ${parameter:-word} - Use default valueAmExtract target name from lineBdExtract target name from target lineAoOperational failures eliminatedCdCheck if filename appears in command before redirectBaFind matching closing parenthesisCmFind matching closing parenthesis for pattern starting at \xe2\x80\xa6BkFind next non-empty, non-comment line indexCaFind token boundary containing the given positionAoFormat alternatives for displayBgFormat lint results for display in REPLAnGenerate arithmetic expressionCiGenerate diff lines between original and purified contentAoGenerate property tests for ASTBeGenerate unit tests for each functionAcHandle lint commandAcHandle load commandAmHandle mode switching commandAcHandle vars commandBiCheck if variable already uses [@] or [*]CgCheck if a closing keyword appears as a standalone wordCgCheck if Makefile has .DELETE_ON_ERROR (case-sensitive)C`Check if this effect set has any network effectsBbCheck if line has quoted variablesCeIgnore duplicate commands in history (default: true).AiInfer type for a variableBdCheck if line is an array assignmentBeCheck if a line is a comment or emptyBcCheck if line starts a define blockBcCheck if line is empty or a commentChCheck if line is empty or comment (stay in recipe state)BdCheck if line is an export statementClCheck if position in line is inside single quotes (where \xe2\x80\xa6CcCheck if variable name is a common log file patternCfCheck if variable is on the right side of == or != \xe2\x80\xa6CjCheck if assignment is a special operator (:=, !=, +=, ?=)CfCheck if variable should be skipped (special shell \xe2\x80\xa6ChKnown external variables that should suppress SC2154 \xe2\x80\xa6CfLint a shell script with shell-specific rule filteringBnNumber of issues requiring manual interventionCgNormalize function syntax to name() { } (default: true)BiParse all .PHONY declarations from sourceCiParse a POSIX command string (simplified for our tiny \xe2\x80\xa6CgParse a single test function starting at the given lineBjParse threshold argument from command lineDcPreprocess here documents (heredocs) Converts &lt;&lt;DELIMITER \xe2\x80\xa6CiPreserve formatting (keep blank lines, multi-line format)0CkWhether to preserve original whitespace in certain contextsAjPrint HTML coverage outputAjPrint JSON coverage outputAjPrint LCOV coverage outputAmNumber of property test casesBiNumber of property test cases to generate0CiPurify bash input and enforce zero-tolerance quality gateBhRebuild the Merkle tree from all entriesCjMetadata for recipe lines with continuations Maps from \xe2\x80\xa6BmNumber of semantic-preserving transformationsCeCheck if we should exit heredoc (line matches marker)CiSplit function arguments by commas, respecting nested \xe2\x80\xa6AnTokenize arithmetic expressionBeTokenize arithmetic expression stringAcTokenize whitespaceAlGet uncovered function namesCbUse [[ ]] instead of [ ] for tests (default: true)AkOverall verification resultCgCommon non-file targets that should be marked as .PHONYAmConfiguration analysis resultBbOutput format for coverage resultsBhDetect multiple targets with same outputBcJustification for emitter decisionsCfFile system constraint: path exists, is readable, etc.AeFilesystem comparisonBdInefficient shell patterns to detectBgRecommend adding .NOTPARALLEL directiveAgTest generation optionsBkAnalyze PATH entries in shell script sourceBaCalculate complexity score (0-10)CmCalculate end column for variable span, including closing \xe2\x80\xa6CjCheck a single COPY \xe2\x80\x93from line for valid stage referenceCiCheck if line uses a variable as a command and return \xe2\x80\xa6BnCompare current line with its purified versionAmCompare environment variablesAlCount closing braces in lineAlCount leading spaces in lineAlCount opening braces in lineBjCreate regex pattern for alias definitionsAlGet the current line contentAmDetect bash -c without set -eAgFinal states comparisonB`Escape a variable name for shellCkExecute an if statement Returns (end_line_index, exit_code)CnExecute a command for substitution (creates a new executor \xe2\x80\xa6AdExit code comparisonAoExplain control flow constructsCgExplain transformations that will be applied at the \xe2\x80\xa6AoExtract value after equals signCiExtract source files (.c, .cpp, .h, .rs, etc.) from a \xe2\x80\xa6ClExtract a variable reference starting at position (e.g., \xe2\x80\xa6CbFind the position of $ character before a variableCcCreates an error message for unknown REPL commands.AlGenerate a conditional blockBlGenerate loader code for embedding in binaryB`Generate improvement suggestions0AdGenerate test runner0AdHandle clear commandAdHandle parse commandCdIgnore commands starting with space (default: true).BmCheck if a line contains an array declarationBlCheck if line starts a conditional directiveCaCheck if this line is a shell script continuationBjCheck if line contains a dangerous patternBiCheck if line starts an include directiveCgCheck if variable is internal (shouldn\xe2\x80\x99t be exported)BmCheck if line is a local variable declarationBdCheck if line is a quoted assignmentClCheck if line is a Makefile recipe line (starts with tab \xe2\x80\xa6AoCheck if a command name is safeChCheck if line is a simple assignment (var=value with \xe2\x80\xa6CbCalculate Levenshtein distance between two stringsCjLint a shell script with shell-type detection based on \xe2\x80\xa6BbCreate a SAFE-WITH-ASSUMPTIONS fixCaParse array elements from string, handling quotesCgPlan which transformations to apply for detected issuesBmPreserve existing blank lines (default: true)BfCheck if we should exit function scopeBaConvert to proptest strategy codeBaTrace rash execution step by stepBkRecursive helper for tracing rash executionBkCheck if function body uses file operationsClVerify that the IR is deterministic (same inputs produce \xe2\x80\xa6AnDetect non-portable echo usageBeTest generator for purified MakefilesC`Patterns that indicate shared state modificationCkAnalyze bracket/brace/paren depth, respecting quote contextCfApply fixes and write to separate output file (not \xe2\x80\xa6AlApply transformations to ASTAeAttack vectors closedBfCollect all .PHONY target declarationsCaCollect variable assignments and uses from sourceCmDetect non-deterministic constructs and create CONFIG-004 \xe2\x80\xa6AnDetect shell-specific featuresChEvaluate test command: [ condition ] Returns true if \xe2\x80\xa6AgExecute a function callBeExplain ${#parameter} - String lengthC`Explain ${parameter:+word} - Use alternate valueBmExtract doctests from a function\xe2\x80\x99s commentsCbExtract function body (everything between { and })CcExtract function name from function definition lineBjExtract function name from definition lineCdExtract the path being added from a PATH export lineCkExtract prerequisites part from target line (everything \xe2\x80\xa6BcExtract redirect filename from lineChExtract TEST, GIVEN, WHEN, THEN comments before functionCaExtract variable name from semantic issue messageCcExtract variable name from variable part (remove $)BnFind if the recipe contains a critical commandAmFind pattern position in lineBjFormat source context with caret indicatorBmFormat string value with truncation if neededBgGenerate bounds checking property testsCiGenerate tests for branch coverage (if/else, case, loops)AgGenerate a pattern ruleBhHandle output to specific file or stdoutAeHandle purify commandAeHandle reload commandAeHandle source commandBhCheck if line contains break or continueCnCheck if Makefile has any multi-line recipes (targets with \xe2\x80\xa6D`Check if a variable is an automatic variable ($@, $&lt;, $^, \xe2\x80\xa6CoCheck if filename is an automatic Make variable ($&lt;, $@, \xe2\x80\xa6CaCheck if value is a literal assignment (not $VAR)CcCheck if a variable is already quoted at a positionCjCheck if line is a recipe line that starts with spaces \xe2\x80\xa6CkCheck if variable is special or builtin (should be skipped)CkCheck if line is a candidate for ssh variable expansion \xe2\x80\xa6BfCheck if value is a variable expansionBbCalculate line coverage percentageClCheck if bash keywords expect continuation Check if \xe2\x80\x98if\xe2\x80\xa6ChParse arithmetic expression with operator precedence \xe2\x80\xa6B`Parse redirect target (filename)BcQuote the RHS of an assignment lineCdRemove longest prefix matching pattern (simple glob)CdRemove longest suffix matching pattern (simple glob)BoRemove non-deterministic constructs from sourceCmCheck if this breakpoint should trigger, incrementing hit \xe2\x80\xa6CiCheck if text starts with command separator (;, |, &amp;)AmTarget mutation score (0-100)BbTrace POSIX execution step by stepCjTry to extract input filename from cat command: \xe2\x80\x9ccat \xe2\x80\xa6BcSet safety rationale (REPL-013-002)BaDetect non-portable command flagsBaDetect platform-specific commandsAhDockerfile quality scoreBbTypes of non-idempotent operationsAjRecommend .DELETE_ON_ERRORAkSet an environment variableCbSuggest using := instead of = for simple variablesBmSuggest SOURCE_DATE_EPOCH for reproducibilityCfCategory of transformation applied during purificationBoAnalyze source for non-deterministic constructsBcBuild diagnostic for missing .PHONYC`Calculate score based on maximum function lengthChCalculate scoring penalties based on Dockerfile lint \xe2\x80\xa6CiCalculate safety ratio from issues and good practices \xe2\x80\xa6BcCalculate safety score (30% weight)BaCalculate safety score (0.0-10.0)BhCompute state transformation descriptionCdDetect if a string contains a GNU Make function callBdCheck if value contains $(shell \xe2\x80\xa6)BnCount the number of stdout redirects in a lineBjGenerate issues for duplicate PATH entriesBdDetect @ prefix that may hide errorsCgDetect transformation patterns between original and \xe2\x80\xa6AfEmitter justificationsAhExecute a case statementCaExplain ${parameter:=word} - Assign default valueChExplain ${parameter:?word} - Display error if null/unsetBdExtract function calls from a stringCdFind which dangerous command (if any) is in the lineCfFind the first unquoted variable in a line Returns \xe2\x80\xa6BcGenerate purified bash from BashAstBhGet compatibility for a specific rule IDBoHandle command processing based on current modeAfHandle history commandCdCheck if this effect set has any file system effectsBkCheck if line has sudo with output redirectBdCheck if line has variable expansionCkCheck if a target name is a common non-file target that \xe2\x80\xa6BgCheck if a line contains exit or returnBhCheck if a line is a function definitionBfCheck if line indicates function startDfCheck if characters form a multi-character operator (&amp;&amp; or \xe2\x80\xa6CkCheck if the match is already part of a POSIX character \xe2\x80\xa60BmCheck if transformation can be applied safelyBfCheck if transform preserves semanticsBfCheck if line is a variable assignmentBhCheck if a line is a variable assignment0BjCheck if \xe2\x80\x98for\xe2\x80\x99 loop needs continuationC`Parse array element assignment: arr[index]=valueBnParse a single item within a conditional blockCgPin unpinned base images to stable versions (DOCKER002)BfPreprocess Makefile source for lintingAoPreprocess a single recipe lineCeRemove shortest prefix matching pattern (simple glob)CeRemove shortest suffix matching pattern (simple glob)AfSet last loaded scriptCjCheck if a braced variable should be skipped (array or \xe2\x80\xa6ChCheck if a variable name should suppress SC2154 warningsChAlternative suggested fixes (for Unsafe - human must \xe2\x80\xa6BjTry numeric comparison between two stringsCaValidate a variable name according to POSIX rulesCdVerify that the IR doesn\xe2\x80\x99t use excessive resourcesBfWrap specific pattern with $(sort \xe2\x80\xa6)CkDangerous commands that should never be run with sudo + \xe2\x80\xa6AiDetect missing dependencyCiDetect multiple sequential recipe lines that could be \xe2\x80\xa6BcTypes of non-deterministic patternsBePatterns that indicate recursive makeBnConvert $VAR to ${VAR} (add braces if missing)B`Add command to list if non-emptyChAnalyze the effects of a shell command based on its nameBaApply line length limit to outputAiBenchmark a single scriptCnCalculate harmonic mean (better for rates and reciprocals) \xe2\x80\xa6BfCalculate score based on nesting depthBiCalculate optimal number of parallel jobsBbCalculate testing score (0.0-10.0)CaGet bash construct completions (for explain mode)BiCreate diagnostic for array without indexBoCreate diagnostic for bare array in conditionalBjCreate diagnostic for non-idempotent mkdirC`Create diagnostic for recursive shell assignmentCaSimple zstd decompression for no_std environmentsBjDetect multiline recipes without .ONESHELLAnDetect non-portable echo usageBjEstimate size reduction from optimizationsBeExtract examples from inline commentsBeExtract output filename from redirectCaFind targets with overlapping shared state writesChFind all unquoted variables in prerequisites Returns \xe2\x80\xa6BcFormat safety rationale for displayAmGenerate boundary value testsBfGenerate tests for a specific functionBfGenerate property tests using proptestCdGenerate targeted tests for specific uncovered pathsChGenerate the inner part of a test condition (without \xe2\x80\xa6CaGet the shell function name for a stdlib functionCkCheck if line has strict mode settings (set -e, set -u, \xe2\x80\xa6BgCheck if line is a readonly declarationCiCheck if variable usage is on same line as assignment \xe2\x80\xa6CkCheck if line is a single-line for loop (for x in y; do \xe2\x80\xa6CkCheck if input matches parameter expansion pattern with \xe2\x80\xa6AmWrite mutation config to fileC`Check if \xe2\x80\x98case\xe2\x80\x99 statement needs continuationBdParse array declaration: arr=(a b c)CjParse a conditional block starting at the given line indexAgPrint JSON test resultsAnPrint terminal coverage outputBcCheck if output should go to stdoutBdCompiler flags for size optimizationBfSkip blank line removal transformation0BkCheck if target has a specific prerequisiteBaNumber of transformations appliedB`Update function depth for bracesCbWrap pattern in specific variable with $(sort \xe2\x80\xa6)BkOptions for controlling Makefile generationBhRecommend adding order-only prerequisiteCcCalculate geometric mean (better for ratios and \xe2\x80\xa6BeCalculate security score (10% weight)CmConvert a statement in a function context (handles return \xe2\x80\xa6CfCreate diagnostic for unnecessary braces in arithmeticC`Create a SEC002 diagnostic for unquoted variableChDeduplicate PATH entries in source, preserving first \xe2\x80\xa6BbDetect duplicate alias definitionsCbDetect non-portable command flags (GNU extensions)BaDetect platform-specific commandsCfEscape special characters for use within double quotesBdExport log for external verificationBnFormat diff highlighting for a line comparisonCjGenerate edge case tests (empty strings, null, max values)BdGenerate mutation test configurationAhHandle functions commandBfCheck if line has command substitutionBhCheck if line starts a conditional blockCeCheck if line ends a control structure (fi/done/esac)CjCheck if variable is in arithmetic context (inside $(( )))BiCheck if this fix can be applied with \xe2\x80\xa6BoCheck if variable name matches array heuristics0CfCheck if line ends with block keyword that expects \xe2\x80\xa6BlCheck if \xe2\x80\x98until\xe2\x80\x99 loop needs continuationBlCheck if \xe2\x80\x98while\xe2\x80\x99 loop needs continuationCfCheck if line assigns a constant command to a variableCdSimple condition evaluator for breakpoint conditionsCnParse variable reference and return (start, end) positions \xe2\x80\xa6BaPrint human-readable test resultsAhPrint JSON audit resultsAhPrint JSON score resultsAlPrint JUnit XML test resultsBeRemove all non-deterministic elementsCeCalculate degrees of freedom for Welch\xe2\x80\x99s t-test \xe2\x80\xa6ChRepresents a non-deterministic construct found in configBoDetailed explanation of a single transformationChAdd \xe2\x80\x93no-install-recommends flag to apt-get install \xe2\x80\xa6BiCheck if a target is missing dependenciesBfDetect performance issues (CONFIG-005)CaGenerate CONFIG-002 issues for unquoted variablesAoEvaluate a single POSIX commandCdFind dependencies that are missing from declared \xe2\x80\xa6BlFind subshell variable assignments on a lineBkFormat idempotency scan results for displayBfCalculate function coverage percentageCjGenerate a minimal Dockerfile for building static binariesCeGenerate default examples based on function structureAiGenerate determinism test0CkGenerate determinism property test (same input \xe2\x86\x92 same \xe2\x80\xa6AiGenerate error case testsAiGenerate idempotency test0CdGenerate idempotency property test (f(f(x)) == f(x))CdGenerate safety rationale for safety transformationsCkAnalyze Makefile for parallel safety issues (Sprint 83) \xe2\x80\xa6BkCheck if function is potentially idempotentCnCheck if a string is a valid POSIX shell identifier (ASCII \xe2\x80\xa6BmParse stage reference from COPY \xe2\x80\x93from= lineBhParse a function definition and store itBbPrint human-readable audit resultsBbPrint human-readable score resultsCgPrint SARIF audit results (GitHub Code Scanning format)ChVerify that script produces identical output across runsBbSecurity vulnerabilities preventedBhDetect missing error handling in recipesBoAnalyze source for unquoted variable expansionsBjCalculate absolute position of RHS in lineBgCalculate complexity score (25% weight)BjCheck dead code violations and report themBhCreate diagnostic for executed backticksBjCreate diagnostic for redirect to variableCiCreate diagnostic for unquoted word with multiple = signsBoDisplay comparison results for multiple scriptsBjExtract all assigned variables from sourceBfFormat purification report for displayBhGenerate a purified Makefile from an ASTBoCheck if input ends with backslash continuationCnCalculate complexity score (0.0-10.0) Check if line starts \xe2\x80\xa6CcParse conditional branches (then and optional else)BnParse single-variable condition (ifdef/ifndef)CmDetermine if a blank line should be preserved before this \xe2\x80\xa6CeAdd cleanup commands for package managers (DOCKER003)CnAnalyze Makefile for reproducible builds issues (Sprint 83 \xe2\x80\xa6BhCalculate determinism score (15% weight)CkCheck a single arithmetic expression for unnecessary bracesBkCheck complexity violations and report themBfCollect source files from recipe linesBnCreate diagnostic for curl/wget piped to shellBjCreate diagnostic for same file read/writeCjPattern to match unquoted variable expansions Matches: \xe2\x80\xa6AkDetect recursive make callsCkExpand variables in arithmetic context (no $ prefix needed)BfExplain parameter expansion constructsBfFind token boundary in reverse mappingBoFormat purified lint result for display in REPLBkGenerate tests until coverage target is metBdCheck if next line has opening braceCkCheck if read is between do and done in single-line for \xe2\x80\xa6CaMark function calls found on this line as coveredBoCheck if function definition needs continuationBlScore a bash script with file type detectionCmTry to extract output filename from redirect pattern: \xe2\x80\x9c \xe2\x80\xa6CdVerify that the IR contains no command injection \xe2\x80\xa6BmTheorem: Semantic equivalence of emitted codeBeTest generation options for MakefilesCnCollect all targets for analysis (both regular targets and \xe2\x80\xa6CkAnalyze Makefile for portability issues (Sprint 83 - Day 7)BoConvert ADD to COPY for local files (DOCKER006)BhCount duplicate PATH entries in analysisBoCreate diagnostic for unquoted variable in testCmDetect output file conflicts (multiple targets writing to \xe2\x80\xa6CiExecute script and measure both time and memory usage \xe2\x80\xa6CiExpand command substitutions: $(cmd) -&gt; command outputBhExplain what changed during purificationC`Format a detailed transformation report from \xe2\x80\xa6C`Generate alternatives for safety transformationsChCheck if two samples are statistically significantly \xe2\x80\xa6CcWhether the difference is statistically significantBjMark lines in covered functions as coveredAlPrint Markdown score resultsBkCheck if .NOTPARALLEL should be recommendedCcValidate undefined variables and return diagnosticsCbCreate a new hit-count breakpoint with a conditionClDetect non-deterministic command (hostname, git, mktemp, \xe2\x80\xa6BhCalculate documentation score (0.0-10.0)BlCheck if value contains command substitutionAoCreate a misspelling diagnosticBfCreate diagnostic for read in for loopBeCreate a self-extracting shell scriptBhCreate a diagnostic for unreachable codeBiCreate diagnostic for unsafe glob patternBdFormat diff output with explanationsCkAnalyze Makefile for error handling issues (Sprint 83 - \xe2\x80\xa6CcValidate all COPY \xe2\x80\x93from references and return \xe2\x80\xa6BfDetect missing error handling in loopsBgRecommend handling recursive make callsBlSuggest combining multiple shell invocationsBlCreate a diagnostic for missing dependenciesBgCreate diagnostic for unquoted variableCcFormat lint violations with source code context \xe2\x80\xa6CiGenerate safety rationale for determinism transformationsCiGenerate safety rationale for idempotency transformationsAnGenerate POSIX compliance test0CjInfer proptest generators from function signature and bodyCjCheck if redirect is stderr or combined (&amp;&gt;, 2&gt;)CcCalculate cyclomatic complexity for a function bodyBjCalculate maintainability score (0.0-10.0)CbCreate diagnostic for array used as scalar in testBhCreate diagnostic for sudo with redirectBkCreate diagnostic for unquoted glob patternBfDetect shared directory creation racesAoGenerate emitter justificationsBhGenerate type preservation property testCbCheck if function has non-deterministic operationsClMark functions that are called at the top level (outside \xe2\x80\xa6BhUpdate function depth for function startCaAnalyze Makefile for performance optimization \xe2\x80\xa6CmCheck line for dangerous pattern and create diagnostic if \xe2\x80\xa6CbCreate diagnostic for unescaped quote in backticksBdCreate diagnostic for redirect groupBfDetect shell from ShellCheck directiveChDetect missing file dependencies (file usage without \xe2\x80\xa6CgDetect performance regression with custom threshold \xe2\x80\xa6ClCheck if variable usage has array subscript or is length \xe2\x80\xa6BjCollect targets that write to shared stateC`Create diagnostic for array-to-string assignmentC`Create diagnostic for ASCII-only character range0BhCreate diagnostic for glob in assignmentChFind unescaped quote position inside backtick expressionCeGenerate alternatives for determinism transformationsCeGenerate alternatives for idempotency transformationsBnRecursive helper for generating justificationsBoCalculate layer optimization score (20% weight)CeCreate diagnostic for constant command variable usageBfCreate diagnostic for hardcoded secretCbCreate diagnostic for numeric operator with stringBfCreate diagnostic for trailing bracketBgDetect for loops without error handlingBhGenerate property-based determinism testBiGenerate property-based determinism testsBcPrint JSON Dockerfile score resultsCjReconstruct a recipe line with backslash continuations \xe2\x80\xa6BmPrint human-readable Dockerfile score resultsCjExplain what changed during purification with detailed \xe2\x80\xa6CfCreate diagnostic for var=command without substitutionChGenerate a purified Makefile from an AST with custom \xe2\x80\xa6BgPrint Markdown Dockerfile score resultsBlCreate diagnostic for local outside functionChFormat purified lint result with source code context \xe2\x80\xa6BfDetect commands without error handlingBoCheck if .DELETE_ON_ERROR should be recommendedCfPreprocess Makefile input to handle line continuations")