<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Writing Custom Rules - The Rash Book - Shell Safety and Purification</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A comprehensive guide to Rash: shell safety, purification, and linting">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "rust";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rash Book - Shell Safety and Purification</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/paiml/bashrs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/paiml/bashrs/edit/main/book/src/linting/custom-rules.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="writing-custom-lint-rules"><a class="header" href="#writing-custom-lint-rules">Writing Custom Lint Rules</a></h1>
<p>This guide explains how to implement custom lint rules in bashrs using EXTREME TDD methodology. Custom rules extend bashrs's linting capabilities for project-specific requirements.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>bashrs's linting architecture supports:</p>
<ul>
<li><strong>Pattern-based rules</strong>: Regex and string matching (most common)</li>
<li><strong>AST-based rules</strong>: Deep semantic analysis (advanced)</li>
<li><strong>Auto-fix support</strong>: Safe, safe-with-assumptions, or unsafe fixes</li>
<li><strong>Shell compatibility</strong>: Rules can be shell-specific (sh, bash, zsh)</li>
<li><strong>Comprehensive testing</strong>: Unit, property, mutation, and integration tests</li>
</ul>
<h2 id="rule-architecture"><a class="header" href="#rule-architecture">Rule Architecture</a></h2>
<h3 id="rule-structure"><a class="header" href="#rule-structure">Rule Structure</a></h3>
<p>Every lint rule is a Rust module implementing a <code>check()</code> function:</p>
<pre><code class="language-rust ignore">//! RULEID: Short description
//!
//! **Rule**: What pattern this detects
//!
//! **Why this matters**: Impact and reasoning
//!
//! **Auto-fix**: Fix strategy (if applicable)

use crate::linter::{Diagnostic, Fix, LintResult, Severity, Span};

/// Check function - entry point for the rule
pub fn check(source: &amp;str) -&gt; LintResult {
    let mut result = LintResult::new();

    // Rule implementation here

    result
}

#[cfg(test)]
mod tests {
    use super::*;

    // Tests here
}</code></pre>
<h3 id="core-types"><a class="header" href="#core-types">Core Types</a></h3>
<p><strong>Diagnostic</strong>: Represents a lint violation</p>
<pre><code class="language-rust ignore">pub struct Diagnostic {
    pub code: String,        // "DET001", "SEC002", etc.
    pub severity: Severity,  // Error, Warning, Info, etc.
    pub message: String,     // Human-readable message
    pub span: Span,          // Source location
    pub fix: Option&lt;Fix&gt;,    // Suggested fix (optional)
}</code></pre>
<p><strong>Span</strong>: Source code location (1-indexed)</p>
<pre><code class="language-rust ignore">pub struct Span {
    pub start_line: usize,  // 1-indexed line number
    pub start_col: usize,   // 1-indexed column
    pub end_line: usize,
    pub end_col: usize,
}</code></pre>
<p><strong>Fix</strong>: Auto-fix suggestion</p>
<pre><code class="language-rust ignore">pub struct Fix {
    pub replacement: String,             // Replacement text
    pub safety_level: FixSafetyLevel,    // Safe, SafeWithAssumptions, Unsafe
    pub assumptions: Vec&lt;String&gt;,        // For SafeWithAssumptions
    pub suggested_alternatives: Vec&lt;String&gt;,  // For Unsafe
}</code></pre>
<p><strong>Severity Levels</strong>:</p>
<ul>
<li><code>Info</code>: Style suggestions</li>
<li><code>Note</code>: Informational</li>
<li><code>Perf</code>: Performance anti-patterns</li>
<li><code>Risk</code>: Potential runtime failure</li>
<li><code>Warning</code>: Likely bug</li>
<li><code>Error</code>: Definite error (must fix)</li>
</ul>
<h2 id="extreme-tdd-workflow-for-rules"><a class="header" href="#extreme-tdd-workflow-for-rules">EXTREME TDD Workflow for Rules</a></h2>
<h3 id="phase-1-red---write-failing-test"><a class="header" href="#phase-1-red---write-failing-test">Phase 1: RED - Write Failing Test</a></h3>
<p>Start with a test that defines the desired behavior:</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_CUSTOM001_detects_pattern() {
        let script = "#!/bin/bash\ndangerous_pattern";
        let result = check(script);

        // Verify detection
        assert_eq!(result.diagnostics.len(), 1);
        let diag = &amp;result.diagnostics[0];
        assert_eq!(diag.code, "CUSTOM001");
        assert_eq!(diag.severity, Severity::Error);
        assert!(diag.message.contains("dangerous"));
    }
}</code></pre>
<p>Run the test - it should FAIL:</p>
<pre><code class="language-bash">cargo test test_CUSTOM001_detects_pattern
</code></pre>
<h3 id="phase-2-green---implement-rule"><a class="header" href="#phase-2-green---implement-rule">Phase 2: GREEN - Implement Rule</a></h3>
<p>Implement the minimal code to make the test pass:</p>
<pre><code class="language-rust ignore">pub fn check(source: &amp;str) -&gt; LintResult {
    let mut result = LintResult::new();

    for (line_num, line) in source.lines().enumerate() {
        if line.contains("dangerous_pattern") {
            let col = line.find("dangerous_pattern").unwrap();

            let span = Span::new(
                line_num + 1,
                col + 1,
                line_num + 1,
                col + 17,  // "dangerous_pattern" length
            );

            let diag = Diagnostic::new(
                "CUSTOM001",
                Severity::Error,
                "Dangerous pattern detected",
                span,
            );

            result.add(diag);
        }
    }

    result
}</code></pre>
<p>Run test again - should PASS:</p>
<pre><code class="language-bash">cargo test test_CUSTOM001_detects_pattern
</code></pre>
<h3 id="phase-3-refactor---clean-up"><a class="header" href="#phase-3-refactor---clean-up">Phase 3: REFACTOR - Clean Up</a></h3>
<p>Extract helpers, improve readability, ensure complexity &lt;10:</p>
<pre><code class="language-rust ignore">pub fn check(source: &amp;str) -&gt; LintResult {
    let mut result = LintResult::new();

    for (line_num, line) in source.lines().enumerate() {
        if let Some(violation) = detect_pattern(line, line_num) {
            result.add(violation);
        }
    }

    result
}

fn detect_pattern(line: &amp;str, line_num: usize) -&gt; Option&lt;Diagnostic&gt; {
    if !line.contains("dangerous_pattern") {
        return None;
    }

    let col = line.find("dangerous_pattern")?;
    let span = Span::new(line_num + 1, col + 1, line_num + 1, col + 17);

    Some(Diagnostic::new(
        "CUSTOM001",
        Severity::Error,
        "Dangerous pattern detected",
        span,
    ))
}</code></pre>
<h3 id="phase-4-property-testing"><a class="header" href="#phase-4-property-testing">Phase 4: Property Testing</a></h3>
<p>Add generative tests to verify properties:</p>
<pre><code class="language-rust ignore">#[cfg(test)]
mod property_tests {
    use super::*;
    use proptest::prelude::*;

    proptest! {
        #[test]
        fn prop_no_false_positives(
            safe_code in "[a-z]{1,100}"
                .prop_filter("Must not contain pattern", |s| !s.contains("dangerous"))
        ) {
            let result = check(&amp;safe_code);
            // Property: Safe code produces no diagnostics
            prop_assert_eq!(result.diagnostics.len(), 0);
        }

        #[test]
        fn prop_always_detects_pattern(
            prefix in "[a-z]{0,50}",
            suffix in "[a-z]{0,50}"
        ) {
            let code = format!("{}dangerous_pattern{}", prefix, suffix);
            let result = check(&amp;code);
            // Property: Pattern is always detected
            prop_assert!(result.diagnostics.len() &gt;= 1);
        }
    }
}</code></pre>
<h3 id="phase-5-mutation-testing"><a class="header" href="#phase-5-mutation-testing">Phase 5: Mutation Testing</a></h3>
<p>Verify test quality with cargo-mutants:</p>
<pre><code class="language-bash">cargo mutants --file rash/src/linter/rules/custom001.rs --timeout 300
</code></pre>
<p><strong>Target</strong>: ≥90% kill rate</p>
<p>If mutations survive, add tests to kill them:</p>
<pre><code class="language-rust ignore">#[test]
fn test_mutation_exact_column() {
    // Kills mutation: col + 1 → col * 1
    let script = "  dangerous_pattern";  // 2 spaces before
    let result = check(script);
    let span = result.diagnostics[0].span;
    assert_eq!(span.start_col, 3);  // Must be 3, not 0 or 2
}

#[test]
fn test_mutation_line_number() {
    // Kills mutation: line_num + 1 → line_num * 1
    let script = "safe\ndangerous_pattern";
    let result = check(script);
    let span = result.diagnostics[0].span;
    assert_eq!(span.start_line, 2);  // Must be 2, not 1
}</code></pre>
<h3 id="phase-6-integration-testing"><a class="header" href="#phase-6-integration-testing">Phase 6: Integration Testing</a></h3>
<p>Test end-to-end with realistic scripts:</p>
<pre><code class="language-rust ignore">#[test]
fn test_integration_full_script() {
    let script = r#"
#!/bin/bash
set -e

function deploy() {
    dangerous_pattern  # Should detect
    safe_code
}

deploy
"#;

    let result = check(script);
    assert_eq!(result.diagnostics.len(), 1);

    // Verify correct line number
    assert_eq!(result.diagnostics[0].span.start_line, 6);
}</code></pre>
<h3 id="phase-7-pmat-verification"><a class="header" href="#phase-7-pmat-verification">Phase 7: pmat Verification</a></h3>
<p>Verify code quality:</p>
<pre><code class="language-bash"><span class="boring"> Complexity check
</span>pmat analyze complexity --file rash/src/linter/rules/custom001.rs --max 10

<span class="boring"> Quality score
</span>pmat quality-score --min 9.0
</code></pre>
<h3 id="phase-8-example-verification"><a class="header" href="#phase-8-example-verification">Phase 8: Example Verification</a></h3>
<p>Create example that demonstrates the rule:</p>
<pre><code class="language-bash"><span class="boring"> examples/custom_rule_demo.sh
</span><span class="boring">!/bin/bash
</span><span class="boring"> Demonstrates CUSTOM001 rule
</span>
dangerous_pattern  # Will be caught by linter
</code></pre>
<p>Run linter on example:</p>
<pre><code class="language-bash">cargo run -- lint examples/custom_rule_demo.sh
</code></pre>
<h2 id="example-implementing-a-security-rule"><a class="header" href="#example-implementing-a-security-rule">Example: Implementing a Security Rule</a></h2>
<p>Let's implement SEC009: Detect unquoted command substitution in eval.</p>
<h3 id="step-1-red-phase"><a class="header" href="#step-1-red-phase">Step 1: RED Phase</a></h3>
<pre><code class="language-rust ignore">// rash/src/linter/rules/sec009.rs
//! SEC009: Unquoted command substitution in eval
//!
//! **Rule**: Detect eval with unquoted $(...)
//!
//! **Why this matters**: eval "$(cmd)" is vulnerable to injection

use crate::linter::{Diagnostic, LintResult, Severity, Span};

pub fn check(source: &amp;str) -&gt; LintResult {
    LintResult::new()  // Empty - will fail tests
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_SEC009_detects_unquoted_command_sub() {
        let script = r#"eval $(get_command)"#;
        let result = check(script);

        assert_eq!(result.diagnostics.len(), 1);
        let diag = &amp;result.diagnostics[0];
        assert_eq!(diag.code, "SEC009");
        assert_eq!(diag.severity, Severity::Error);
    }

    #[test]
    fn test_SEC009_no_warning_for_quoted() {
        let script = r#"eval "$(get_command)""#;
        let result = check(script);

        assert_eq!(result.diagnostics.len(), 0);
    }
}</code></pre>
<p>Run test:</p>
<pre><code class="language-bash">cargo test test_SEC009_detects_unquoted_command_sub
<span class="boring"> FAILS - as expected (RED)
</span></code></pre>
<h3 id="step-2-green-phase"><a class="header" href="#step-2-green-phase">Step 2: GREEN Phase</a></h3>
<pre><code class="language-rust ignore">pub fn check(source: &amp;str) -&gt; LintResult {
    let mut result = LintResult::new();

    for (line_num, line) in source.lines().enumerate() {
        // Check for eval $(...) pattern
        if line.contains("eval") &amp;&amp; line.contains("$(") {
            // Verify not quoted
            if !is_quoted(line, "eval") {
                if let Some(col) = line.find("eval") {
                    let span = Span::new(
                        line_num + 1,
                        col + 1,
                        line_num + 1,
                        col + 5,
                    );

                    let diag = Diagnostic::new(
                        "SEC009",
                        Severity::Error,
                        "Unquoted command substitution in eval - command injection risk",
                        span,
                    );

                    result.add(diag);
                }
            }
        }
    }

    result
}

fn is_quoted(line: &amp;str, pattern: &amp;str) -&gt; bool {
    if let Some(pos) = line.find(pattern) {
        // Simple heuristic: check if followed by quote
        let after = &amp;line[pos + pattern.len()..];
        after.trim_start().starts_with('"')
    } else {
        false
    }
}</code></pre>
<p>Run tests:</p>
<pre><code class="language-bash">cargo test test_SEC009
<span class="boring"> PASSES - GREEN achieved!
</span></code></pre>
<h3 id="step-3-refactor-phase"><a class="header" href="#step-3-refactor-phase">Step 3: REFACTOR Phase</a></h3>
<pre><code class="language-rust ignore">pub fn check(source: &amp;str) -&gt; LintResult {
    let mut result = LintResult::new();

    for (line_num, line) in source.lines().enumerate() {
        if let Some(violation) = detect_unquoted_eval(line, line_num) {
            result.add(violation);
        }
    }

    result
}

fn detect_unquoted_eval(line: &amp;str, line_num: usize) -&gt; Option&lt;Diagnostic&gt; {
    // Must have both eval and command substitution
    if !line.contains("eval") || !line.contains("$(") {
        return None;
    }

    // Check if quoted
    if is_command_sub_quoted(line) {
        return None;
    }

    // Find eval position
    let col = line.find("eval")?;

    let span = Span::new(line_num + 1, col + 1, line_num + 1, col + 5);

    Some(Diagnostic::new(
        "SEC009",
        Severity::Error,
        "Unquoted command substitution in eval - command injection risk",
        span,
    ))
}

fn is_command_sub_quoted(line: &amp;str) -&gt; bool {
    // Check for eval "$(...)" pattern
    line.contains(r#"eval "$"#) || line.contains(r#"eval '$"#)
}</code></pre>
<h3 id="step-4-property-testing"><a class="header" href="#step-4-property-testing">Step 4: Property Testing</a></h3>
<pre><code class="language-rust ignore">#[cfg(test)]
mod property_tests {
    use super::*;
    use proptest::prelude::*;

    proptest! {
        #[test]
        fn prop_safe_code_no_warnings(
            safe_code in "[a-z ]{1,50}"
                .prop_filter("No eval", |s| !s.contains("eval"))
        ) {
            let result = check(&amp;safe_code);
            prop_assert_eq!(result.diagnostics.len(), 0);
        }

        #[test]
        fn prop_quoted_eval_safe(
            cmd in "[a-z_]{1,20}"
        ) {
            let code = format!(r#"eval "$({})""#, cmd);
            let result = check(&amp;code);
            prop_assert_eq!(result.diagnostics.len(), 0);
        }

        #[test]
        fn prop_unquoted_eval_detected(
            cmd in "[a-z_]{1,20}"
        ) {
            let code = format!("eval $({})", cmd);
            let result = check(&amp;code);
            prop_assert!(result.diagnostics.len() &gt;= 1);
        }
    }
}</code></pre>
<h3 id="step-5-mutation-testing"><a class="header" href="#step-5-mutation-testing">Step 5: Mutation Testing</a></h3>
<pre><code class="language-bash">cargo mutants --file rash/src/linter/rules/sec009.rs --timeout 300
</code></pre>
<p>Add tests to kill survivors:</p>
<pre><code class="language-rust ignore">#[test]
fn test_mutation_column_calculation() {
    let script = "  eval $(cmd)";  // 2-space indent
    let result = check(script);
    assert_eq!(result.diagnostics[0].span.start_col, 3);
}

#[test]
fn test_mutation_line_number() {
    let script = "safe\neval $(cmd)";
    let result = check(script);
    assert_eq!(result.diagnostics[0].span.start_line, 2);
}</code></pre>
<h3 id="step-6-register-rule"><a class="header" href="#step-6-register-rule">Step 6: Register Rule</a></h3>
<p>Add to <code>rash/src/linter/rules/mod.rs</code>:</p>
<pre><code class="language-rust ignore">pub mod sec009;

// In lint_shell() function:
result.merge(sec009::check(source));</code></pre>
<h3 id="step-7-documentation"><a class="header" href="#step-7-documentation">Step 7: Documentation</a></h3>
<p>Add rule to security documentation:</p>
<pre><code class="language-markdown">## SEC009: Unquoted Command Substitution in eval

**Severity**: Error (Critical)

### Examples

❌ **VULNERABILITY**:
```bash
eval $(get_command)
</code></pre>
<p>✅ <strong>SAFE</strong>:</p>
<pre><code class="language-bash">eval "$(get_command)"
</code></pre>
<h2 id="adding-auto-fix-support"><a class="header" href="#adding-auto-fix-support">Adding Auto-fix Support</a></h2>
<h3 id="safe-fix-example"><a class="header" href="#safe-fix-example">Safe Fix Example</a></h3>
<p>For deterministic fixes (quoting variables):</p>
<pre><code class="language-rust ignore">let fix = Fix::new("\"${VAR}\"");  // Safe replacement

let diag = Diagnostic::new(
    "SC2086",
    Severity::Error,
    "Quote variable to prevent word splitting",
    span,
).with_fix(fix);</code></pre>
<h3 id="safe-with-assumptions-fix-example"><a class="header" href="#safe-with-assumptions-fix-example">Safe-with-Assumptions Fix Example</a></h3>
<p>For fixes that work in most cases:</p>
<pre><code class="language-rust ignore">let fix = Fix::new_with_assumptions(
    "mkdir -p",
    vec!["Directory creation failure is not critical".to_string()],
);

let diag = Diagnostic::new(
    "IDEM001",
    Severity::Warning,
    "Non-idempotent mkdir - add -p flag",
    span,
).with_fix(fix);</code></pre>
<h3 id="unsafe-fix-example"><a class="header" href="#unsafe-fix-example">Unsafe Fix Example</a></h3>
<p>For fixes requiring human judgment:</p>
<pre><code class="language-rust ignore">let fix = Fix::new_unsafe(vec![
    "Option 1: Use version: ID=\"${VERSION}\"".to_string(),
    "Option 2: Use git commit: ID=\"$(git rev-parse HEAD)\"".to_string(),
    "Option 3: Pass as argument: ID=\"$1\"".to_string(),
]);

let diag = Diagnostic::new(
    "DET001",
    Severity::Error,
    "Non-deterministic $RANDOM - requires manual fix",
    span,
).with_fix(fix);</code></pre>
<h2 id="shell-compatibility"><a class="header" href="#shell-compatibility">Shell Compatibility</a></h2>
<h3 id="marking-rules-as-shell-specific"><a class="header" href="#marking-rules-as-shell-specific">Marking Rules as Shell-Specific</a></h3>
<p>Register rule compatibility in <code>rule_registry.rs</code>:</p>
<pre><code class="language-rust ignore">pub fn get_rule_compatibility(rule_id: &amp;str) -&gt; ShellCompatibility {
    match rule_id {
        // Bash-only features
        "SC2198" =&gt; ShellCompatibility::NotSh,  // Arrays
        "SC2199" =&gt; ShellCompatibility::NotSh,
        "SC2200" =&gt; ShellCompatibility::NotSh,

        // Universal (all shells)
        "SEC001" =&gt; ShellCompatibility::Universal,
        "DET001" =&gt; ShellCompatibility::Universal,
        "IDEM001" =&gt; ShellCompatibility::Universal,

        // Default: assume universal
        _ =&gt; ShellCompatibility::Universal,
    }
}</code></pre>
<h3 id="shell-types"><a class="header" href="#shell-types">Shell Types</a></h3>
<ul>
<li><code>ShellType::Sh</code>: POSIX sh</li>
<li><code>ShellType::Bash</code>: GNU Bash</li>
<li><code>ShellType::Zsh</code>: Z shell</li>
<li><code>ShellType::Dash</code>: Debian Almquist shell</li>
<li><code>ShellType::Ksh</code>: Korn shell</li>
<li><code>ShellType::Ash</code>: Almquist shell</li>
<li><code>ShellType::BusyBox</code>: BusyBox sh</li>
</ul>
<h2 id="pattern-based-vs-ast-based-rules"><a class="header" href="#pattern-based-vs-ast-based-rules">Pattern-Based vs AST-Based Rules</a></h2>
<h3 id="pattern-based-rules-recommended"><a class="header" href="#pattern-based-rules-recommended">Pattern-Based Rules (Recommended)</a></h3>
<p>Most rules use regex or string matching:</p>
<p><strong>Pros</strong>:</p>
<ul>
<li>Simple to implement</li>
<li>Fast execution</li>
<li>Easy to test</li>
<li>Good for 90% of use cases</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-rust ignore">pub fn check(source: &amp;str) -&gt; LintResult {
    let mut result = LintResult::new();

    for (line_num, line) in source.lines().enumerate() {
        if line.contains("dangerous_pattern") {
            // Create diagnostic
        }
    }

    result
}</code></pre>
<h3 id="ast-based-rules-advanced"><a class="header" href="#ast-based-rules-advanced">AST-Based Rules (Advanced)</a></h3>
<p>For semantic analysis:</p>
<p><strong>Pros</strong>:</p>
<ul>
<li>Semantic understanding</li>
<li>Context-aware</li>
<li>Fewer false positives</li>
</ul>
<p><strong>Cons</strong>:</p>
<ul>
<li>Complex implementation</li>
<li>Slower execution</li>
<li>Requires parser</li>
</ul>
<p><strong>Example</strong>:</p>
<pre><code class="language-rust ignore">use crate::parser::bash_parser;

pub fn check(source: &amp;str) -&gt; LintResult {
    let mut result = LintResult::new();

    // Parse to AST
    let ast = bash_parser::parse(source)?;

    // Traverse AST
    for node in ast.commands() {
        if let Command::Function(func) = node {
            // Analyze function semantics
        }
    }

    result
}</code></pre>
<h2 id="testing-best-practices"><a class="header" href="#testing-best-practices">Testing Best Practices</a></h2>
<h3 id="comprehensive-test-coverage"><a class="header" href="#comprehensive-test-coverage">Comprehensive Test Coverage</a></h3>
<p>Every rule needs:</p>
<ol>
<li>
<p><strong>Basic detection tests</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_detects_violation() { }
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>No false positive tests</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_no_false_positive() { }
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Edge case tests</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_edge_case_empty_line() { }
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><strong>Property tests</strong>:</p>
<pre><code class="language-rust ignore">proptest! { fn prop_no_false_positives() { } }</code></pre>
</li>
<li>
<p><strong>Mutation tests</strong>:</p>
<pre><code class="language-bash">cargo mutants --file rash/src/linter/rules/custom001.rs
</code></pre>
</li>
<li>
<p><strong>Integration tests</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn test_integration_real_script() { }
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h3 id="test-naming-convention"><a class="header" href="#test-naming-convention">Test Naming Convention</a></h3>
<p>Format: <code>test_&lt;RULE_ID&gt;_&lt;feature&gt;_&lt;scenario&gt;</code></p>
<p>Examples:</p>
<pre><code class="language-rust ignore">#[test]
fn test_SEC009_detects_unquoted_eval() { }

#[test]
fn test_SEC009_no_warning_for_quoted() { }

#[test]
fn test_SEC009_handles_multiline() { }</code></pre>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="pattern-1-simple-string-matching"><a class="header" href="#pattern-1-simple-string-matching">Pattern 1: Simple String Matching</a></h3>
<pre><code class="language-rust ignore">pub fn check(source: &amp;str) -&gt; LintResult {
    let mut result = LintResult::new();

    for (line_num, line) in source.lines().enumerate() {
        if let Some(col) = line.find("pattern") {
            let span = Span::new(line_num + 1, col + 1, line_num + 1, col + 8);
            result.add(Diagnostic::new("CODE", Severity::Warning, "Message", span));
        }
    }

    result
}</code></pre>
<h3 id="pattern-2-regex-matching"><a class="header" href="#pattern-2-regex-matching">Pattern 2: Regex Matching</a></h3>
<pre><code class="language-rust ignore">use regex::Regex;

lazy_static::lazy_static! {
    static ref PATTERN: Regex = Regex::new(r"\$RANDOM").unwrap();
}

pub fn check(source: &amp;str) -&gt; LintResult {
    let mut result = LintResult::new();

    for (line_num, line) in source.lines().enumerate() {
        if let Some(m) = PATTERN.find(line) {
            let span = Span::new(
                line_num + 1,
                m.start() + 1,
                line_num + 1,
                m.end() + 1,
            );
            result.add(Diagnostic::new("CODE", Severity::Error, "Message", span));
        }
    }

    result
}</code></pre>
<h3 id="pattern-3-context-aware-detection"><a class="header" href="#pattern-3-context-aware-detection">Pattern 3: Context-Aware Detection</a></h3>
<pre><code class="language-rust ignore">pub fn check(source: &amp;str) -&gt; LintResult {
    let mut result = LintResult::new();

    for (line_num, line) in source.lines().enumerate() {
        // Only check in specific context
        if line.trim_start().starts_with("eval") {
            if line.contains("$(") &amp;&amp; !line.contains(r#""$""#) {
                // Detect violation
            }
        }
    }

    result
}</code></pre>
<h3 id="pattern-4-multi-line-pattern"><a class="header" href="#pattern-4-multi-line-pattern">Pattern 4: Multi-line Pattern</a></h3>
<pre><code class="language-rust ignore">pub fn check(source: &amp;str) -&gt; LintResult {
    let mut result = LintResult::new();
    let lines: Vec&lt;&amp;str&gt; = source.lines().collect();

    for i in 0..lines.len() {
        // Check current + next line
        if i + 1 &lt; lines.len() {
            if lines[i].contains("pattern_part1") &amp;&amp;
               lines[i + 1].contains("pattern_part2") {
                // Detect violation spanning lines
            }
        }
    }

    result
}</code></pre>
<h2 id="cicd-integration"><a class="header" href="#cicd-integration">CI/CD Integration</a></h2>
<h3 id="test-rules-in-ci"><a class="header" href="#test-rules-in-ci">Test Rules in CI</a></h3>
<pre><code class="language-yaml"># .github/workflows/lint-rules.yml
name: Test Lint Rules
on: [push, pull_request]
jobs:
  test-rules:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Run unit tests
        run: cargo test --lib sec009
      - name: Run property tests
        run: cargo test --lib prop_ --release
      - name: Run mutation tests
        run: |
          cargo install cargo-mutants
          cargo mutants --file rash/src/linter/rules/sec009.rs --timeout 300
</code></pre>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="rule-not-triggering"><a class="header" href="#rule-not-triggering">Rule Not Triggering</a></h3>
<ol>
<li>Check pattern matching logic</li>
<li>Verify span calculation (1-indexed!)</li>
<li>Test with minimal example</li>
<li>Add debug prints:
<pre><code class="language-rust ignore">eprintln!("Line {}: {}", line_num, line);
eprintln!("Pattern match: {:?}", line.find("pattern"));</code></pre>
</li>
</ol>
<h3 id="false-positives"><a class="header" href="#false-positives">False Positives</a></h3>
<ol>
<li>Add context checks</li>
<li>Use more specific patterns</li>
<li>Check for quoted strings</li>
<li>Ignore comments</li>
<li>Add exclusion tests</li>
</ol>
<h3 id="mutation-tests-failing"><a class="header" href="#mutation-tests-failing">Mutation Tests Failing</a></h3>
<ol>
<li>Review survived mutants:
<pre><code class="language-bash">cargo mutants --file rash/src/linter/rules/sec009.rs --list
</code></pre>
</li>
<li>Add tests targeting specific mutations</li>
<li>Verify edge cases covered</li>
</ol>
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<ul>
<li><a href="/linting/security.html">bashrs Rule Registry</a></li>
<li><a href="/CLAUDE.html#extreme-tdd-definition">EXTREME TDD Guide</a></li>
<li><a href="https://pitest.org/">Mutation Testing</a></li>
<li><a href="https://proptest-rs.github.io/proptest/">Property Testing with Proptest</a></li>
</ul>
<hr />
<p><strong>Quality Standard</strong>: All custom rules must achieve ≥90% mutation kill rate and pass comprehensive property tests before merging.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../linting/idempotency.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../config/overview.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../linting/idempotency.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../config/overview.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../editor.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
