searchState.loadedDescShard("rash", 0, "Check if the given Rust code is valid for transpilation\nTranspile Rust source code to POSIX shell script\nValidate that an AST conforms to Rash restrictions\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTransform an AST by calling a function on each expression\nWalk an AST and call the visitor for each node\nTranspile Rust source to shell script\nCheck Rust source for Rash compatibility\nInitialize new Rash project\nVerify shell script matches Rust source\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTarget shell dialect\nEnable verbose output\nVerification stringency level\nEmit verification proof\nInput Rust file\nInput Rust file\nProject name\nDisable optimizations\nOutput shell script file\nProject directory\nRust source file\nShell script file\nEmit shell code from IR based on target dialect\nEscape a command name for shell execution\nEscape a string for safe use in shell scripts\nEscape a variable name for shell\nCheck if a command name is safe\nCheck if a string is safe to use unquoted in shell\nCheck if a string is a valid shell identifier\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nConvert AST to Shell IR\nCalls <code>U::from(self)</code>.\nOptimize Shell IR based on configuration\nReading environment variables\nReading from files\nWriting to files\nNetwork access\nProcess execution\nPure computation (no side effects)\nSystem calls that modify state\nAdd an effect to this set\nAnalyze the effects of a shell command based on its name\nCheck if this effect set contains a specific effect\nReturns the argument unchanged.\nReturns the argument unchanged.\nCheck if this effect set has any file system effects\nCheck if this effect set has any network effects\nCheck if this effect set has any system modification …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if this effect set is pure\nCheck if this effect set is a subset of another\nCreate a pure effect set (no side effects)\nCreate an effect set with a single effect\nGet all effects as a vector\nUnion two effect sets\nBoolean value (converted to “true”/“false”)\nCommand substitution\nConcatenated values\nCommand execution\nExit with code\nConditional execution\nVariable assignment: readonly NAME=VALUE\nNo-op\nSequence of operations\nString literal\nVariable reference\nGet the string representation for constant values\nGet all effects from this IR node and its children\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if this value is a constant (doesn’t depend on …\nCheck if this IR node is pure (has no side effects)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nContains the error value\nContains the success value\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nParse Rust source code into a RestrictedAst\nVerify that the given IR satisfies safety properties\nVerify that the IR is deterministic (same inputs produce …\nVerify that the IR represents idempotent operations\nVerify that the IR contains no command injection …\nVerify that the IR doesn’t use excessive resources")