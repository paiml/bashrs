searchState.loadedDescShard("bashrs", 0, "Rash - Rust to Shell Transpiler\nAbstract Syntax Tree (AST) Module\nBash-to-Rash Parser Module\nBash-to-Rash Transpiler\nCheck if the given Rust code is valid for transpilation …\nShell Code Emitter Module\nFormal verification module for the rash emitter\nPre-flight Formatter Implementation\nbashrs Native Linter\nMakefile Parser and Purification\nThis module provides support for stdlib functions that are …\nTest Generation Module\nTranspile Rust source code to POSIX shell script.\nValidate that an AST conforms to Rash restrictions\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTransform an AST by calling a function on each expression\nWalk an AST and call the visitor for each node\nBash Abstract Syntax Tree\nBash Lexer\nBash Parser\nSemantic Analysis for Bash AST\nAlternative value expansion: ${VAR:+alt_value} If variable …\nLogical operations\nArithmetic expression\nArithmetic expansion: $((expr))\nArray/list: (item1 item2 item3)\nAssign default value expansion: ${VAR:=default} If …\nVariable assignment: VAR=value\nMetadata about the parsed script\nRoot AST node representing a complete bash script\nExpression-level AST node\nWrapper type for AST nodes\nStatement-level AST node\nCommand execution: echo “hello”\nCommand substitution: $(cmd) or <code>cmd</code>\nComment (preserved for documentation)\nString concatenation\nDefault value expansion: ${VAR:-default} If variable is …\nError if unset expansion: ${VAR:?message} If variable is …\nFile tests\nFor loop: for VAR in LIST; do BODY; done\nFunction definition\nGlob pattern: *.txt\nIf statement\nInteger comparison\nString literal\nRemove longest prefix expansion: ${VAR##pattern} Remove …\nRemove longest suffix expansion: ${VAR%%pattern} Remove …\nRemove prefix expansion: ${VAR#pattern} Remove shortest …\nRemove suffix expansion: ${VAR%pattern} Remove shortest …\nReturn statement\nSource code span for error reporting\nString tests\nString comparison\nString length expansion: ${#VAR} Get the length of the …\nTest expression: [ expr ]\nTest expression (conditional)\nUntil loop: until CONDITION; do BODY; done Note: Purified …\nVariable reference: $VAR or ${VAR}\nWhile loop\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nContains the error value\nContains the success value\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTracks side effects of commands\nContains the error value\nContains the success value\nTracks variable scopes and their metadata\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nContains the error value\nContains the success value\nCode Generation for Bash-to-Rash Transpiler\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTranslation Patterns for Bash-to-Rash\nPurification Transforms for Bash Scripts\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPattern for translating bash commands\nPattern for translating bash for loops\nPattern for translating bash functions\nPattern for translating bash if statements\nPattern for translating bash variable assignments\nPattern for translating bash while loops\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nContains the error value\nContains the success value\nConfiguration for purification\nReport of purification transformations applied\nPurifies bash AST to ensure idempotency and determinism\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRemove all non-deterministic elements\nEnforce strict idempotency (fail on non-idempotent …\nTrack all side effects\nTranspile Rust source to shell script\nBusybox (900KB)\nCheck Rust source for Rash compatibility\nCompile to standalone binary\nRuntime options for compilation\nContainer format options\nDash shell (180KB)\nDebug format\nDocker format\nHTML report\nHuman-readable format\nHuman-readable report\nInitialize new Rash project\nGenerate formal verification inspection report\nOutput format for inspection reports\nJSON report\nJSON format\nJSON AST\nJSON format\nLint shell scripts or Rust source for safety issues\nOutput format for lint results\nMakefile parsing, purification, and transformation\nOutput format for Makefile parse results\nMarkdown report\nMarkdown format\nMinimal interpreter (50KB)\nOCI format\nParse Makefile to AST\nPurify Makefile (determinism + idempotency)\nOutput format for purification reports\nSARIF format\nHuman-readable text\nVerify shell script matches Rust source\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEnable strict mode (fail on warnings)\nTarget shell dialect\nShellCheck-compatible validation level\nEnable verbose output\nVerification stringency level\nBuild distroless container\nContainer format\nInclude detailed traces\nEmit verification proof\nEnable auto-fix suggestions\nOutput format\nOutput format\nInput Rust file\nInput Rust file\nInput AST file (JSON) or inline AST specification\nInput file (shell script or Rust source)\nProject name\nDisable optimizations\nOutput shell script file\nOutput file (defaults to stdout)\nOutput binary path\nProject directory\nRuntime type\nRust source file\nInput Rust source file\nCreate self-extracting script instead of binary\nShell script file\nApply fixes in-place (creates .bak backup)\nOutput format\nReport format\nInput Makefile\nInput Makefile\nOutput file (defaults to stdout or in-place with –fix)\nShow detailed transformation report\nCreate a self-extracting shell script\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMinimal runtime loader for embedded scripts This module …\nELF structures for parsing\nLoader configuration\nSimple zstd decompression for no_std environments\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate loader code for embedding in binary\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEstimate size reduction from optimizations\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nLinker flags for size optimization\nCompiler flags for size optimization\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate a minimal Dockerfile for building static binaries\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEmit shell code from IR based on target dialect\nEscape a command name for shell execution\nEscape a string for safe use in shell scripts\nEscape a variable name for shell\nCheck if a command name is safe\nCheck if a string is safe to use unquoted in shell\nCheck if a string is a valid POSIX shell identifier (ASCII …\nEscape a string for safe use in shell scripts (public …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAbstract state representation for formal verification\nFormal emitter for the tiny AST subset\nProof inspection and intermediate artifact generation\nOperational semantics for rash AST and POSIX shell\nTiny subset of rash AST for formal verification\nAbstract representation of the system state\nDirectory\nText file with content\nEntry in the abstract filesystem\nChange the current working directory\nCreate a directory (mkdir -p behavior)\nCurrent working directory\nEnvironment variables (name -&gt; value mapping)\nExit code of the last command\nAbstract filesystem representation (path -&gt; content) For …\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet an environment variable\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if two states are semantically equivalent\nCreate a new abstract state with basic initialization\nSet an environment variable\nStandard error buffer\nStandard output buffer\nCreate a test state with common setup\nWrite to stderr\nWrite to stdout\nFormally verified emitter for the tiny AST subset\nEmit POSIX shell code from a tiny AST node\nEmit a variable assignment\nEmit a change directory command\nEmit a simple command\nEmit a sequence of commands\nEscape special characters for use within double quotes\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nQuote a command argument if necessary\nQuote a value for assignment\nTheorem: Semantic equivalence of emitted code\nAST annotated with semantic information\nWorking directory change\nWorking directory comparison\nJustification for emitter decisions\nEnvironment variable change\nEnvironment variables comparison\nAnalysis of state equivalence\nSingle execution step\nStep-by-step execution trace\nExit code comparison\nFilesystem change\nFilesystem comparison\nOutput comparison\nProof inspector for generating detailed verification …\nDescription of how a state was transformed\nDetailed verification report containing all intermediate …\nOverall verification result\nAnalyze equivalence between two states\nCreate an annotated AST with semantic information\nAnnotated AST with semantic information\nWhether the states are equivalent\nThe original AST being verified\nThe AST node being emitted\nChild annotations for composite nodes\nCompare working directories\nCompare environment variables\nCompare exit codes\nCompare filesystems\nCompare output streams\nCompute state transformation description\nAny special considerations\nWorking directory change\nWorking directory comparison\nGenerated POSIX shell code\nEmitter justifications\nEnvironment variable changes\nDetailed comparison of environment variables\nFinal states comparison\nAny errors that occurred\nErrors produced\nExit code change\nExit code comparison\nFinal state\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFilesystem changes\nFilesystem comparison\nGenerate emitter justifications\nRecursive helper for generating justifications\nGenerate a human-readable report\nThe generated POSIX code\nInitial state used for verification\nInitial state\nGenerate a comprehensive verification report\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe AST node\nDescription of the operation\nOutput comparison\nOutput produced\nStep-by-step execution trace for POSIX semantics\nPost-condition state (after execution)\nPre-condition state (before execution)\nStep-by-step execution trace for rash semantics\nReasoning for the generation\nState after this step\nState before this step\nStep number\nExecution steps\nTrace POSIX execution step by step\nTrace rash execution step by step\nRecursive helper for tracing rash execution\nState transformation description\nOverall verification result\nContains the error value\nResult of evaluating an AST node or shell command\nContains the success value\nOperational semantics for POSIX shell commands\nOperational semantics for the tiny rash AST subset\nSimple POSIX command representation\nEvaluate a POSIX shell command string in a given state\nEvaluate a single POSIX command\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nParse a command line into words (simplified shell parsing)\nParse a POSIX command string (simplified for our tiny …\nExecute a command in the abstract state\nEvaluate a rash AST node in a given state\nRestricted list of allowed commands for bootstrap scripts\nChange the current directory\nExecute a simple command with fixed arguments\nSequential execution of commands\nSet an environment variable\nThe tiny subset of rash AST nodes\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCheck if the AST node is valid\nValidate that a command is in the allowed list\nValidate a variable name according to POSIX rules\nList of literal string arguments\nCommand name from a restricted allow-list\nList of commands to execute in order\nVariable name (valid POSIX variable name)\nAbsolute or simple relative path\nLiteral string value\nCore formatter trait for pre-flight syntactic normalization\nMain formatter implementation\nContract system for shell-specific type inference and …\nShell dialect detection and compatibility system\nNormalization engine for syntax transformation\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTransform logging with Merkle tree for integrity …\nSource mapping with character-level precision\nTransform algebra and normalization operations\nCore type definitions for the formatter\nLogical operators\nContract specification\nContract condition expressed as logical formula\nContract-based type system for shell scripts\nContract violation\nCustom predicate with shell expression\nFile system constraint: path exists, is readable, etc.\nFunction signature with pre/post conditions\nNon-null constraint: variable is defined\nRange constraint: numeric variable in range\nType constraint: variable has specific type\nContext for type inference\nType error information\nType inference engine with constraint solving\nActive contracts in current scope\nAdd a contract to the current scope\nApply type substitution\nInitialize with built-in shell functions\nCheck a specific contract\nType constraints to solve\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFunction signatures\nGet the current type of a variable\nInfer type for a variable\nType inference engine\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFresh type variable counter\nRegister a function signature\nSolve all type constraints\nType environment for variables\nUnification algorithm for type inference\nValidate contracts in current scope\nFeature compatibility between dialects\nCore shell dialects for scoring (excludes Inferred variant)\nDialect scoring system for inference\nFeature is directly compatible\nFeature is incompatible\nConfidence scoring for dialect inference\nShell dialect variants with version information\nCheck compatibility between source and target dialects for …\nGet display name for the dialect\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInfer dialect with confidence scoring\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if this dialect supports a given feature\nMain normalization engine with zero-copy fast path\nConfiguration options\nEnable fast path for canonical inputs\nReturns the argument unchanged.\nReturns the argument unchanged.\nWhether to generate transform proofs\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if input is already in canonical form (23% hit rate …\nMaximum nesting depth before giving up\nMain normalization with full tracking\nWhether to preserve comments\nActive whitespace context stack\nMetadata about the transformation log\nStatistics about the transformation log\nData structure for external log verification\nMerkle proof for verifying log entry integrity\nMerkle tree for log integrity verification\nIndividual transformation log entry\nAppend-only log for transformation verification context …\nResult of verifying a Merkle proof\nAdd a new transformation entry\nLog creation timestamp\nDirection indicators (true = right, false = left)\nCreate an empty Merkle tree\nAll transformation entries\nExport log for external verification\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate Merkle tree from leaf hashes\nGenerate a proof for a specific log entry\nGenerate a Merkle proof for a specific leaf\nHash a single transform entry\nTree height (log2 of leaf count, rounded up)\nUnique identifier for this transformation\nInternal node hashes for efficient verification\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAll leaf hashes (one per log entry)\nIndex of the leaf being verified\nMerkle tree for integrity verification\nLog metadata\nCreate a new empty transform log\nHash path from leaf to root\nOptional SMT proof for semantic preservation\nRebuild the Merkle tree from all entries\nResulting span after transformation\nGet the current root hash for integrity checking\nRoot hash of the tree\nSemantic changes introduced (if any)\nNumber of semantic-preserving transformations\nSource span affected by this transformation\nGet statistics about the log\nTime span of all transformations\nTimestamp when transformation was applied\nTotal number of transformations\nThe transformation that was applied\nVerify a Merkle proof against the current root\nVerify a Merkle proof\nNumber of transformations with proofs\nB+ tree for O(log n) point queries, O(k + log n) range …\nCharacter-level bidirectional source mapping\nBuilder for constructing source maps incrementally\nStatistics about source map memory usage and performance\nCompressed span deltas for memory efficiency\nAdd a character-level mapping\nAdd a mapping between original and formatted positions\nAdd a range mapping\nAdd a span delta for compressed storage\nAdd token boundary\nAdd token boundary information\nBuild the final source map\nCalculate compression ratio compared to naive mapping\nCompressed span deltas for memory efficiency\nFind token boundary containing the given position\nFind token boundary in reverse mapping\nB+ tree for forward mapping (original -&gt; formatted)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate identity mapping for unchanged source\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLength of the span\nGet all mappings in a range\nGet human-readable memory usage\nCreate a new source map\nCharacter-level precision with token boundary awareness\nReverse mapping from formatted to original\nB+ tree for reverse mapping (formatted -&gt; original)\nStarting position delta from previous span\nGet statistics about the mapping\nToken boundaries for precise error reporting\nTransform ID that created this span\nArithmetic expression: remove all whitespace\nAssignment RHS: context-dependent\nCase pattern: preserve for alignment\nNormal command context: collapse to single space\nHere-document: preserve exactly\nInterval set for tracking preserved ranges\nString literal: preserve internal whitespace\nSemantic changes introduced by transformations\nSMT proof representation (simplified)\nTransformations form a monoid under composition\nUnique identifier for transforms\nContext-dependent whitespace handling\nMonoid composition with optimization\nCompose semantic deltas (associative operation)\nGet human-readable description\nGet human-readable description\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if delta is semantics-preserving\nCheck if transform preserves semantics\nCompute semantic delta for verification\nPreserved byte ranges (e.g., string literals)\nSMT formula asserting equivalence\nCompound types\nByte position in source text\nCharacter position in source text\nShell-specific types\nConfiguration for formatting operations\nResult of formatting operations with full provenance …\nPosition mapping result with token boundary information\nSemantic metadata preserved during formatting\nShell-specific type system for contracts\nSource span with start and end positions\nPrimitive types\nType variables for inference\nUnion types for shell’s dynamic nature\nBLAKE3-256 for content addressing (measured 89% cache hit …\nComments and their positions\nDetected contracts/specifications\nGet a human-readable representation\nWhether to enable SIMD optimizations\nExact character position\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFunction definitions\nWhether to generate SMT proofs for transformations\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if this type is compatible with another\nMaximum number of threads to use\nSemantic annotations preserved across transforms\nEnable parallel processing for large files\nWhether to preserve original whitespace in certain contexts\nCharacter-level bidirectional mapping with interval trees\nUTF-8 normalized text, zero-copy when possible\nEnd of containing token\nStart of containing token\nAppend-only log for verification context propagation\nVariable declarations and usage\nConvert a statement in a function context (handles return …\nReturns the argument unchanged.\nConvert AST to Shell IR\nCalls <code>U::from(self)</code>.\nCheck if a ShellValue represents a string type (not a …\nOptimize Shell IR based on configuration\nReading environment variables\nReading from files\nWriting to files\nNetwork access\nProcess execution\nPure computation (no side effects)\nSystem calls that modify state\nAdd an effect to this set\nAnalyze the effects of a shell command based on its name\nCheck if this effect set contains a specific effect\nReturns the argument unchanged.\nReturns the argument unchanged.\nCheck if this effect set has any file system effects\nCheck if this effect set has any network effects\nCheck if this effect set has any system modification …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if this effect set is pure\nCheck if this effect set is a subset of another\nCreate a pure effect set (no side effects)\nCreate an effect set with a single effect\nGet all effects as a vector\nUnion two effect sets\n: addition\nCommand-line argument access: $1, $2, $@, etc. Sprint 27b: …\nArgument count: $# Sprint 27b: Command-Line Arguments …\nArithmetic operation (for $((expr)))\nBoolean value (converted to “true”/“false”)\nBreak statement\nCase statement (for match expressions)\nCommand substitution\nComparison operation (for test conditions)\nConcatenated values\nContinue statement\n/ : division\nEcho a value (for function returns)\nEnvironment variable expansion: ${VAR} or ${VAR:-default} …\nCommand execution\nExit with code\nExit code of last command: $? Sprint 27c: Exit Code …\nFor loop with range\nFunction definition\n-ge: numeric greater than or equal\n-gt: numeric greater than\nConditional execution\n-le: numeric less than or equal\nVariable assignment: readonly NAME=VALUE\nLogical AND (&amp;&amp;) operation\nLogical NOT (!) operation\nLogical OR (||) operation\n-lt: numeric less than\n% : modulo\n: multiplication\nNo-op\n-eq: numeric equality\n-ne: numeric inequality\nSequence of operations\n=: string equality\n!=: string inequality\nString literal\n: subtraction\nVariable reference\nWhile loop\nGet the string representation for constant values\nGet all effects from this IR node and its children\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if this value is a constant (doesn’t depend on …\nCheck if this IR node is pure (has no side effects)\nAuto-fix application for linter diagnostics\nDiagnostic types for linting\nOutput formatters for lint results\nLint rules for shell script analysis\nOptions for auto-fix application\nPriority for applying fixes when multiple fixes overlap …\nResult of applying fixes\nQuote command substitutions (SC2046) Applied SECOND after …\nQuote variables (SC2086) Applied LAST (lowest priority)\nRemove useless constructs (SC2116: useless echo) Applied …\nApply fixes from lint result to source code\nApply fixes to a file\nApply a single fix to source code\nBackup file path (if backup created)\nBackup file suffix\nCreate backup file before applying fixes\nDry-run mode (don’t actually modify file)\nNumber of fixes applied\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet priority for a diagnostic rule code\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nModified source code (if not dry-run)\nCheck if two spans overlap\nA lint diagnostic\nError (must fix)\nA suggested fix for a diagnostic\nInformational message\nCollection of lint diagnostics\nSuggestion or note\nSeverity level of a diagnostic\nA source code location span\nWarning (should fix but not critical)\nAdd a diagnostic\nDiagnostic code (e.g., “SC2086”, “BP1001”)\nCount diagnostics by severity\nAll diagnostics found\nEnd column (1-indexed)\nEnd line (1-indexed)\nOptional suggested fix\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCheck if there are any errors\nCheck if there are any warnings\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the highest severity level present\nMerge another result into this one\nHuman-readable message\nCreate a new span\nCreate a new fix\nCreate a new diagnostic\nCreate an empty result\nCreate a span for a single point\nThe replacement text\nSeverity level\nSource location\nStart column (1-indexed)\nStart line (1-indexed)\nAdd a suggested fix\nHuman-readable format (default)\nJSON format\nJSON output format\nOutput format for lint results\nSARIF format (Static Analysis Results Interchange Format)\nSARIF output format (simplified version)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHuman-readable output format\nWrite lint results in the specified format\nLint a shell script and return all diagnostics\nSC2046: Quote command substitutions to prevent word …\nSC2086: Double quote to prevent globbing and word splitting\nSC2116: Useless echo wrapping in command substitution\nCheck for unquoted command substitutions (SC2046)\nCheck for unquoted variable expansions (SC2086)\nCheck for useless echo in command substitutions (SC2116)\nAST (Abstract Syntax Tree) for GNU Makefiles\nCode generators for Makefile AST\nLexer for Makefiles\nMakefile parser\nSemantic analysis for Makefile AST\nAppend (+=) - add to existing value\nA comment line\nA conditional block (ifeq, ifdef, etc.)\nConditional assignment (?=) - only if not already defined\nA function call\nifdef VAR\nifeq ($(VAR),value)\nifndef VAR\nifneq ($(VAR),value)\nAn include directive\nRoot AST node representing a complete Makefile\nConditional types in Makefiles\nMakefile constructs (targets, variables, conditionals, …\nMetadata about the parsed Makefile\nA pattern rule\nRecursive assignment (=) - expanded when used\nShell assignment (!=) - execute shell command\nSimple assignment (:=) - expanded immediately (PREFERRED)\nSource location information\nA target with prerequisites and recipe\nVariable assignment flavors\nA variable assignment\nCreate a dummy span (for testing or when location is …\nEnd byte offset\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAll items in the Makefile (targets, variables, …\nLine number (1-indexed)\nNumber of lines in the source\nMetadata about the Makefile\nCreate default metadata\nCreate a span with specific values\nParse time in milliseconds\nSource file path (if available)\nStart byte offset\nCreate metadata with line count\nFunction arguments\nCondition type\nItems in the “else” branch (if present)\nVariable flavor (=, :=, ?=, +=, !=)\nTarget name (e.g., “build”, “test”, “clean”)\nVariable name\nFunction name (e.g., “wildcard”, “patsubst”)\nWhether this is optional (-include)\nFile path to include\nWhether this target is marked as .PHONY\nPrerequisite patterns\nList of prerequisites (targets or files this depends on)\nRecipe lines (commands to execute, tab-indented)\nRecipe lines\nSource location\nSource location\nSource location\nSource location\nSource location\nSource location\nSource location\nTarget pattern (e.g., “%.o”)\nComment text (without the # prefix)\nItems in the “then” branch\nVariable value\nGenerate a comment\nGenerate a conditional block\nGenerate an include directive\nGenerate text for a single MakeItem\nGenerate a pattern rule\nGenerate a purified Makefile from an AST\nGenerate a target with prerequisites and recipe\nGenerate a variable assignment\nCheck if a line is a variable assignment\nParse a conditional block starting at the given line index\nParse a single item within a conditional block\nParse an include directive\nParse a Makefile string into an AST\nParse a target rule starting at the given line index\nParse a variable assignment\nPreprocess Makefile input to handle line continuations\nAdd comment suggesting manual fix\nResult of purification process\nType of transformation to apply\nWrap pattern with $(sort …)\nApply transformations to AST\nPurified AST\nExtract variable name from semantic issue message\nFind matching closing parenthesis for pattern starting at …\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate human-readable report of transformations\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if transformation can be applied safely\nNumber of issues successfully fixed\nNumber of issues requiring manual intervention\nPlan which transformations to apply for detected issues\nPurify a Makefile AST by fixing non-deterministic patterns\nReport of transformations\nNumber of transformations applied\nWrap specific pattern with $(sort …)\nWrap pattern in specific variable with $(sort …)\nCommon non-file targets that should be marked as .PHONY\nCritical - breaks determinism or idempotency\nHigh - reduces build reproducibility\nIssue severity levels for semantic analysis\nLow - style or best practice\nMedium - potential issue\nSemantic issue found in Makefile\nAnalyze a Makefile AST for semantic issues\nDetect non-deterministic $RANDOM or $(shell echo $$RANDOM) …\nDetect non-deterministic $(shell date) patterns in a …\nDetect non-deterministic $(shell find) patterns in a …\nDetect non-deterministic $(wildcard) patterns in a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if a target name is a common non-file target that …\nIssue description\nPurification rule that detected this\nSeverity level\nLocation in source\nSuggested fix (if available)\nAlmquist Shell (BusyBox)\nBash (version 3.2+)\nBasic safety checks only\nConfiguration options for transpilation.\nDebian Almquist Shell\nNo verification (not recommended)\nMaximum verification (slowest)\nPOSIX sh - maximum compatibility\nTarget shell dialect for generated scripts.\nStrict verification (recommended)\nLevel of verification applied during transpilation.\nWhether to emit formal verification proofs\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEnable IR optimization passes\nEnable strict POSIX mode (no extensions)\nTarget shell dialect for generated scripts\nShellCheck validation level\nLevel of verification to apply during transpilation\nEnhanced diagnostic information for errors\nInternal compiler errors\nI/O errors\nSyntax/parse errors\nIR generation errors\nUnsupported Rust features\nValidation errors\nCategorize error and provide helpful context\nError category (for grouping similar errors)\nColumn number (if available)\nThe underlying error\nSource file path (if available)\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a diagnostic from an error with context\nSuggested fix or workaround\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLine number (if available)\nAdditional context/explanation\nCalculate quality score (0.0 to 1.0)\nCode snippet (if available)\nContains the error value\nContains the error value\nContains the success value\nContains the success value\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nParse Rust source code into a RestrictedAst\nAll stdlib functions\nStdlib function metadata\nReturns the argument unchanged.\nGet the shell function name for a stdlib function\nCalls <code>U::from(self)</code>.\nCheck if a function name is a stdlib function\nCore Test Generator Infrastructure\nCoverage Tracking and Analysis\nDoctest Generation (Sprint 3)\nMutation Test Configuration Generation (Sprint 3)\nProperty Test Generation (Sprint 2)\nUnit Test Generation\nContains the error value\nComplete generated test suite\nContains the success value\nConfiguration options for test generation\nMain test generator orchestrator\nGet coverage report\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate complete test suite from bash AST\nGenerate doctests from comments\nGenerate mutation test configuration\nGenerate property tests using proptest\nGenerate unit tests for each function\nGenerate tests until coverage target is met\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWrite mutation config to file\nNumber of property test cases\nTarget coverage percentage (0-100)\nTarget mutation score (0-100)\nFormat as Rust test module\nUse existing bashrs_runtime\nUnique identifier for a code branch\nTracks code coverage for generated tests\nQuality metrics report\nRepresents an uncovered code path\nAnalyze test suite and calculate coverage\nCalculate branch coverage percentage\nCalculate line coverage percentage\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if coverage meets target\nSet total branches to track\nSet total lines to track\nGet uncovered code paths\nExtract doctests from a function’s comments\nExtract examples from inline comments\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate default examples based on function structure\nGenerate doctests from bash comments\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert to Rust doctest code\nAnalyze code complexity to determine configuration\nAnalyze a single statement for complexity\nBase timeout in seconds\nBuild configuration based on complexity metrics\nCalculate cyclomatic complexity for a function body\nCalculate optimal number of parallel jobs\nCalculate appropriate timeout based on complexity\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate mutation test configuration\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSelect mutation operators based on code patterns\nTarget mutation score (0.0 - 1.0)\nConvert to TOML configuration format\nExtract bounds from conditional statements\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate bounds checking property tests\nGenerate determinism property test (same input → same …\nGenerate idempotency property test (f(f(x)) == f(x))\nGenerate property tests for AST\nGenerate type preservation property test\nCheck if function has non-deterministic operations\nInfer proptest generators from function signature and body\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if function is potentially idempotent\nMaximum test cases per property\nConvert to proptest strategy code\nGenerate Rust code for this property test\nTest assertion types\nComment for documentation\nassert_eq!(actual, expected)\nassert!(!condition)\nassert_ne!(actual, expected)\n#[should_panic]\nassert!(condition)\nA single unit test\nGenerates unit tests for bash functions\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate boundary value tests\nGenerate tests for branch coverage (if/else, case, loops)\nGenerate edge case tests (empty strings, null, max values)\nGenerate error case tests\nGenerate tests for a specific function\nGenerate targeted tests for specific uncovered paths\nGenerate unit tests for all functions in AST\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert to Rust test code\nConvert to Rust assertion code\nCheck if function body uses arithmetic operations\nCheck if function body uses file operations\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nVerify that the given IR satisfies safety properties\nVerify that the IR is deterministic (same inputs produce …\nVerify that the IR represents idempotent operations\nVerify that the IR contains no command injection …\nVerify that the IR doesn’t use excessive resources")