searchState.loadedDescShard("bashrs", 0, "Rash - Rust to Shell Transpiler\nAbstract Syntax Tree (AST) Module\nBash-to-Rash Parser Module\nBash-to-Rash Transpiler\nCheck if the given Rust code is valid for transpilation …\nCompiler module for bashrs\nShell configuration file management\nShell Code Emitter Module\nFormal verification module for the rash emitter\nPre-flight Formatter Implementation\nIntermediate Representation (IR) module\nbashrs Native Linter\nMakefile Parser and Purification\nThis module provides support for stdlib functions that are …\nTest Generation Module\nTranspile Rust source code to POSIX shell script.\nWebAssembly Support for bashrs\nValidate that an AST conforms to Rash restrictions\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTransform an AST by calling a function on each expression\nWalk an AST and call the visitor for each node\nBash Abstract Syntax Tree\nBash Lexer\nBash Parser\nSemantic Analysis for Bash AST\nAlternative value expansion: ${VAR:+alt_value} If variable …\nLogical operations\nArithmetic expression\nArithmetic expansion: $((expr))\nArray/list: (item1 item2 item3)\nAssign default value expansion: ${VAR:=default} If …\nVariable assignment: VAR=value\nMetadata about the parsed script\nRoot AST node representing a complete bash script\nExpression-level AST node\nWrapper type for AST nodes\nStatement-level AST node\nCommand execution: echo “hello”\nCommand substitution: $(cmd) or <code>cmd</code>\nComment (preserved for documentation)\nString concatenation\nDefault value expansion: ${VAR:-default} If variable is …\nError if unset expansion: ${VAR:?message} If variable is …\nFile tests\nFor loop: for VAR in LIST; do BODY; done\nFunction definition\nGlob pattern: *.txt\nIf statement\nInteger comparison\nString literal\nRemove longest prefix expansion: ${VAR##pattern} Remove …\nRemove longest suffix expansion: ${VAR%%pattern} Remove …\nRemove prefix expansion: ${VAR#pattern} Remove shortest …\nRemove suffix expansion: ${VAR%pattern} Remove shortest …\nReturn statement\nSource code span for error reporting\nString tests\nString comparison\nString length expansion: ${#VAR} Get the length of the …\nTest expression: [ expr ]\nTest expression (conditional)\nUntil loop: until CONDITION; do BODY; done Note: Purified …\nVariable reference: $VAR or ${VAR}\nWhile loop\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nContains the error value\nContains the success value\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTracks side effects of commands\nContains the error value\nContains the success value\nTracks variable scopes and their metadata\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nContains the error value\nContains the success value\nCode Generation for Bash-to-Rash Transpiler\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTranslation Patterns for Bash-to-Rash\nPurification Transforms for Bash Scripts\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPattern for translating bash commands\nPattern for translating bash for loops\nPattern for translating bash functions\nPattern for translating bash if statements\nPattern for translating bash variable assignments\nPattern for translating bash while loops\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nContains the error value\nContains the success value\nConfiguration for purification\nReport of purification transformations applied\nPurifies bash AST to ensure idempotency and determinism\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRemove all non-deterministic elements\nEnforce strict idempotency (fail on non-idempotent …\nTrack all side effects\nAnalyze shell configuration file for issues\nTranspile Rust source to shell script\nBusybox (900KB)\nCheck Rust source for Rash compatibility\nCompile to standalone binary\nRuntime options for compilation\nShell configuration file management (NEW in v7.0)\nOutput format for config commands\nContainer format options\nDash shell (180KB)\nDebug format\nDocker format\nHTML report\nHuman-readable format\nHuman-readable format\nHuman-readable report\nInitialize new Rash project\nGenerate formal verification inspection report\nOutput format for inspection reports\nJSON format\nJSON report\nJSON format\nJSON AST\nJSON format\nLint shell scripts or Rust source for safety issues\nLint Makefile for quality issues\nLint shell configuration file\nOutput format for lint results\nMakefile parsing, purification, and transformation\nOutput format for Makefile parse results\nMarkdown report\nMarkdown format\nMinimal interpreter (50KB)\nOCI format\nParse Makefile to AST\nPurify Makefile (determinism + idempotency)\nPurify shell configuration file (fix issues automatically)\nInteractive REPL with integrated debugger (NEW in v7.0)\nOutput format for purification reports\nSARIF format\nHuman-readable text\nVerify shell script matches Rust source\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEnable strict mode (fail on warnings)\nTarget shell dialect\nShellCheck-compatible validation level\nEnable verbose output\nVerification stringency level\nBuild distroless container\nContainer format\nEnable debug mode\nInclude detailed traces\nEmit verification proof\nEnable auto-fix suggestions (SAFE fixes only)\nApply fixes with assumptions (requires –fix, includes …\nOutput format\nOutput format\nInput Rust file\nInput Rust file\nInput AST file (JSON) or inline AST specification\nInput file (shell script or Rust source)\nMaximum recursion depth (default: 100)\nMaximum memory usage in MB (default: 100)\nProject name\nDisable optimizations\nOutput shell script file\nOutput file (defaults to stdout)\nOutput binary path\nOutput file for fixed content\nProject directory\nRuntime type\nRust source file\nInput Rust source file\nEnable sandboxed execution\nCreate self-extracting script instead of binary\nShell script file\nTimeout in seconds (default: 30)\nDry run (show what would be changed)\nApply fixes in-place (creates timestamped backup)\nOutput format\nOutput format\nInput config file (.bashrc, .zshrc, .profile, etc.)\nInput config file\nInput config file\nDon’t create backup (dangerous!)\nOutput file (defaults to stdout, or in-place with –fix)\nApply fixes in-place (creates .bak backup)\nApply automatic fixes\nOutput format\nReport format\nOutput format\nInput Makefile\nInput Makefile\nInput Makefile\nOutput file (defaults to stdout or in-place with –fix)\nOutput file (defaults to in-place with –fix)\nShow detailed transformation report\nFilter by specific rules (comma-separated: MAKE001,MAKE003)\nCreate a self-extracting shell script\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMinimal runtime loader for embedded scripts This module …\nELF structures for parsing\nLoader configuration\nSimple zstd decompression for no_std environments\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate loader code for embedding in binary\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEstimate size reduction from optimizations\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nLinker flags for size optimization\nCompiler flags for size optimization\n~/.bash_profile - Bash login shell\n~/.bashrc - Bash interactive shell\nAnalysis result for a configuration file\nA specific issue found in the config\nConfiguration file types\nGeneric shell script\nA PATH entry found in the config\nPerformance issue detected\n~/.profile - POSIX login shell\n~/.zprofile - Zsh login shell\n~/.zshrc - Zsh interactive shell\nCONFIG-003: Consolidate Duplicate Aliases\nShell configuration file analyzer\nCONFIG-001: Deduplicate PATH entries\nGet expected shell for this config type\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDetect config type from file path\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCONFIG-004: Detect and Remove Non-Deterministic Constructs\nShell configuration file purifier\nCONFIG-002: Quote Variable Expansions\nRepresents an alias definition found in the source\nAnalyze source for alias definitions\nConsolidate duplicate aliases, keeping only the last …\nCreate regex pattern for alias definitions\nDetect duplicate alias definitions\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAnalyze a shell configuration file\nCalculate complexity score (0-10)\nDetect performance issues (CONFIG-005)\nAnalyze PATH entries in shell script source\nDeduplicate PATH entries in source, preserving first …\nGenerate issues for duplicate PATH entries\nExtract the path being added from a PATH export line\nTypes of non-deterministic constructs\nRepresents a non-deterministic construct found in config\nAnalyze source for non-deterministic constructs\nDetect non-deterministic constructs and create CONFIG-004 …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRemove non-deterministic constructs from source\nPurify a shell configuration file\nRepresents an unquoted variable found in the source\nConvert $VAR to ${VAR} (add braces if missing)\nAnalyze source for unquoted variable expansions\nPattern to match unquoted variable expansions Matches: …\nGenerate CONFIG-002 issues for unquoted variables\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCheck if a variable at position is already quoted\nCheck if variable is in a special context where quoting is …\nQuote the RHS of an assignment line\nQuote variables in a command line\nQuote all unquoted variables in source\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate a minimal Dockerfile for building static binaries\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEmit shell code from IR based on target dialect\nEscape a command name for shell execution\nEscape a string for safe use in shell scripts\nEscape a variable name for shell\nCheck if a command name is safe\nCheck if a string is safe to use unquoted in shell\nCheck if a string is a valid POSIX shell identifier (ASCII …\nEscape a string for safe use in shell scripts (public …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAbstract state representation for formal verification\nFormal emitter for the tiny AST subset\nProof inspection and intermediate artifact generation\nOperational semantics for rash AST and POSIX shell\nTiny subset of rash AST for formal verification\nAbstract representation of the system state\nDirectory\nText file with content\nEntry in the abstract filesystem\nChange the current working directory\nCreate a directory (mkdir -p behavior)\nCurrent working directory\nEnvironment variables (name -&gt; value mapping)\nExit code of the last command\nAbstract filesystem representation (path -&gt; content) For …\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet an environment variable\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if two states are semantically equivalent\nCreate a new abstract state with basic initialization\nSet an environment variable\nStandard error buffer\nStandard output buffer\nCreate a test state with common setup\nWrite to stderr\nWrite to stdout\nFormally verified emitter for the tiny AST subset\nEmit POSIX shell code from a tiny AST node\nEmit a variable assignment\nEmit a change directory command\nEmit a simple command\nEmit a sequence of commands\nEscape special characters for use within double quotes\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nQuote a command argument if necessary\nQuote a value for assignment\nTheorem: Semantic equivalence of emitted code\nAST annotated with semantic information\nWorking directory change\nWorking directory comparison\nJustification for emitter decisions\nEnvironment variable change\nEnvironment variables comparison\nAnalysis of state equivalence\nSingle execution step\nStep-by-step execution trace\nExit code comparison\nFilesystem change\nFilesystem comparison\nOutput comparison\nProof inspector for generating detailed verification …\nDescription of how a state was transformed\nDetailed verification report containing all intermediate …\nOverall verification result\nAnalyze equivalence between two states\nCreate an annotated AST with semantic information\nAnnotated AST with semantic information\nWhether the states are equivalent\nThe original AST being verified\nThe AST node being emitted\nChild annotations for composite nodes\nCompare working directories\nCompare environment variables\nCompare exit codes\nCompare filesystems\nCompare output streams\nCompute state transformation description\nAny special considerations\nWorking directory change\nWorking directory comparison\nGenerated POSIX shell code\nEmitter justifications\nEnvironment variable changes\nDetailed comparison of environment variables\nFinal states comparison\nAny errors that occurred\nErrors produced\nExit code change\nExit code comparison\nFinal state\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFilesystem changes\nFilesystem comparison\nGenerate emitter justifications\nRecursive helper for generating justifications\nGenerate a human-readable report\nThe generated POSIX code\nInitial state used for verification\nInitial state\nGenerate a comprehensive verification report\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe AST node\nDescription of the operation\nOutput comparison\nOutput produced\nStep-by-step execution trace for POSIX semantics\nPost-condition state (after execution)\nPre-condition state (before execution)\nStep-by-step execution trace for rash semantics\nReasoning for the generation\nState after this step\nState before this step\nStep number\nExecution steps\nTrace POSIX execution step by step\nTrace rash execution step by step\nRecursive helper for tracing rash execution\nState transformation description\nOverall verification result\nContains the error value\nResult of evaluating an AST node or shell command\nContains the success value\nOperational semantics for POSIX shell commands\nOperational semantics for the tiny rash AST subset\nSimple POSIX command representation\nEvaluate a POSIX shell command string in a given state\nEvaluate a single POSIX command\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nParse a command line into words (simplified shell parsing)\nParse a POSIX command string (simplified for our tiny …\nExecute a command in the abstract state\nEvaluate a rash AST node in a given state\nRestricted list of allowed commands for bootstrap scripts\nChange the current directory\nExecute a simple command with fixed arguments\nSequential execution of commands\nSet an environment variable\nThe tiny subset of rash AST nodes\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCheck if the AST node is valid\nValidate that a command is in the allowed list\nValidate a variable name according to POSIX rules\nList of literal string arguments\nCommand name from a restricted allow-list\nList of commands to execute in order\nVariable name (valid POSIX variable name)\nAbsolute or simple relative path\nLiteral string value\nCore formatter trait for pre-flight syntactic normalization\nMain formatter implementation\nContract system for shell-specific type inference and …\nShell dialect detection and compatibility system\nNormalization engine for syntax transformation\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTransform logging with Merkle tree for integrity …\nSource mapping with character-level precision\nTransform algebra and normalization operations\nCore type definitions for the formatter\nLogical operators\nContract specification\nContract condition expressed as logical formula\nContract-based type system for shell scripts\nContract violation\nCustom predicate with shell expression\nFile system constraint: path exists, is readable, etc.\nFunction signature with pre/post conditions\nNon-null constraint: variable is defined\nRange constraint: numeric variable in range\nType constraint: variable has specific type\nContext for type inference\nType error information\nType inference engine with constraint solving\nActive contracts in current scope\nAdd a contract to the current scope\nApply type substitution\nInitialize with built-in shell functions\nCheck a specific contract\nType constraints to solve\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFunction signatures\nGet the current type of a variable\nInfer type for a variable\nType inference engine\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nFresh type variable counter\nRegister a function signature\nSolve all type constraints\nType environment for variables\nUnification algorithm for type inference\nValidate contracts in current scope\nFeature compatibility between dialects\nCore shell dialects for scoring (excludes Inferred variant)\nDialect scoring system for inference\nFeature is directly compatible\nFeature is incompatible\nConfidence scoring for dialect inference\nShell dialect variants with version information\nCheck compatibility between source and target dialects for …\nGet display name for the dialect\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInfer dialect with confidence scoring\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if this dialect supports a given feature\nMain normalization engine with zero-copy fast path\nConfiguration options\nEnable fast path for canonical inputs\nReturns the argument unchanged.\nReturns the argument unchanged.\nWhether to generate transform proofs\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if input is already in canonical form (23% hit rate …\nMaximum nesting depth before giving up\nMain normalization with full tracking\nWhether to preserve comments\nActive whitespace context stack\nMetadata about the transformation log\nStatistics about the transformation log\nData structure for external log verification\nMerkle proof for verifying log entry integrity\nMerkle tree for log integrity verification\nIndividual transformation log entry\nAppend-only log for transformation verification context …\nResult of verifying a Merkle proof\nAdd a new transformation entry\nLog creation timestamp\nDirection indicators (true = right, false = left)\nCreate an empty Merkle tree\nAll transformation entries\nExport log for external verification\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate Merkle tree from leaf hashes\nGenerate a proof for a specific log entry\nGenerate a Merkle proof for a specific leaf\nHash a single transform entry\nTree height (log2 of leaf count, rounded up)\nUnique identifier for this transformation\nInternal node hashes for efficient verification\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAll leaf hashes (one per log entry)\nIndex of the leaf being verified\nMerkle tree for integrity verification\nLog metadata\nCreate a new empty transform log\nHash path from leaf to root\nOptional SMT proof for semantic preservation\nRebuild the Merkle tree from all entries\nResulting span after transformation\nGet the current root hash for integrity checking\nRoot hash of the tree\nSemantic changes introduced (if any)\nNumber of semantic-preserving transformations\nSource span affected by this transformation\nGet statistics about the log\nTime span of all transformations\nTimestamp when transformation was applied\nTotal number of transformations\nThe transformation that was applied\nVerify a Merkle proof against the current root\nVerify a Merkle proof\nNumber of transformations with proofs\nB+ tree for O(log n) point queries, O(k + log n) range …\nCharacter-level bidirectional source mapping\nBuilder for constructing source maps incrementally\nStatistics about source map memory usage and performance\nCompressed span deltas for memory efficiency\nAdd a character-level mapping\nAdd a mapping between original and formatted positions\nAdd a range mapping\nAdd a span delta for compressed storage\nAdd token boundary\nAdd token boundary information\nBuild the final source map\nCalculate compression ratio compared to naive mapping\nCompressed span deltas for memory efficiency\nFind token boundary containing the given position\nFind token boundary in reverse mapping\nB+ tree for forward mapping (original -&gt; formatted)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate identity mapping for unchanged source\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLength of the span\nGet all mappings in a range\nGet human-readable memory usage\nCreate a new source map\nCharacter-level precision with token boundary awareness\nReverse mapping from formatted to original\nB+ tree for reverse mapping (formatted -&gt; original)\nStarting position delta from previous span\nGet statistics about the mapping\nToken boundaries for precise error reporting\nTransform ID that created this span\nArithmetic expression: remove all whitespace\nAssignment RHS: context-dependent\nCase pattern: preserve for alignment\nNormal command context: collapse to single space\nHere-document: preserve exactly\nInterval set for tracking preserved ranges\nString literal: preserve internal whitespace\nSemantic changes introduced by transformations\nSMT proof representation (simplified)\nTransformations form a monoid under composition\nUnique identifier for transforms\nContext-dependent whitespace handling\nMonoid composition with optimization\nCompose semantic deltas (associative operation)\nGet human-readable description\nGet human-readable description\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if delta is semantics-preserving\nCheck if transform preserves semantics\nCompute semantic delta for verification\nPreserved byte ranges (e.g., string literals)\nSMT formula asserting equivalence\nCompound types\nByte position in source text\nCharacter position in source text\nShell-specific types\nConfiguration for formatting operations\nResult of formatting operations with full provenance …\nPosition mapping result with token boundary information\nSemantic metadata preserved during formatting\nShell-specific type system for contracts\nSource span with start and end positions\nPrimitive types\nType variables for inference\nUnion types for shell’s dynamic nature\nBLAKE3-256 for content addressing (measured 89% cache hit …\nComments and their positions\nDetected contracts/specifications\nGet a human-readable representation\nWhether to enable SIMD optimizations\nExact character position\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFunction definitions\nWhether to generate SMT proofs for transformations\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if this type is compatible with another\nMaximum number of threads to use\nSemantic annotations preserved across transforms\nEnable parallel processing for large files\nWhether to preserve original whitespace in certain contexts\nCharacter-level bidirectional mapping with interval trees\nUTF-8 normalized text, zero-copy when possible\nEnd of containing token\nStart of containing token\nAppend-only log for verification context propagation\nVariable declarations and usage\nConvert a statement in a function context (handles return …\nReturns the argument unchanged.\nConvert AST to Shell IR\nCalls <code>U::from(self)</code>.\nCheck if a ShellValue represents a string type (not a …\nOptimize Shell IR based on configuration\nReading environment variables\nReading from files\nWriting to files\nNetwork access\nProcess execution\nPure computation (no side effects)\nSystem calls that modify state\nAdd an effect to this set\nAnalyze the effects of a shell command based on its name\nCheck if this effect set contains a specific effect\nReturns the argument unchanged.\nReturns the argument unchanged.\nCheck if this effect set has any file system effects\nCheck if this effect set has any network effects\nCheck if this effect set has any system modification …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if this effect set is pure\nCheck if this effect set is a subset of another\nCreate a pure effect set (no side effects)\nCreate an effect set with a single effect\nGet all effects as a vector\nUnion two effect sets\n: addition\nCommand-line argument access: $1, $2, $@, etc. Sprint 27b: …\nArgument count: $# Sprint 27b: Command-Line Arguments …\nArithmetic operation (for $((expr)))\nBoolean value (converted to “true”/“false”)\nBreak statement\nCase statement (for match expressions)\nCommand substitution\nComparison operation (for test conditions)\nConcatenated values\nContinue statement\n/ : division\nEcho a value (for function returns)\nEnvironment variable expansion: ${VAR} or ${VAR:-default} …\nCommand execution\nExit with code\nExit code of last command: $? Sprint 27c: Exit Code …\nFor loop with range\nFunction definition\n-ge: numeric greater than or equal\n-gt: numeric greater than\nConditional execution\n-le: numeric less than or equal\nVariable assignment: readonly NAME=VALUE\nLogical AND (&amp;&amp;) operation\nLogical NOT (!) operation\nLogical OR (||) operation\n-lt: numeric less than\n% : modulo\n: multiplication\nNo-op\n-eq: numeric equality\n-ne: numeric inequality\nSequence of operations\n=: string equality\n!=: string inequality\nString literal\n: subtraction\nVariable reference\nWhile loop\nGet the string representation for constant values\nGet all effects from this IR node and its children\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if this value is a constant (doesn’t depend on …\nCheck if this IR node is pure (has no side effects)\nAuto-fix application for linter diagnostics\nDiagnostic types for linting\nMakefile recipe preprocessing for bash linting\nOutput formatters for lint results\nLint rules for shell script analysis\nOptions for auto-fix application\nPriority for applying fixes when multiple fixes overlap …\nResult of applying fixes\nQuote command substitutions (SC2046) Applied SECOND after …\nQuote variables (SC2086) Applied LAST (lowest priority)\nRemove useless constructs (SC2116: useless echo) Applied …\nApply fixes with assumptions (SAFE + SAFE-WITH-ASSUMPTIONS)\nApply fixes from lint result to source code\nApply fixes to a file\nApply a single fix to source code\nBackup file path (if backup created)\nBackup file suffix\nCreate backup file before applying fixes\nDry-run mode (don’t actually modify file)\nNumber of fixes applied\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet priority for a diagnostic rule code\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nModified source code (if not dry-run)\nOptional output path (if None, modifies file in-place)\nCheck if two spans overlap\nA lint diagnostic\nError (definite syntax or semantic error, must fix)\nA suggested fix for a diagnostic\nFix safety level (following APR research best practices)\nInformational message (style, best practices)\nCollection of lint diagnostics\nSuggestion or note\nPerformance anti-pattern (not critical)\nRisk: potential runtime failure (context-dependent)\nSAFE: Semantic preservation guaranteed\nSAFE-WITH-ASSUMPTIONS: Semantic preservation under …\nSeverity level of a diagnostic\nA source code location span\nUNSAFE: Semantic transformation required\nWarning (likely bug, should fix)\nAdd a diagnostic\nAssumptions required for this fix (for SafeWithAssumptions)\nDiagnostic code (e.g., “SC2086”, “BP1001”)\nCount diagnostics by severity\nAll diagnostics found\nEnd column (1-indexed)\nEnd line (1-indexed)\nOptional suggested fix\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCheck if there are any errors\nCheck if there are any warnings\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if this fix can be applied with <code>--fix</code>\nCheck if this fix can be applied with …\nCheck if this fix should never be auto-applied\nGet the highest severity level present\nMerge another result into this one\nHuman-readable message\nCreate a new span\nCreate a new SAFE fix (default)\nCreate a new diagnostic\nCreate an empty result\nCreate an UNSAFE fix (provides suggestions, no automatic …\nCreate a SAFE-WITH-ASSUMPTIONS fix\nCreate a span for a single point\nThe replacement text\nSafety level of this fix\nSeverity level\nSource location\nStart column (1-indexed)\nStart line (1-indexed)\nAlternative suggested fixes (for Unsafe - human must …\nAdd a suggested fix\nMatch recipe lines (lines starting with tab after target …\nMatch target declarations (word followed by colon)\nPreprocess Makefile source for linting\nPreprocess a single recipe line\nHuman-readable format (default)\nJSON format\nJSON output format\nOutput format for lint results\nSARIF format (Static Analysis Results Interchange Format)\nSARIF output format (simplified version)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHuman-readable output format\nWrite lint results in the specified format\nDET001: Non-deterministic $RANDOM usage\nDET002: Non-deterministic timestamp usage\nDET003: Unordered wildcard usage\nIDEM001: Non-idempotent mkdir\nIDEM002: Non-idempotent rm\nIDEM003: Non-idempotent ln\nLint a Makefile and return all diagnostics\nLint a shell script and return all diagnostics\nMAKE001: Non-deterministic wildcard usage in Makefiles\nMAKE002: Non-idempotent mkdir in Makefile recipes\nMAKE003: Unsafe variable expansion in Makefile recipes\nMAKE004: Missing .PHONY declaration for non-file targets\nMAKE005: Recursive variable assignment in Makefiles\nMAKE006: Missing target dependencies\nMAKE007: Silent recipe errors (missing @ prefix)\nMAKE008: Tab vs spaces in recipes (CRITICAL)\nMAKE009: Hardcoded paths (non-portable)\nMAKE010: Missing error handling (|| exit 1)\nMAKE011: Dangerous pattern rules\nMAKE012: Recursive make considered harmful\nMAKE013: Missing .SUFFIXES (performance issue)\nMAKE014: Inefficient shell invocation\nMAKE015: Missing .DELETE_ON_ERROR\nMAKE016: Unquoted variable in prerequisites\nMAKE017: Missing .ONESHELL\nMAKE018: Parallel-unsafe targets (race conditions)\nMAKE019: Environment variable pollution\nMAKE020: Missing include guard\nSC2001: See if you can use ${variable//search/replace} …\nSC2002: Useless use of cat\nSC2006: Use $(…) instead of legacy backticks\nSC2027: Wrong quoting in printf format strings\nSC2028: Echo may not expand escape sequences\nSC2034: Variable assigned but never used\nSC2043: Use direct command instead of for loop with single …\nSC2044: Use find with -print0 and read -d ‘’ for safe …\nSC2045: Don’t use ls output for iteration\nSC2046: Quote command substitutions to prevent word …\nSC2048: Use “$@” (with quotes) to prevent word …\nSC2050: This expression is constant. Did you forget the $ …\nSC2066: Quote variables in [[ … ]] to prevent globbing …\nSC2068: Double quote array expansions to prevent globbing …\nSC2070: Use -n/-z for string length tests\nSC2071: Use arithmetic comparison, not string comparison\nSC2072: Decimal numbers not supported in arithmetic context\nSC2076: Don’t quote right-hand side of =~ (regex …\nSC2081: Expressions don’t expand in single quotes, use …\nSC2086: Double quote to prevent globbing and word splitting\nSC2116: Useless echo wrapping in command substitution\nSC2128: Expanding an array without an index only gives the …\nSC2154: Variable referenced but not assigned\nSC2162: read without -r will mangle backslashes\nSC2164: Use cd … || exit in case cd fails\nSC2178: Variable was used as an array but is now assigned …\nSC2181: Check exit code directly with e.g. ‘if mycmd;’…\nSC2190: Elements in associative arrays need index, e.g. …\nSC2191: The = here is literal. To assign by index, use ( […\nSC2196: egrep is deprecated and non-standard. Use grep -E …\nSEC001: Command Injection via eval\nSEC002: Unquoted Variable in Command\nSEC003: Unquoted find -exec {} Pattern\nSEC004: wget/curl Without TLS Verification\nSEC005: Hardcoded Secrets\nSEC006: Unsafe Temporary File Creation\nSEC007: Running Commands as Root Without Validation\nSEC008: Using <code>curl | sh</code> Pattern\nCheck for $RANDOM usage in shell script\nCheck for timestamp usage in shell script\nCheck for unordered wildcard usage\nCheck for mkdir without -p flag\nCheck for rm without -f flag\nCheck for ln -s without rm -f first\nCheck for unordered wildcard usage in Makefiles\nFind matching closing parenthesis\nCheck for non-idempotent mkdir usage in Makefile recipes\nCheck for unquoted variable expansions in Makefile recipes\nCommon non-file targets that should be .PHONY\nCheck for missing .PHONY declarations\nCheck for recursive variable assignments with $(shell …)\nInformation about a parsed target line\nCheck for targets with missing dependencies\nCheck if a target is missing dependencies\nCollect source files from recipe lines\nCreate a diagnostic for missing dependencies\nExtract source files (.c, .cpp, .h, .rs, etc.) from a …\nFind dependencies that are missing from declared …\nFind all .PHONY targets in the Makefile\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nParse a target line and extract target name and …\nCheck if a line should be skipped (not a target definition)\nCommands that should typically be silent\nCheck for echo/printf commands without @ prefix\nCheck a recipe line for echo/printf without @ prefix\nCheck if trimmed line starts with the given command\nCheck for spaces instead of tabs in recipe lines\nHardcoded paths that should use variables\nCheck for hardcoded installation paths\nCreate fix by replacing hardcoded /usr/local with $(PREFIX)\nCommands that should have error handling\nCheck for missing error handling in recipe commands\nFind if the recipe contains a critical command\nCheck if a recipe line already has error handling\nDangerous pattern rules (too broad)\nCheck for dangerous pattern rules\nCheck line for dangerous pattern and create diagnostic if …\nCreate a fix by suggesting a more specific pattern\nCheck if line contains a dangerous pattern\nCheck if line is a target line (contains ‘:’ and not a …\nPatterns that indicate recursive make\nCheck for recursive make invocations\nCreate fix by suggesting include directive instead of …\nExtract subdirectory from make -C or –directory command\nCheck for missing .SUFFIXES to disable built-in implicit …\nCheck if Makefile has .SUFFIXES directive (case-sensitive)\nInefficient shell patterns to detect\nCheck for inefficient shell invocations\nCreate a fix by replacing inefficient pattern with …\nCheck for missing .DELETE_ON_ERROR special target\nCreate fix by adding .DELETE_ON_ERROR: at top of Makefile\nCheck if Makefile has .DELETE_ON_ERROR (case-sensitive)\nCheck for unquoted variables in prerequisites\nCreate a fix by adding quotes around the unquoted variable\nExtract prerequisites part from target line (everything …\nExtract a variable reference starting at position (e.g., …\nFind all unquoted variables in prerequisites Returns …\nCheck if a variable is an automatic variable ($@, $&lt;, $^, …\nCheck if line is a target line (contains ‘:’ and not a …\nCheck for missing .ONESHELL directive\nCheck if Makefile has any multi-line recipes (targets with …\nCheck if Makefile has .ONESHELL directive (case-sensitive)\nPatterns that indicate shared state modification\nTarget with its shared state writes\nCheck for parallel-unsafe targets\nCollect targets that write to shared state\nFind targets with overlapping shared state writes\nReturns the argument unchanged.\nCheck if Makefile has .NOTPARALLEL\nCalls <code>U::from(self)</code>.\nVariables that commonly should NOT be exported …\nCheck for unnecessary export statements\nCreate a fix by removing “export “ keyword\nExtract variable name from export statement e.g., “…\nCheck if variable is internal (shouldn’t be exported)\nCheck for missing include guards in Makefiles meant for …\nCreate fix by adding include guard around entire file\nCheck if Makefile has any ifndef directive\nCheck if Makefile should have an include guard (has …\nCheck for sed usage that could be replaced with parameter …\nCheck for useless use of cat\nCheck for deprecated backtick command substitution\nCheck for wrong quoting in printf format strings\nCheck for echo with escape sequences without -e flag\nCreate diagnostic for subshell variable usage\nFind subshell variable assignments on a line\nCheck if line contains a subshell (standalone parentheses, …\nCheck if position in line is inside quotes (double or …\nCheck if position in line is inside single quotes (where …\nCheck if variable usage is on same line as assignment …\nCheck for variables assigned but never used\nCreate diagnostic for unescaped quote in backticks\nFind unescaped quote position inside backtick expression\nCheck if quote at position is escaped\nCheck if character at position is a quote\nCheck if character at position is an unescaped quote\nCheck if line should be analyzed (has backticks and quotes)\nCreate diagnostic for read in for loop\nCheck if line starts a for loop\nCheck if position in line is inside quotes\nCheck if read is between do and done in single-line for …\nCheck if line is a single-line for loop (for x in y; do …\nCheck if read command is part of while read (which is …\nCheck for useless for loops with single element\nCheck for find in for loops without -print0\nCheck for ls in for loops\nCheck for unquoted command substitutions (SC2046)\nCheck for unquoted $* that should be “$@”\nCheck if a position in a line is inside quotes\nCheck for constant comparisons (missing $ on variables)\nCheck for unquoted variables in [[ … ]] conditionals\nCheck if variable is on the right side of == or != …\nCheck if a variable is already quoted at a position\nCheck for unquoted array expansions ($@, $<em>, ${array[@]}, </em>…\nCheck if a position in a line is inside quotes\nCheck for implicit string length tests that should use …\nCheck for string comparison operators used on numbers\nCheck for decimal numbers in arithmetic contexts\nCheck for quoted regex patterns in =~ comparisons\nCheck for variable/command expansion in single quotes\nBuild diagnostic for unquoted variable\nCalculate end column for variable span, including closing …\nCheck for unquoted variable expansions (SC2086)\nFind the position of $ character before a variable\nCheck if variable is already quoted\nCheck if variable is in arithmetic context (inside $(( )))\nCheck if line should be skipped (comments or assignments)\nCheck for useless echo in command substitutions (SC2116)\nCheck for array reference without index\nCheck for variables referenced but not assigned\nCheck for read without -r flag\nCheck for cd without error handling\nCheck for string assignment to array variable\nCheck for indirect $? comparisons\nCheck for associative array without keys\nCheck for space between = and ( in array assignment\nCheck for deprecated egrep/fgrep commands\nCreate diagnostic for array used as scalar in test\nCheck if variable usage has array subscript or is length …\nCheck if variable name looks like an array (heuristic)\nCheck if line should be checked (has single brackets, not …\nCheck for command injection via eval\nDangerous commands that should never have unquoted …\nCheck for unquoted variables in dangerous commands\nCheck for unquoted {} in find -exec\nCheck for disabled TLS verification in wget/curl\nPatterns that indicate hardcoded secrets\nCheck for hardcoded secrets\nCheck for unsafe temporary file creation\nDangerous commands that should never be run with sudo + …\nCheck for unsafe sudo operations\nCheck for curl/wget piped to shell\nAST (Abstract Syntax Tree) for GNU Makefiles\nEnhanced error types for Makefile parser\nCode generators for Makefile AST\nLexer for Makefiles\nMakefile parser\nSemantic analysis for Makefile AST\nAppend (+=) - add to existing value\nA comment line\nA conditional block (ifeq, ifdef, etc.)\nConditional assignment (?=) - only if not already defined\nA function call\nifdef VAR\nifeq ($(VAR),value)\nifndef VAR\nifneq ($(VAR),value)\nAn include directive\nRoot AST node representing a complete Makefile\nConditional types in Makefiles Makefile conditional …\nMakefile constructs (targets, variables, conditionals, …\nMetadata about the parsed Makefile\nA pattern rule\nRecursive assignment (=) - expanded when used\nShell assignment (!=) - execute shell command\nSimple assignment (:=) - expanded immediately (PREFERRED)\nSource location information\nA target with prerequisites and recipe\nVariable assignment flavors\nA variable assignment\nCreate a dummy span (for testing or when location is …\nEnd byte offset\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAll items in the Makefile (targets, variables, …\nLine number (1-indexed)\nNumber of lines in the source\nMetadata about the Makefile\nCreate default metadata\nCreate a span with specific values\nParse time in milliseconds\nSource file path (if available)\nStart byte offset\nCreate metadata with line count\nFunction arguments\nCondition type\nItems in the “else” branch (if present)\nVariable flavor (=, :=, ?=, +=, !=)\nTarget name (e.g., “build”, “test”, “clean”)\nVariable name\nFunction name (e.g., “wildcard”, “patsubst”)\nWhether this is optional (-include)\nFile path to include\nWhether this target is marked as .PHONY\nPrerequisite patterns\nList of prerequisites (targets or files this depends on)\nRecipe lines (commands to execute, tab-indented)\nRecipe lines\nSource location\nSource location\nSource location\nSource location\nSource location\nSource location\nSource location\nTarget pattern (e.g., “%.o”)\nComment text (without the # prefix)\nItems in the “then” branch\nVariable value\nEnhanced error types for Makefile parsing\nSource location information for error reporting\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet recovery hint for this error\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the location information for this error\nGet explanatory note for this error\nCalculate quality score for this error\nConvert to a displayable error message with note and help\nGenerate a comment\nGenerate a conditional block\nGenerate an include directive\nGenerate text for a single MakeItem\nGenerate a pattern rule\nGenerate a purified Makefile from an AST\nGenerate a target with prerequisites and recipe\nGenerate a variable assignment\nDetect if a string contains a GNU Make function call\nExtract function calls from a string\nCheck if a line is a variable assignment\nParse a conditional block starting at the given line index\nParse a single item within a conditional block\nParse a define…endef block for multi-line variable …\nParse an include directive\nParse a Makefile string into an AST\nParse a target rule starting at the given line index\nParse a variable assignment\nPreprocess Makefile input to handle line continuations\nSplit function arguments by commas, respecting nested …\nAdd comment suggesting manual fix\nDetect bashisms (non-POSIX shell constructs)\nDetect shared directory creation race\nDetect missing error handling in loops\nDetect missing dependency\nDetect missing error handling in recipes\nDetect missing set -e in shell scripts\nDetect non-deterministic command (hostname, git, mktemp, …\nDetect non-portable echo usage\nDetect non-portable command flags\nDetect multiple targets with same output\nDetect platform-specific commands\nDetect process ID $$ usage\nDetect race condition in shared file write\nDetect $RANDOM usage\nDetect multiple sequential recipe lines that could be …\nDetect shell-specific features (source, declare, etc.)\nDetect silent failures with @ prefix\nDetect non-deterministic timestamp ($(shell date))\nResult of purification process\nRecommend .DELETE_ON_ERROR\nRecommend adding .NOTPARALLEL directive\nRecommend .ONESHELL for multiline recipes\nRecommend adding order-only prerequisite\nRecommend handling recursive make calls\nRecommend adding .SUFFIXES: to disable builtin rules\nSuggest combining multiple shell invocations\nSuggest pattern rule instead of explicit rules\nSuggest using := instead of = for simple variables\nSuggest SOURCE_DATE_EPOCH for reproducibility\nType of transformation to apply\nWrap pattern with $(sort …)\nAnalyze Makefile for error handling issues (Sprint 83 - …\nAnalyze Makefile for parallel safety issues (Sprint 83)\nAnalyze Makefile for performance optimization …\nAnalyze Makefile for portability issues (Sprint 83 - Day 7)\nAnalyze Makefile for reproducible builds issues (Sprint 83 …\nApply transformations to AST\nPurified AST\nExtract variable name from semantic issue message\nFind matching closing parenthesis for pattern starting at …\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate human-readable report of transformations\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if transformation can be applied safely\nNumber of issues successfully fixed\nNumber of issues requiring manual intervention\nPlan which transformations to apply for detected issues\nPurify a Makefile AST by fixing non-deterministic patterns\nReport of transformations\nNumber of transformations applied\nWrap specific pattern with $(sort …)\nWrap pattern in specific variable with $(sort …)\nCommon non-file targets that should be marked as .PHONY\nCritical - breaks determinism or idempotency\nHigh - reduces build reproducibility\nIssue severity levels for semantic analysis\nLow - style or best practice\nMedium - potential issue\nSemantic issue found in Makefile\nAnalyze a Makefile AST for semantic issues\nDetect non-deterministic $RANDOM or $(shell echo $$RANDOM) …\nDetect non-deterministic $(shell date) patterns in a …\nDetect non-deterministic $(shell find) patterns in a …\nDetect non-deterministic $(wildcard) patterns in a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if a target name is a common non-file target that …\nIssue description\nPurification rule that detected this\nSeverity level\nLocation in source\nSuggested fix (if available)\nAlmquist Shell (BusyBox)\nBash (version 3.2+)\nBasic safety checks only\nConfiguration options for transpilation.\nDebian Almquist Shell\nNo verification (not recommended)\nMaximum verification (slowest)\nPOSIX sh - maximum compatibility\nTarget shell dialect for generated scripts.\nStrict verification (recommended)\nLevel of verification applied during transpilation.\nWhether to emit formal verification proofs\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nEnable IR optimization passes\nEnable strict POSIX mode (no extensions)\nTarget shell dialect for generated scripts\nShellCheck validation level\nLevel of verification to apply during transpilation\nEnhanced diagnostic information for errors\nInternal compiler errors\nI/O errors\nSyntax/parse errors\nIR generation errors\nUnsupported Rust features\nValidation errors\nCategorize error and provide helpful context\nError category (for grouping similar errors)\nColumn number (if available)\nThe underlying error\nSource file path (if available)\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a diagnostic from an error with context\nSuggested fix or workaround\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLine number (if available)\nAdditional context/explanation\nCalculate quality score (0.0 to 1.0)\nCode snippet (if available)\nContains the error value\nContains the error value\nContains the success value\nContains the success value\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMain REPL loop for bashrs\nConfiguration for the bashrs REPL\nEnable debug mode (default: false)\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nMaximum recursion depth (default: 100)\nMaximum memory usage in bytes (default: 100MB)\nCreate a new ReplConfig with custom settings\nCreate a sandboxed configuration (for untrusted input)\nEnable sandboxed execution (default: false)\nExecution timeout for commands (default: 30 seconds)\nValidate configuration\nEnable debug mode\nSet maximum recursion depth\nSet maximum memory\nSet timeout\nFormat lint results for display in REPL\nLint bash input and return diagnostics\nGet history file path\nHandle lint command\nHandle mode switching command\nHandle parse command\nHandle purify command\nPrint help message\nMain REPL loop for bashrs\nDebug mode - step-by-step execution\nExplain mode - explain bash constructs\nLint mode - show linting results\nNormal mode - execute commands directly\nPurify mode - show purified version of bash commands\nREPL execution modes\nGet mode name as string\nGet mode description\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nParse mode from string (case-insensitive)\nFormat parse error for display in REPL\nParse bash input and return AST\nFormat purification report for display\nPurify bash input and return purified AST with report\nMutable state for a REPL session\nAdd a command to history\nClear command history\nClear all variables\nGet error count\nError count (for debugging and statistics)\nExit requested flag (for clean shutdown)\nReturns the argument unchanged.\nGet a specific history entry\nGet a session variable\nGet command history\nCommand history (for up/down arrow navigation)\nGet history length\nCalls <code>U::from(self)</code>.\nGet current REPL mode\nCurrent REPL mode\nCreate a new REPL state\nIncrement error count\nRemove a session variable\nRequest exit\nReset error count\nSet REPL mode\nSet a session variable\nCheck if exit was requested\nGet variable count\nGet all variables\nSession variables (persist across commands)\nParse Rust source code into a RestrictedAst\nAll stdlib functions\nStdlib function metadata\nReturns the argument unchanged.\nGet the shell function name for a stdlib function\nCalls <code>U::from(self)</code>.\nCheck if a function name is a stdlib function\nCore Test Generator Infrastructure\nCoverage Tracking and Analysis\nDoctest Generation (Sprint 3)\nMutation Test Configuration Generation (Sprint 3)\nProperty Test Generation (Sprint 2)\nUnit Test Generation\nContains the error value\nComplete generated test suite\nContains the success value\nConfiguration options for test generation\nMain test generator orchestrator\nGet coverage report\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate complete test suite from bash AST\nGenerate doctests from comments\nGenerate mutation test configuration\nGenerate property tests using proptest\nGenerate unit tests for each function\nGenerate tests until coverage target is met\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWrite mutation config to file\nNumber of property test cases\nTarget coverage percentage (0-100)\nTarget mutation score (0-100)\nFormat as Rust test module\nUse existing bashrs_runtime\nUnique identifier for a code branch\nTracks code coverage for generated tests\nQuality metrics report\nRepresents an uncovered code path\nAnalyze test suite and calculate coverage\nCalculate branch coverage percentage\nCalculate line coverage percentage\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if coverage meets target\nSet total branches to track\nSet total lines to track\nGet uncovered code paths\nExtract doctests from a function’s comments\nExtract examples from inline comments\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate default examples based on function structure\nGenerate doctests from bash comments\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert to Rust doctest code\nAnalyze code complexity to determine configuration\nAnalyze a single statement for complexity\nBase timeout in seconds\nBuild configuration based on complexity metrics\nCalculate cyclomatic complexity for a function body\nCalculate optimal number of parallel jobs\nCalculate appropriate timeout based on complexity\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate mutation test configuration\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSelect mutation operators based on code patterns\nTarget mutation score (0.0 - 1.0)\nConvert to TOML configuration format\nExtract bounds from conditional statements\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate bounds checking property tests\nGenerate determinism property test (same input → same …\nGenerate idempotency property test (f(f(x)) == f(x))\nGenerate property tests for AST\nGenerate type preservation property test\nCheck if function has non-deterministic operations\nInfer proptest generators from function signature and body\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if function is potentially idempotent\nMaximum test cases per property\nConvert to proptest strategy code\nGenerate Rust code for this property test\nTest assertion types\nComment for documentation\nassert_eq!(actual, expected)\nassert!(!condition)\nassert_ne!(actual, expected)\n#[should_panic]\nassert!(condition)\nA single unit test\nGenerates unit tests for bash functions\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate boundary value tests\nGenerate tests for branch coverage (if/else, case, loops)\nGenerate edge case tests (empty strings, null, max values)\nGenerate error case tests\nGenerate tests for a specific function\nGenerate targeted tests for specific uncovered paths\nGenerate unit tests for all functions in AST\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConvert to Rust test code\nConvert to Rust assertion code\nCheck if function body uses arithmetic operations\nCheck if function body uses file operations\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nVerify that the given IR satisfies safety properties\nVerify that the IR is deterministic (same inputs produce …\nVerify that the IR represents idempotent operations\nVerify that the IR contains no command injection …\nVerify that the IR doesn’t use excessive resources\nJavaScript API for bashrs WASM\nBuilt-in Bash Commands for WASM Runtime\nConfig management for WASM\nBash Script Executor for WASM Runtime\nVirtual Filesystem for WASM\nI/O Streams for WASM Bash Runtime\nStreaming I/O for WASM\nVirtual Filesystem for WASM Bash Runtime\nConfiguration analysis result\nA single configuration issue\nBash script execution result\nAnalyze a shell configuration file\nGet complexity score (0-10)\nExecute a bash script in WASM runtime\nGet exit code\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInitialize the WASM module\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if content is valid bash syntax\nGet the number of issues found\nGet issues as JSON string\nGet line count\nPurify a shell configuration file\nGet stderr output\nGet stdout output\nGet result as JSON string\nGet bashrs version\nBash built-in commands\nExecute cd command\nExecute echo command\nExecute a builtin command\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCheck if a command is a builtin\nExecute pwd command\nExecute tr command (translate characters)\nExecute wc command (word count)\nBash script executor\nExecution result\nStored function definition\nArrays (name -&gt; elements)\nFunction body (lines of code)\nEnvironment variables\nEvaluate an arithmetic expression\nEvaluate a condition (handles both [ … ] tests and …\nEvaluate test command: [ condition ] Returns true if …\nExecute a bash script\nExecute a brace group (shared scope) Brace groups execute …\nExecute a case statement\nExecute a single command (or pipeline)\nExecute a for loop Returns (end_line_index, exit_code)\nExecute a function call\nExecute an if statement Returns (end_line_index, exit_code)\nExecute a range of lines with control flow support (for …\nExecute a pipeline: cmd1 | cmd2 | cmd3\nExecute a subshell (isolated scope) Subshells create a new …\nExecute a command for substitution (creates a new executor …\nExecute a while loop Returns (end_line_index, exit_code)\nLast exit code\nExit code\nExpand arithmetic expressions: $((expr)) -&gt; evaluated …\nExpand variables in arithmetic context (no $ prefix needed)\nExpand command substitutions: $(cmd) -&gt; command output\nExpand parameter expressions: arr[0], arr[@], #arr[@], …\nParse and expand variables in a string\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nDefined functions (name -&gt; definition)\nRecursive glob pattern matching\nCheck if line contains a pipeline (| outside quotes)\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nI/O streams\nCheck if a line is a function call\nCheck if a line is a function definition\nCreate new bash executor\nParse and evaluate arithmetic expression with proper …\nParse array access syntax: arr[index] -&gt; (arr, index)\nParse array element assignment: arr[index]=value\nParse array declaration: arr=(a b c)\nParse array elements from string, handling quotes\nCheck if line is a variable assignment\nParse command line into words (simple space-based …\nParse expression: term ((‘+’ | ‘-’) term)*\nParse factor: ‘(’ expr ‘)’ | ‘-’ factor | …\nParse a function definition and store it\nParse term: factor ((‘<em>’ | ‘/’ | ‘%’) factor)</em>\nCheck if a pattern matches a value (glob-style matching)\nPreprocess here documents (heredocs) Converts &lt;&lt;DELIMITER …\nRemove longest prefix matching pattern (simple glob)\nRemove longest suffix matching pattern (simple glob)\nRemove shortest prefix matching pattern (simple glob)\nRemove shortest suffix matching pattern (simple glob)\nFlag indicating exit command was called\nSplit pipeline into individual commands (respecting quotes)\nCaptured stderr\nCaptured stdout\nTokenize arithmetic expression\nVirtual filesystem\nVirtual filesystem interface\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nWriter that captures output to an in-memory buffer\nI/O streams for bash execution\nShared writer that wraps Arc&lt;Mutex&gt;\nGet captured content as UTF-8 string\nClear stdin\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet captured stderr as UTF-8 string\nGet stdin content\nGet captured stdout as UTF-8 string\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new capture writer\nCreate new I/O streams with capture buffers\nSet stdin content (for pipelines)\nBenchmark result\nStatistics from streaming operation\nBenchmark streaming performance\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if performance meets requirements\nStream output to JavaScript callback\nDirectory with children\nRegular file with content\nSymbolic link\nVirtual filesystem node\nIn-memory virtual filesystem\nChange current working directory\nCurrent working directory\nCheck if path exists\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet node at path\nGet mutable node at path\nGet current working directory\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if path is a directory\nCreate directory\nCreate new virtual filesystem with standard Unix directory …\nResolve path (handle . and .., relative/absolute)\nRoot directory")