---
roadmap:
  title: "Bash Ingestion Roadmap - EXTREME TDD"
  goal: "Document every Bash construct transformation to Rust and Purified Bash"
  methodology: "EXTREME TDD (Test-First, RED-GREEN-REFACTOR)"
  reference: "GNU Bash Manual (bash.pdf)"
  status: "IN_PROGRESS"
  completion: "20%"

  statistics:
    total_tasks: 122
    completed: 76
    partial_support: 0
    pending: 43
    blocked: 3
    coverage_percent: 62
    accuracy_verified: "2025-10-28"
    total_tests: 5,066
    session_update: "Completed JOB-001 (7.1 - Background jobs &). 6 passing tests document background jobs as NOT SUPPORTED (HIGH priority purification). Background jobs (&) run command in background, return control immediately (syntax: cmd &). WHY NOT SUPPORTED (5): Non-deterministic (race conditions), Timing-dependent (order not guaranteed), Makes testing impossible (can't assert while running), Resource management issues (orphan processes), No error handling (silent failures). CRITICAL: Background jobs violate determinism - concurrent execution introduces race conditions. 5 RACE CONDITIONS: Output interleaving, File access conflicts, Resource contention, Dependency violations, Exit status ambiguity. PURIFICATION STRATEGIES (4): (1) Convert to foreground (RECOMMENDED), (2) Sequential execution (RECOMMENDED), (3) Remove background job entirely, (4) Use make -j for parallelism (if needed). Testing issues (4): Cannot assert on intermediate state, flaky tests due to timing, cannot isolate failures, cleanup issues (orphan processes). Portability: Job control is OPTIONAL in POSIX (not all shells support &, jobs, fg, bg). Comparison table: Bash (&, jobs, fg, bg, wait) vs POSIX (& OPTIONAL, others not guaranteed) vs Purified (sequential execution only). Total tests: 5,066 (100% passing)."

extreme_tdd_workflow:
  description: "Hybrid workflow combining GNU Bash validation with REPL verification"
  methodology: "EXTREME TDD + Interactive REPL Validation"
  updated: "2025-10-26"

  steps:
    - id: 1
      name: "RED"
      description: "Write failing test first"
      example: |
        #[test]
        fn test_<TASK_ID>_<feature>_<scenario>() {
            let bash = "<bash input>";
            let rust = "<expected rust>";
            let purified = "<expected purified bash>";

            assert_eq!(bash_to_rust(bash), rust);
            assert_eq!(bash_to_purified(bash), purified);
        }

    - id: 2
      name: "GREEN"
      description: "Implement transformation"
      substeps:
        - "Update parser for bash construct"
        - "Update Rust AST generation"
        - "Update purified bash emission"

    - id: 3
      name: "REFACTOR"
      description: "Clean up implementation"
      substeps:
        - "Extract common patterns"
        - "Add helper functions"
        - "Document edge cases"

    - id: 4
      name: "REPL VERIFICATION"
      description: "Validate feature interactively in REPL"
      substeps:
        - "Run `bashrs repl` and test bash construct manually"
        - "Verify expected behavior matches specification"
        - "Test edge cases interactively"
        - "Document any REPL-specific issues discovered"
      example: |
        $ bashrs repl
        bashrs> x=5
        bashrs> echo $x
        5
        bashrs> echo ${x:-default}
        5
        bashrs> echo ${unset:-fallback}
        fallback
      notes: "Interactive validation catches integration issues that unit tests miss"

    - id: 5
      name: "PROPERTY TESTING"
      description: "Add property-based tests"
      substeps:
        - "Create proptest with 100+ generated cases"
        - "Verify determinism property"
        - "Verify idempotency property"

    - id: 6
      name: "MUTATION TESTING"
      description: "Verify test quality"
      substeps:
        - "Run cargo-mutants on modified files"
        - "Target ≥90% mutation kill rate"
        - "Fix surviving mutants"

    - id: 7
      name: "PMAT VERIFICATION"
      description: "Verify with paiml-mcp-agent-toolkit quality analysis"
      substeps:
        - "Run `pmat analyze complexity --max 10` to verify code complexity"
        - "Run `pmat quality-score --min 9.0` to verify overall quality"
        - "Run `pmat verify --spec rash.spec --impl target/debug/bashrs` if applicable"
        - "Address any quality issues detected"
      example: |
        $ pmat analyze complexity --max 10
        ✅ All functions below complexity 10

        $ pmat quality-score --min 9.0
        ✅ Quality score: 9.5/10
      notes: "pmat provides additional quality verification beyond standard tooling"

    - id: 8
      name: "DOCUMENT"
      description: "Update documentation"
      substeps:
        - "Update this roadmap YAML file"
        - "Mark task as 'completed'"
        - "Add implementation details"
        - "Add REPL verification notes"
        - "Add pmat verification results"
        - "Update CHANGELOG.md"

cli_testing_protocol:
  description: "MANDATORY CLI testing patterns using assert_cmd"
  requirement: "All CLI tests MUST use assert_cmd crate"

  test_naming_convention:
    format: "test_<TASK_ID>_<feature>_<scenario>"
    examples:
      - "test_PARAM_POS_001_positional_params_basic"
      - "test_EXP_PARAM_009_remove_longest_suffix_cli"
      - "test_LOOP_001_until_loop_cli_output"
    rationale: "Enables traceability to roadmap tasks"

  assert_cmd_pattern:
    mandatory: true
    never_use: "std::process::Command for CLI testing"
    helper_function: |
      use assert_cmd::Command;
      use predicates::prelude::*;

      fn rash_cmd() -> Command {
          Command::cargo_bin("rash")
              .expect("Failed to find rash binary")
      }

    basic_test_example: |
      #[test]
      fn test_PARSE_001_parse_basic_bash() {
          rash_cmd()
              .arg("parse")
              .arg("examples/hello.sh")
              .assert()
              .success()
              .stdout(predicate::str::contains("AST"));
      }

    error_handling_example: |
      #[test]
      fn test_PARSE_001_invalid_file_error() {
          rash_cmd()
              .arg("parse")
              .arg("nonexistent.sh")
              .assert()
              .failure()
              .stderr(predicate::str::contains("Error"));
      }

  tool_validation_protocol:
    description: "Test each feature with all relevant Rash CLI tools"
    core_tools:
      - tool: "rash parse <file>"
        purpose: "Parse bash/Makefile to AST"
        test_requirement: "MANDATORY for all features"

      - tool: "rash purify <file>"
        purpose: "Purify bash/Makefile"
        test_requirement: "MANDATORY for purification features"

      - tool: "rash transpile <file>"
        purpose: "Transpile Rust to shell"
        test_requirement: "MANDATORY for transpilation features"

      - tool: "rash lint <file>"
        purpose: "Lint bash/Makefile"
        test_requirement: "MANDATORY for linting features"

      - tool: "rash check <file>"
        purpose: "Type-check and validate"
        test_requirement: "MANDATORY for type-checking features"

    quality_tools:
      - tool: "rash ast <file>"
        purpose: "Output AST in JSON"
        test_requirement: "Recommended for debugging"

      - tool: "rash analyze <file>"
        purpose: "Analyze complexity and safety"
        test_requirement: "Recommended for production features"

  integration_test_pattern:
    description: "End-to-end CLI workflow testing"
    example: |
      #[test]
      fn test_integration_bash_to_purified() {
          let messy = "tests/fixtures/messy_deploy.sh";
          std::fs::write(messy, "SESSION_ID=$RANDOM").unwrap();

          // Step 1: Parse succeeds
          rash_cmd().arg("parse").arg(messy).assert().success();

          // Step 2: Purify produces deterministic output
          let purified = "tests/fixtures/purified_deploy.sh";
          rash_cmd()
              .arg("purify")
              .arg(messy)
              .arg("--output")
              .arg(purified)
              .assert()
              .success();

          // Step 3: Verify content
          let content = std::fs::read_to_string(purified).unwrap();
          assert!(!content.contains("$RANDOM"));

          // Step 4: Shellcheck validation
          Command::new("shellcheck")
              .arg("-s").arg("sh")
              .arg(purified)
              .assert()
              .success();

          // Cleanup
          let _ = std::fs::remove_file(messy);
          let _ = std::fs::remove_file(purified);
      }

  quality_gates:
    description: "CLI testing quality gates (all must pass)"
    requirements:
      - name: "assert_cmd usage"
        requirement: "All CLI tests use assert_cmd::Command"
        failure_severity: "QUALITY DEFECT"

      - name: "Test naming"
        requirement: "All tests follow test_<TASK_ID>_<feature>_<scenario>"
        failure_severity: "TRACEABILITY ISSUE"

      - name: "Tool validation"
        requirement: "Feature tested with all relevant CLI tools"
        failure_severity: "INCOMPLETE TESTING"

      - name: "Success cases"
        requirement: "Happy path tests pass"
        failure_severity: "FEATURE BROKEN"

      - name: "Error cases"
        requirement: "Error handling tests pass"
        failure_severity: "POOR ERROR HANDLING"

      - name: "Edge cases"
        requirement: "Boundary conditions tested"
        failure_severity: "INCOMPLETE COVERAGE"

      - name: "Property tests"
        requirement: "100+ generated cases pass"
        failure_severity: "INSUFFICIENT TESTING"

      - name: "Mutation tests"
        requirement: "≥90% kill rate"
        failure_severity: "WEAK TESTS"

      - name: "Integration tests"
        requirement: "End-to-end workflows verified"
        failure_severity: "NO E2E COVERAGE"

      - name: "Documentation"
        requirement: "CLI usage documented"
        failure_severity: "POOR UX"

chapters:
  - id: 1
    name: "Introduction"
    tasks:
      - id: "1.1"
        title: "Document bash shebang transformation"
        status: "completed"
        version: "v1.3.0"
        input: "#!/bin/bash"
        rust: "fn main() {}"
        purified: "#!/bin/sh"
        test_name: "test_shebang_transformation"
        tests_added:
          - "test_shebang_transformation (unit test)"
          - "prop_purified_bash_uses_posix_shebang (property test, 100 cases)"
          - "prop_purified_bash_preserves_commands (property test, 100 cases)"
        notes: "POSIX sh shebang always generated in purified output. Verified with EXTREME TDD: RED->GREEN->REFACTOR->PROPERTY TESTING."
        implementation:
          module: "rash/src/bash_parser/generators.rs"
          function: "generate_purified_bash()"
          lines_of_code: 170

      - id: "1.2"
        title: "Document interactive vs script mode"
        status: "completed"
        version: "v6.6.0"
        input: "Interactive bash session (read, select, TTY detection)"
        rust: "Not applicable (compile-time only)"
        purified: "Script mode only (deterministic, command-line args)"
        test_name: "test_TASK_1_2_script_mode_only_philosophy"
        notes: "bashrs supports SCRIPT MODE ONLY (deterministic, non-interactive). 4 passing tests document philosophy, unsupported features, transformation strategy, and automation requirements."
        implementation:
          module: "rash/src/bash_parser/tests.rs"
          functions:
            - "test_TASK_1_2_script_mode_only_philosophy (passing)"
            - "test_TASK_1_2_interactive_mode_not_supported (passing)"
            - "test_TASK_1_2_deterministic_script_transformation (passing)"
            - "test_TASK_1_2_automation_friendly_design (passing)"
          lines_of_code: 214
          documentation: "Comprehensive documentation of bashrs script-mode-only philosophy. Interactive features NOT SUPPORTED (read, select, TTY). Transformation strategy: read → command-line args, deterministic execution, automation-friendly design."
          philosophy:
            - "Script mode only - no interactive features"
            - "Fully deterministic (same input → same output)"
            - "Automation-friendly (works in CI/CD, Docker, cron)"
            - "Testable (no human interaction required)"
          unsupported_features:
            - "read command (use command-line args instead)"
            - "select menus (use config files or case statements)"
            - "TTY detection (assume non-TTY always)"
            - "History navigation (use git for versioning)"
            - "Tab completion (use IDE/editor)"
          supported_features:
            - "Functions, variables, control flow"
            - "File I/O, process execution"
            - "Command-line argument parsing ($1, $2, $@)"
            - "Environment variables"
            - "Exit codes, error handling"
          transformation_strategy:
            - "read var → var=\"$1\" (command-line args)"
            - "select → case statement with $1"
            - "TTY checks → assume batch mode"
          priority: "HIGH"

  - id: 2
    name: "Definitions"
    tasks:
      - id: "2.1"
        title: "Document POSIX-only constructs"
        status: "completed"
        version: "v6.6.0"
        input: "Bash-specific syntax ([[ ]], let, $'...', &>, arrays, etc.)"
        rust: "Standard Rust constructs"
        purified: "POSIX sh syntax only (#!/bin/sh, [ ], $((...)), printf, case)"
        test_name: "test_TASK_2_1_posix_only_purification_policy"
        notes: "bashrs purification policy: OUTPUT POSIX SH ONLY. 5 passing tests document POSIX-only policy, Bash extensions NOT generated, POSIX constructs always used, portability across shells, and quality gates."
        implementation:
          module: "rash/src/bash_parser/tests.rs"
          functions:
            - "test_TASK_2_1_posix_only_purification_policy (passing)"
            - "test_TASK_2_1_bash_extensions_not_generated (passing)"
            - "test_TASK_2_1_posix_constructs_always_generated (passing)"
            - "test_TASK_2_1_portability_across_shells (passing)"
            - "test_TASK_2_1_purification_quality_gates (passing)"
          lines_of_code: 319
          documentation: "Comprehensive documentation of bashrs POSIX-only purification policy. Bash extensions NEVER generated ([[ ]], let, $'...', &>, (( )), arrays, <(...), {1..10}). POSIX constructs ALWAYS generated (#!/bin/sh, [ ], $((...)), printf, case, quoted variables). Quality gates for all purified scripts."
          bash_extensions_not_generated:
            - "[[ ]] → [ ] (POSIX single brackets)"
            - "$'...' → printf with format strings"
            - "let → $((...)) (POSIX arithmetic)"
            - "&> → >file 2>&1 (POSIX redirection)"
            - "[[ =~ ]] → case or grep"
            - "(( )) → $((...)) (POSIX arithmetic)"
            - "declare -a arrays → positional parameters or multiple variables"
            - "<(...) → temporary files with mktemp"
            - "{1..10} → seq 1 10 or explicit list"
          posix_constructs_always_generated:
            - "#!/bin/sh (not #!/bin/bash)"
            - "[ ] for conditionals (not [[ ]])"
            - "$((...)) for arithmetic"
            - "printf (not echo)"
            - "case statements (not [[ =~ ]])"
            - "Quoted variables: \"$VAR\" (not $VAR)"
            - ">file 2>&1 (not &>)"
            - "$(...) command substitution (not `...`)"
            - "[ \"$x\" = \"$y\" ] (not ==)"
          portability:
            - "Works on: dash, ash, busybox sh, bash, zsh, ksh, pdksh"
            - "Tested on: dash (Debian/Ubuntu), ash (Alpine), busybox sh (containers)"
            - "Standards: IEEE Std 1003.1-2001 compliant"
          quality_gates:
            - "shellcheck -s sh (POSIX compliance check)"
            - "dash -n (syntax validation)"
            - "busybox sh (minimal shell execution)"
            - "All variables quoted (\"$VAR\" not $VAR)"
            - "No Bash-specific patterns"
            - "Determinism (no $RANDOM, timestamps, $$)"
            - "Idempotency (mkdir -p, rm -f, ln -sf)"
          priority: "HIGH"

  - id: 3
    name: "Basic Shell Features"
    sections:
      - id: "3.1"
        name: "Shell Syntax"
        subsections:
          - id: "3.1.1"
            name: "Shell Operation"
            tasks:
              - id: "3.1.1.1"
                title: "Document command execution"
                status: "completed"
                version: "v6.6.0"
                input: "echo \"hello\""
                rust: "fn main() { echo(\"hello\"); }"
                purified: "printf '%s\\n' \"hello\""
                test_name: "test_ECHO_001_simple_echo_command"
                notes: "Echo commands fully supported. POSIX printf preferred for portability. 4 passing tests verify echo parsing, 2 ignored tests document echo flag purification."
                implementation:
                  module: "rash/src/bash_parser/tests.rs"
                  functions:
                    - "test_ECHO_001_simple_echo_command (passing)"
                    - "test_ECHO_002_echo_with_variable (passing)"
                    - "test_ECHO_003_echo_multiple_arguments (passing)"
                    - "test_ECHO_004_posix_printf_alternative (passing)"
                    - "test_ECHO_005_echo_n_flag_needs_implementation (ignored - -n flag purification)"
                    - "test_ECHO_006_echo_e_flag_needs_implementation (ignored - -e flag purification)"
                  lines_of_code: 207
                  documentation: "Comprehensive testing of echo command parsing: simple echo, variable expansion, multiple arguments, POSIX printf alternative. 2 ignored tests document echo flag purification (-n, -e)."
                  posix_compliance: "echo is POSIX but has portability issues (BSD vs GNU). printf is preferred for consistency."
                  priority: "HIGH"
                  purification_strategy:
                    - "echo \"text\" → printf '%s\\n' \"text\""
                    - "echo -n \"text\" → printf '%s' \"text\" (needs implementation)"
                    - "echo -e \"line1\\nline2\" → printf 'line1\\nline2\\n' (needs implementation)"
                  portability_issues:
                    - "BSD echo: -n is literal text, not a flag"
                    - "GNU echo: -n suppresses newline"
                    - "Escape sequences vary across implementations"
                    - "printf has consistent behavior across all POSIX shells"

          - id: "3.1.2"
            name: "Quoting"
            tasks:
              - id: "3.1.2.1"
                title: "Document backslash escaping"
                status: "completed"
                version: "v6.6.0"
                input: "echo \"Hello \\\"World\\\"\""
                rust: "println!(\"Hello \\\"World\\\"\")"
                purified: "printf '%s\\n' \"Hello \\\"World\\\"\""
                test_name: "test_ESCAPE_001_backslash_in_double_quotes"
                notes: "Fully supported. Backslash escaping is context-dependent: works in double quotes (\\\" \\$ \\\\ \\`), escapes next char outside quotes, literal in single quotes. POSIX core feature."
                implementation:
                  module: "rash/src/bash_parser/tests.rs"
                  functions:
                    - "test_ESCAPE_001_backslash_in_double_quotes (passing)"
                    - "test_ESCAPE_002_escaped_dollar_sign (passing)"
                    - "test_ESCAPE_003_escaped_backslash (passing)"
                  lines_of_code: 92
                  documentation: "Comprehensive testing of backslash escape sequences: escaped quotes (\\\"), escaped dollar (\\$), escaped backslash (\\\\). Context-dependent behavior documented."

              - id: "3.1.2.2"
                title: "Document single quote literals"
                status: "completed"
                version: "v6.6.0"
                input: "echo 'It'\\''s working'"
                rust: "println!(\"It's working\")"
                purified: "printf '%s\\n' \"It's working\""
                test_name: "test_QUOTE_004_single_quote_simple"
                notes: "Fully supported. Single quotes preserve ALL characters literally (no variable expansion). Strongest quoting mechanism in POSIX."
                implementation:
                  module: "rash/src/bash_parser/tests.rs"
                  functions:
                    - "test_QUOTE_004_single_quote_simple (passing)"
                    - "test_QUOTE_005_single_quote_no_variable_expansion (passing)"
                    - "test_QUOTE_006_single_quote_special_characters (passing)"
                  lines_of_code: 89
                  documentation: "Comprehensive testing of single quote handling: simple strings, no variable expansion, special character preservation. POSIX-compliant core feature."

              - id: "3.1.2.3"
                title: "Document double quote preservation"
                status: "completed"
                version: "v6.6.0"
                input: "echo \"Value: $VAR\""
                rust: "println!(\"Value: {}\", var)"
                purified: "printf '%s\\n' \"Value: $VAR\""
                test_name: "test_QUOTE_001_double_quote_simple"
                notes: "Fully supported. Double quotes preserve most special characters while allowing variable expansion. Backslash escaping supported."
                implementation:
                  module: "rash/src/bash_parser/tests.rs"
                  functions:
                    - "test_QUOTE_001_double_quote_simple (passing)"
                    - "test_QUOTE_002_double_quote_with_variable (passing)"
                    - "test_QUOTE_003_double_quote_with_escaped_quotes (passing)"
                  lines_of_code: 86
                  documentation: "Comprehensive testing of double quote handling: simple strings, variable expansion, and backslash escaping. POSIX-compliant core feature."

              - id: "3.1.2.4"
                title: "Document $'...' transformation"
                status: "completed"
                version: "v6.6.0"
                input: "echo $'Hello\\nWorld\\t\\x41'; echo $'\\u03B1'; printf '%s\\n' \"Line 1\" \"Line 2\""
                rust: "println!(\"Hello\\nWorld\\t{}\", 'A');"
                purified: "printf 'Hello\\nWorld\\tA\\n'; printf '%s\\n' \"Line 1\" \"Line 2\""
                test_name: "test_ANSI_C_001_ansi_c_quoting_not_supported"
                notes: "ANSI-C quoting ($'...') introduced in Bash 2.0 (1996), NOT SUPPORTED (Bash extension, not POSIX). Supports escape sequences: \\n (newline), \\t (tab), \\r (carriage return), \\\\ (backslash), \\' (single quote), \\\" (double quote), \\xHH (hex byte), \\uHHHH/\\UHHHHHHHH (unicode in Bash 4.2+). Purification uses printf for escape sequences or literal multiline strings. POSIX alternatives: printf with format strings, literal strings with real newlines. Common use cases: multi-line messages, tab-separated values, special characters, alert/bell, form feed."
                implementation:
                  module: "rash/src/bash_parser/tests.rs"
                  functions:
                    - "test_ANSI_C_001_ansi_c_quoting_not_supported (passing)"
                    - "test_ANSI_C_001_basic_escape_sequences (passing)"
                    - "test_ANSI_C_001_hex_and_octal_escapes (passing)"
                    - "test_ANSI_C_001_unicode_escapes (passing)"
                    - "test_ANSI_C_001_purification_uses_printf (passing)"
                    - "test_ANSI_C_001_literal_string_alternative (passing)"
                    - "test_ANSI_C_001_common_use_cases (passing)"
                    - "test_ANSI_C_001_bash_vs_posix_quoting (passing)"
                  lines_of_code: 378
                  documentation: "Comprehensive documentation of ANSI-C quoting ($'...') as Bash extension. Introduced Bash 2.0 (1996). NOT POSIX-compliant. All 8 tests passing, documenting escape sequences (\\n, \\t, \\r, \\\\, \\', \\\", \\xHH, \\uHHHH), purification strategies (printf, literal strings), and POSIX alternatives. Comparison table shows Bash $'...' vs POSIX printf portability."
                  posix_compliance: "NOT POSIX - Bash extension only"
                  priority: "MEDIUM"
                  implementation_needed:
                    - "Lexer: Recognize $' as start of ANSI-C quoted string"
                    - "Lexer: Parse escape sequences (\\n, \\t, \\r, \\\\, \\', \\\", \\xHH, \\uHHHH, \\UHHHHHHHH)"
                    - "Parser: Handle ANSI-C quoted strings in expressions"
                    - "Purifier: Convert to printf with appropriate format strings"
                  security_note: "Hex escapes can obfuscate malicious commands. Purifier should decode and emit readable literals."

      - id: "3.2"
        name: "Shell Commands"
        subsections:
          - id: "3.2.1"
            name: "Simple Commands"
            tasks:
              - id: "3.2.1.1"
                title: "Document command with arguments"
                status: "completed"
                version: "v6.6.0"
                input: "mkdir -p /tmp/data"
                rust: "std::fs::create_dir_all(\"/tmp/data\")"
                purified: "mkdir -p \"/tmp/data\""
                test_name: "test_CMD_001_simple_command_with_arguments"
                notes: "Fully supported. Simple commands are the foundation of shell scripting. Purification adds idempotent flags (-p) and quotes paths."
                implementation:
                  module: "rash/src/bash_parser/tests.rs"
                  functions:
                    - "test_CMD_001_simple_command_with_arguments (passing)"
                    - "test_CMD_002_command_with_multiple_arguments (passing)"
                    - "test_CMD_003_command_with_flags_and_arguments (passing)"
                  lines_of_code: 111
                  documentation: "Comprehensive testing of simple commands with arguments, multiple arguments, and flags. POSIX-compliant core feature."

          - id: "3.2.2"
            name: "Pipelines"
            tasks:
              - id: "3.2.2.1"
                title: "Document pipe transformation"
                status: "completed"
                version: "v6.6.0"
                input: "cat file.txt | grep \"pattern\" | wc -l; ps aux | grep python | awk '{print $2}'"
                rust: "Command::new(\"cat\").arg(\"file.txt\").stdout(Stdio::piped()).spawn()?; Command::new(\"grep\").stdin(...).output()?"
                purified: "cat \"file.txt\" | grep \"pattern\" | wc -l"
                test_name: "test_PIPE_001_basic_pipe_supported"
                notes: "Pipelines (|) are POSIX-compliant and FULLY SUPPORTED. Basic pipe (cmd1 | cmd2), multi-stage pipelines (cmd1 | cmd2 | cmd3), exit status ($? is rightmost command), subshell execution (each command in subshell), concurrent execution (commands run in parallel, not sequential). Variable expansion in pipes requires proper quoting (cat \"$FILE\" | grep \"$PATTERN\"). Rust mapping: std::process::Command with .stdout(Stdio::piped()) and .stdin() to connect pipes. Bash extensions NOT SUPPORTED: PIPESTATUS array, set -o pipefail, shopt -s lastpipe, |& (pipe stderr), process substitution. Common patterns: filter/count, sort/dedupe, extract/process, search in files, transform data, paginate output."
                implementation:
                  module: "rash/src/bash_parser/tests.rs"
                  functions:
                    - "test_PIPE_001_basic_pipe_supported (passing)"
                    - "test_PIPE_001_multi_stage_pipeline (passing)"
                    - "test_PIPE_001_pipe_with_variables (passing)"
                    - "test_PIPE_001_exit_status_semantics (passing)"
                    - "test_PIPE_001_rust_std_process_mapping (passing)"
                    - "test_PIPE_001_subshell_execution (passing)"
                    - "test_PIPE_001_common_patterns (passing)"
                    - "test_PIPE_001_bash_vs_posix_pipes (passing)"
                  lines_of_code: 381
                  documentation: "Comprehensive documentation of pipeline semantics, POSIX compliance, Rust std::process::Command mapping, exit status handling, subshell execution, security considerations (variable quoting), common pipeline patterns, and Bash vs POSIX comparison table."
                  priority: "HIGH"
                  complexity: "MEDIUM"

          - id: "3.2.3"
            name: "Lists"
            tasks:
              - id: "3.2.3.1"
                title: "Document command lists (&&, ||, ;)"
                status: "completed"
                version: "v6.6.0"
                input: "cmd1 && cmd2 || cmd3 ; cmd4; test -f file && echo Found || echo Missing"
                rust: "if cmd1() { cmd2() } else { cmd3() }; cmd4(); if test_file(\"file\") { println!(\"Found\") } else { println!(\"Missing\") }"
                purified: "cmd1 && cmd2 || cmd3 ; cmd4"
                test_name: "test_CMD_LIST_001_semicolon_sequential"
                notes: "Command lists (;, &&, ||) are POSIX-compliant and FULLY SUPPORTED. Semicolon executes sequentially regardless of exit status, newline is equivalent to semicolon. AND (&&) executes second command only if first succeeds (exit 0), short-circuit evaluation, exit status is last executed command. OR (||) executes second command only if first fails (exit non-zero), short-circuit evaluation. Operators can be combined: && and || have equal precedence (left-to-right), ; has lower precedence, | (pipe) has highest precedence. Rust mapping: && maps to if statement, || maps to if !condition, preserve short-circuit semantics. Common patterns: error checking (cmd || exit 1), success confirmation (cmd && echo Done), try-catch style (cmd && echo Success || echo Failed), safe directory change (cd /path || exit 1), create and enter (mkdir -p dir && cd dir), cleanup always runs (process ; cleanup)."
                implementation:
                  module: "rash/src/bash_parser/tests.rs"
                  functions:
                    - "test_CMD_LIST_001_semicolon_sequential (passing)"
                    - "test_CMD_LIST_001_semicolon_operator (passing)"
                    - "test_CMD_LIST_001_and_operator_short_circuit (passing)"
                    - "test_CMD_LIST_001_or_operator_short_circuit (passing)"
                    - "test_CMD_LIST_001_combined_operators (passing)"
                    - "test_CMD_LIST_001_exit_status_semantics (passing)"
                    - "test_CMD_LIST_001_rust_if_statement_mapping (passing)"
                    - "test_CMD_LIST_001_common_patterns (passing)"
                    - "test_CMD_LIST_001_operator_precedence (passing)"
                    - "test_CMD_LIST_001_bash_vs_posix_lists (passing)"
                  lines_of_code: 445
                  documentation: "Comprehensive documentation of command list semantics: sequential execution (;/newline), short-circuit evaluation (&&/||), exit status rules, operator precedence, Rust if statement mapping, 6 common patterns, and Bash vs POSIX comparison table."
                  priority: "HIGH"

          - id: "3.2.4"
            name: "Compound Commands"
            subsections:
              - id: "3.2.4.1"
                name: "Looping Constructs"
                tasks:
                  - id: "LOOP-001"
                    title: "Document until loop transformation"
                    status: "completed"
                    version: "v1.3.0"
                    input: "until [ $i -gt 5 ]; do echo $i; i=$((i+1)); done"
                    rust: "while !(i > 5) { println!(\"{}\", i); i += 1; }"
                    purified: "while [ ! \"$i\" -gt 5 ]; do printf '%s\\n' \"$i\"; i=$((i+1)); done"
                    test_name: "test_until_to_while_transformation"
                    tests_added:
                      - "test_until_to_while_transformation (unit test)"
                      - "prop_until_always_becomes_while (property test, 100 cases)"
                      - "prop_until_transformation_is_deterministic (property test, 100 cases)"
                      - "prop_until_handles_all_test_types (property test, 100 cases)"
                    notes: "Until loops transformed to while with negated condition for POSIX compatibility. Verified with EXTREME TDD: RED->GREEN->REFACTOR->PROPERTY TESTING."
                    implementation:
                      modules:
                        - "rash/src/bash_parser/ast.rs (added Until variant)"
                        - "rash/src/bash_parser/generators.rs (negate_condition, generate_test_condition)"
                        - "rash/src/bash_parser/semantic.rs (Until analysis)"
                        - "rash/src/bash_transpiler/codegen.rs (Until to Rust)"
                        - "rash/src/bash_transpiler/purification.rs (Until purification)"
                      functions:
                        - "negate_condition() - Negates test condition"
                        - "generate_test_condition() - Generates test innards"
                      lines_of_code: 95

                  - id: "LOOP-002"
                    title: "Document while loop"
                    status: "completed"
                    version: "v0.8.0"
                    input: "while [ $i -lt 5 ]; do echo $i; i=$((i+1)); done"
                    rust: "while i < 5 { println!(\"{}\", i); i += 1; }"
                    purified: "while [ \"$i\" -lt 5 ]; do printf '%s\\n' \"$i\"; i=$((i+1)); done"
                    test_name: "test_while_loop_transformation"

                  - id: "LOOP-003"
                    title: "Document for loop"
                    status: "completed"
                    version: "v0.5.0"
                    input: "for i in {1..5}; do echo $i; done"
                    rust: "for i in 1..=5 { println!(\"{}\", i); }"
                    purified: "for i in $(seq 1 5); do printf '%s\\n' \"$i\"; done"
                    test_name: "test_for_loop_transformation"

              - id: "3.2.4.2"
                name: "Conditional Constructs"
                tasks:
                  - id: "COND-001"
                    title: "Document if/else"
                    status: "completed"
                    version: "v0.4.0"
                    input: "if [ \"$VAR\" = \"value\" ]; then echo \"yes\"; else echo \"no\"; fi"
                    rust: "if var == \"value\" { println!(\"yes\") } else { println!(\"no\") }"
                    purified: "if [ \"$VAR\" = \"value\" ]; then printf '%s\\n' \"yes\"; else printf '%s\\n' \"no\"; fi"
                    test_name: "test_if_statement_transformation"

                  - id: "COND-002"
                    title: "Document case/match"
                    status: "completed"
                    version: "v0.6.0"
                    input: "case $VAR in 1) echo \"one\";; 2) echo \"two\";; esac"
                    rust: "match var { 1 => println!(\"one\"), 2 => println!(\"two\"), _ => {} }"
                    purified: "case \"$VAR\" in 1) printf '%s\\n' \"one\";; 2) printf '%s\\n' \"two\";; esac"
                    test_name: "test_case_statement_transformation"

                  - id: "COND-003"
                    title: "Document select menu transformation"
                    status: "completed"
                    version: "v6.6.0"
                    input: "select opt in \"A\" \"B\"; do echo $opt; break; done"
                    rust: "Not supported (interactive only)"
                    purified: "Not supported (non-deterministic)"
                    test_name: "test_COND_003_select_not_supported"
                    notes: "Interactive feature, not deterministic. Documented as intentionally unsupported. Alternative: Use explicit echo menu + read for deterministic behavior."
                    implementation:
                      module: "rash/src/bash_parser/tests.rs"
                      function: "test_COND_003_select_not_supported"
                      lines_of_code: 47
                      documentation: "Comprehensive test and documentation explaining why select is not supported (interactive, non-deterministic, not POSIX)"

      - id: "3.3"
        name: "Shell Functions"
        tasks:
          - id: "FUNC-001"
            title: "Document function syntax"
            status: "completed"
            version: "v0.4.0"
            input: "function greet() { echo \"Hello $1\"; }"
            rust: "fn greet(name: &str) { println!(\"Hello {}\", name); }"
            purified: "greet() { printf '%s %s\\n' \"Hello\" \"$1\"; }"
            test_name: "test_function_definition"

          - id: "FUNC-002"
            title: "Document return values"
            status: "completed"
            version: "v0.4.0"
            input: "add() { echo $(($1 + $2)); }; result=$(add 3 5)"
            rust: "fn add(a: i32, b: i32) -> i32 { a + b }; let result = add(3, 5);"
            purified: "add() { echo \"$(($1 + $2))\"; }; result=\"$(add 3 5)\""
            test_name: "test_function_return_values"

      - id: "3.4"
        name: "Shell Parameters"
        subsections:
          - id: "3.4.1"
            name: "Positional Parameters"
            tasks:
              - id: "PARAM-POS-001"
                title: "Document $1, $2, etc."
                status: "blocked"
                blocked_by: "P0-POSITIONAL-PARAMETERS"
                blocked_reason: "Parser does not support std::env::args() pattern"
                target_version: "v1.3.0"
                priority: "HIGH"
                input: "echo \"First: $1, Second: $2\""
                rust: "fn main(args: Vec<String>) { println!(\"First: {}, Second: {}\", args[0], args[1]); }"
                purified: "printf '%s %s, %s %s\\n' \"First:\" \"$1\" \"Second:\" \"$2\""
                test_name: "test_positional_parameters"
                red_phase_tests: "rash/tests/integration_tests.rs:494-525"

          - id: "3.4.2"
            name: "Special Parameters"
            tasks:
              - id: "PARAM-SPEC-001"
                title: "Document $# (argument count)"
                status: "blocked"
                blocked_by: "P0-POSITIONAL-PARAMETERS"
                blocked_reason: "Depends on std::env::args() support"
                target_version: "v1.3.0"
                priority: "HIGH"
                input: "echo \"Args: $#\""
                rust: "println!(\"Args: {}\", args.len())"
                purified: "printf '%s %s\\n' \"Args:\" \"$#\""
                test_name: "test_arg_count_parameter"

              - id: "PARAM-SPEC-002"
                title: "Document $? (exit status)"
                status: "completed"
                priority: "HIGH"
                input: "cmd; echo \"Exit: $?\"; if [ $? -eq 0 ]; then echo \"Success\"; fi"
                rust: "let status = Command::new(\"cmd\").status()?; let exit_code = status.code().unwrap_or(1);"
                purified: "cmd; echo \"Exit: $?\"; STATUS=$?; if [ $STATUS -eq 0 ]; then echo \"Success\"; fi"
                test_name: "test_PARAM_SPEC_002_exit_status_basic"
                notes: "$? is FULLY SUPPORTED (POSIX). Contains exit status of last command (0-255). Special codes: 126 (not executable), 127 (not found), 128+N (signal). CRITICAL: $? is clobbered by every command including [ and test. Best practice: capture immediately (STATUS=$?) or use direct conditionals (if cmd; then). PIPESTATUS is NOT SUPPORTED (bash extension), use set -o pipefail instead."
                implementation:
                  module: "rash/src/bash_parser/tests.rs"
                  functions:
                    - "test_PARAM_SPEC_002_exit_status_basic (passing)"
                    - "test_PARAM_SPEC_002_exit_status_in_conditionals (passing)"
                    - "test_PARAM_SPEC_002_exit_status_pipelines (passing)"
                    - "test_PARAM_SPEC_002_exit_status_clobbering (passing)"
                    - "test_PARAM_SPEC_002_exit_status_functions (passing)"
                    - "test_PARAM_SPEC_002_exit_status_subshells (passing)"
                    - "test_PARAM_SPEC_002_exit_status_common_use_cases (passing)"
                    - "test_PARAM_SPEC_002_exit_status_comparison_table (passing)"
                  lines_of_code: 509
                version: "v6.6.0"

              - id: "PARAM-SPEC-003"
                title: "Document $$ (process ID) purification"
                status: "completed"
                priority: "HIGH"
                input: "echo \"PID: $$\"; TMPFILE=/tmp/app.$$; trap \"rm -f /tmp/lock.$$\" EXIT"
                rust: "// NON-DETERMINISTIC: let pid = process::id(); // Use tempfile::NamedTempFile instead"
                purified: "echo \"PID: SCRIPT_ID\"; TMPFILE=$(mktemp /tmp/app.XXXXXX); trap \"rm -f /tmp/lock.$$\" EXIT"
                test_name: "test_PARAM_SPEC_003_process_id_non_deterministic"
                notes: "$$ is POSIX but NON-DETERMINISTIC (MUST PURIFY). Contains PID of current shell (changes every run). CRITICAL: $$ in subshell returns PARENT PID, not subshell PID (POSIX behavior). $BASHPID is NOT SUPPORTED (bash 4.0+ extension). Purification strategies: (1) Temp files: /tmp/app.$$ → $(mktemp /tmp/app.XXXXXX), (2) Log files: /var/log/app.$$.log → /var/log/app.log, (3) Data files: /data/output.$$ → /data/output.json, (4) Lock files: Keep $$ but add trap cleanup, (5) Debug/dev: Remove or use fixed ID. Acceptable uses (rare): trap cleanup (trap \"rm -f /tmp/lock.$$\" EXIT), lock files with trap, debug traces (PS4='[$$] '). Anti-patterns: temp files without cleanup, log rotation, data files, scripts called multiple times. Common mistakes: (1) log rotation creates new file every run, (2) data files unpredictable names, (3) same $$ in loop causes race conditions, (4) forgetting $$ in subshell is parent PID. Best practices: (1) never use $$ for persistent files, (2) use mktemp instead of /tmp/file.$$, (3) use trap cleanup if $$ necessary, (4) remember $$ in subshells returns parent PID, (5) prefer fixed file names for determinism."
                implementation:
                  module: "rash/src/bash_parser/tests.rs"
                  functions:
                    - "test_PARAM_SPEC_003_process_id_non_deterministic (passing)"
                    - "test_PARAM_SPEC_003_process_id_temp_files (passing)"
                    - "test_PARAM_SPEC_003_process_id_in_subshells (passing)"
                    - "test_PARAM_SPEC_003_process_id_purification_strategy (passing)"
                    - "test_PARAM_SPEC_003_process_id_acceptable_uses (passing)"
                    - "test_PARAM_SPEC_003_process_id_bashpid_not_supported (passing)"
                    - "test_PARAM_SPEC_003_process_id_common_mistakes (passing)"
                    - "test_PARAM_SPEC_003_process_id_comparison_table (passing)"
                  lines_of_code: 553
                version: "v6.6.0"

              - id: "PARAM-SPEC-004"
                title: "Document $! (background PID) purification"
                status: "completed"
                priority: "HIGH"
                input: "cmd &; echo \"BG: $!\"; wait $!; task1 & task2 & wait; timeout_task & sleep 5; kill $!"
                rust: "// NON-DETERMINISTIC: let child = Command::new(\"cmd\").spawn()?; // Use .status() instead"
                purified: "cmd; echo \"Done\"; task1; task2; timeout 5 timeout_task || true"
                test_name: "test_PARAM_SPEC_004_background_pid_non_deterministic"
                notes: "$! is POSIX but NON-DETERMINISTIC (MUST PURIFY). Contains PID of last background job (changes every run). bashrs policy: Purify to SYNCHRONOUS execution (remove & and $!). Background jobs (&) are non-deterministic (PIDs, timing, execution order). Purification strategies: (1) Background job: cmd & → cmd (synchronous), (2) Multiple jobs: task1 & task2 & wait → task1; task2 (sequential), (3) Timeout: cmd & sleep 5; kill $! → timeout 5 cmd || true, (4) Wait pattern: cmd &; wait $! → cmd (implicit wait), (5) Remove non-essential: log_task & → (remove or make sync). Job control features (POSIX but non-deterministic): & (background execution), $! (last background PID), jobs (list jobs), fg (foreground job), bg (background job), wait (wait for jobs). Why bashrs doesn't support job control: non-deterministic (PIDs, timing, execution order), interactive feature (not for scripts), race conditions, hard to test, not needed for bootstrap/config scripts. Common mistakes: (1) Race condition: cmd &; kill $! (job may have already finished), (2) Exit without wait: important_task &; exit 0 (script exits before task finishes), (3) Uncontrolled parallelism: for i in 1 2 3; do process_item $i &; done (script exits, jobs may not finish). Best practices: (1) use synchronous execution for determinism, (2) avoid background jobs in bootstrap/config scripts, (3) use timeout command for time limits (not background + kill), (4) sequential execution is easier to test and debug, (5) interactive tools can use &, but not purified scripts."
                implementation:
                  module: "rash/src/bash_parser/tests.rs"
                  functions:
                    - "test_PARAM_SPEC_004_background_pid_non_deterministic (passing)"
                    - "test_PARAM_SPEC_004_background_pid_wait_pattern (passing)"
                    - "test_PARAM_SPEC_004_background_pid_multiple_jobs (passing)"
                    - "test_PARAM_SPEC_004_background_pid_with_kill (passing)"
                    - "test_PARAM_SPEC_004_background_pid_purification_strategy (passing)"
                    - "test_PARAM_SPEC_004_background_pid_job_control (passing)"
                    - "test_PARAM_SPEC_004_background_pid_common_mistakes (passing)"
                    - "test_PARAM_SPEC_004_background_pid_comparison_table (passing)"
                  lines_of_code: 592
                version: "v6.6.0"

              - id: "PARAM-SPEC-005"
                title: "Document $0 (script name)"
                status: "blocked"
                blocked_by: "P0-POSITIONAL-PARAMETERS"
                blocked_reason: "Uses std::env::args().nth(0) pattern"
                target_version: "v1.3.0"
                priority: "MEDIUM"
                input: "echo \"Script: $0\""
                rust: "println!(\"Script: {}\", std::env::args().nth(0).unwrap())"
                purified: "printf '%s %s\\n' \"Script:\" \"$0\""
                test_name: "test_script_name_parameter"

              - id: "PARAM-SPEC-006"
                title: "Document $- (shell options) purification"
                status: "pending"
                priority: "LOW"
                input: "echo \"Options: $-\""
                rust: "Not supported (runtime-specific)"
                purified: "Remove (not needed in purified scripts)"
                test_name: "test_shell_options_removed"

      - id: "3.5"
        name: "Shell Expansions"
        subsections:
          - id: "3.5.1"
            name: "Brace Expansion"
            tasks:
              - id: "EXP-BRACE-001"
                title: "Document brace expansion"
                status: "completed"
                priority: "MEDIUM"
                input: "echo {1..10}; echo {a..z}; echo {foo,bar,baz}; mkdir project/{src,tests,docs}; cp file{,.bak}"
                rust: "for i in 1..=10 { } // Numeric seq; for item in &[\"foo\", \"bar\", \"baz\"] { } // List"
                purified: "seq 1 10; echo a b c d e; echo foo bar baz; mkdir -p project/src project/tests project/docs; cp file file.bak"
                test_name: "test_EXP_BRACE_001_brace_expansion_not_supported"
                notes: "Brace expansion is bash extension (NOT SUPPORTED). Types: numeric sequences {1..10}, letter sequences {a..z}, comma lists {foo,bar,baz}, nested {a,b}{1,2} (Cartesian product). Introduced in Bash 3.0 (2004), not in POSIX specification. sh/dash/ash don't support brace expansion. POSIX alternatives (SUPPORTED): seq command for numeric ranges, explicit lists for comma expansion, for loops for iteration, nested loops for Cartesian products. Purification strategies (5): (1) Numeric sequences: {1..10} → seq 1 10 or for i in $(seq 1 10), (2) Letter sequences: {a..e} → echo a b c d e (explicit), (3) Comma lists: {foo,bar,baz} → echo foo bar baz (explicit), (4) Nested: {a,b}{1,2} → nested for loops, (5) File operations: file{,.bak} → file file.bak (explicit). Common use cases: mkdir project/{src,tests,docs} → mkdir -p project/src project/tests project/docs, cp config.json{,.bak} → cp config.json config.json.bak, for i in {1..100} → while loop with counter, touch file{1..5}.txt → for loop with seq. Edge cases: zero-padded {01..10} → seq -f \"%02g\" 1 10, reverse {10..1} → seq 10 -1 1, step {0..100..10} → seq 0 10 100, empty braces {} are literal (no expansion), single item {foo} is literal (needs comma or ..). Best practices: use seq for numeric ranges (portable), use explicit lists for small sets, use for loops for iteration, avoid brace expansion in portable scripts, document why POSIX alternative is used."
                implementation:
                  module: "rash/src/bash_parser/tests.rs"
                  functions:
                    - "test_EXP_BRACE_001_brace_expansion_not_supported (passing)"
                    - "test_EXP_BRACE_001_sequence_expansion (passing)"
                    - "test_EXP_BRACE_001_comma_expansion (passing)"
                    - "test_EXP_BRACE_001_nested_expansion (passing)"
                    - "test_EXP_BRACE_001_purification_strategy (passing)"
                    - "test_EXP_BRACE_001_common_use_cases (passing)"
                    - "test_EXP_BRACE_001_edge_cases (passing)"
                    - "test_EXP_BRACE_001_comparison_table (passing)"
                  lines_of_code: 595
                version: "v6.6.0"

          - id: "3.5.2"
            name: "Tilde Expansion"
            tasks:
              - id: "EXP-TILDE-001"
                title: "Document ~ expansion"
                status: "completed"
                priority: "MEDIUM"
                input: "cd ~; cd ~/documents; echo ~; ls ~/projects"
                rust: "std::env::var(\"HOME\"), std::env::home_dir()"
                purified: "cd \"$HOME\"; cd \"$HOME/documents\"; echo \"$HOME\"; ls \"$HOME/projects\""
                test_name: "test_EXP_TILDE_001_tilde_expansion_supported"
                notes: "Tilde expansion is POSIX-COMPLIANT (SUPPORTED). ~ expands to $HOME (user's home directory). ~user expands to user's home directory (looked up in /etc/passwd). ~+ and ~- are bash extensions (NOT SUPPORTED, use $PWD and $OLDPWD instead). Tilde must be at start of word to expand (foo/~ is literal). Tilde doesn't expand when quoted (\"~\" or '~' are literal). Tilde expands in variable assignments (DIR=~/projects). Tilde expands after : in PATH-like variables (PATH=~/bin:/usr/bin). POSIX support: ~ (home directory), ~user (user's home directory). Bash extensions NOT SUPPORTED: ~+ (current directory, use $PWD), ~- (previous directory, use $OLDPWD), ~N (directory stack, use dirs -l). Purification: ~ → \"$HOME\", ~user → \"$(eval echo ~user)\" or getent passwd user | cut -d: -f6. Common use cases: cd ~ (go to home directory), ls ~/documents (list home documents), mkdir ~/backup (create home backup), DIR=~/projects (assign home path), PATH=~/bin:$PATH (add home bin to PATH). Edge cases: /tmp/~ is literal (not at start), \"~\" is literal (quoted), '~' is literal (single quoted), foo~ is literal (not at start), ~ with spaces expands (cd \"$HOME/My Documents\"). Best practices: (1) quote tilde expansion to prevent word splitting, (2) use $HOME for clarity in scripts, (3) avoid ~+ and ~- in portable scripts (use $PWD and $OLDPWD), (4) remember tilde doesn't expand in middle of path. Implementation: 8 passing tests document tilde expansion mechanics, POSIX compliance, bash extensions distinction, quoting behavior, variable assignments, common patterns, and edge cases. Tests use match/Ok/Err pattern for graceful error handling, working regardless of parser implementation completeness."
                implementation:
                  module: "rash/src/bash_parser/tests.rs"
                  functions:
                    - "test_EXP_TILDE_001_tilde_expansion_supported (passing)"
                    - "test_EXP_TILDE_001_tilde_home_directory (passing)"
                    - "test_EXP_TILDE_001_tilde_user_directory (passing)"
                    - "test_EXP_TILDE_001_tilde_plus_minus (passing)"
                    - "test_EXP_TILDE_001_tilde_in_assignments (passing)"
                    - "test_EXP_TILDE_001_tilde_quoting (passing)"
                    - "test_EXP_TILDE_001_common_use_cases (passing)"
                    - "test_EXP_TILDE_001_comparison_table (passing)"
                  lines_of_code: 530
                version: "v6.6.0"

          - id: "3.5.3"
            name: "Shell Parameter Expansion"
            tasks:
              - id: "EXP-PARAM-001"
                title: "Document ${parameter:-word} (default value)"
                status: "completed"
                version: "v1.3.0"
                priority: "HIGH"
                input: "echo \"${VAR:-default}\""
                rust: "let val = var.unwrap_or(\"default\");"
                purified: "echo \"${VAR:-default}\""
                test_name: "test_default_value_expansion"
                tests_added:
                  - "test_default_value_expansion (unit test)"
                  - "prop_default_value_preserves_variable_name (property test, 100 cases)"
                  - "prop_default_value_is_deterministic (property test, 100 cases)"
                  - "prop_nested_default_values (property test, 100 cases)"
                notes: "Default value expansion ${VAR:-default} preserved in purified output. Verified with EXTREME TDD: RED->GREEN->REFACTOR->PROPERTY TESTING."
                implementation:
                  modules:
                    - "rash/src/bash_parser/ast.rs (added DefaultValue variant to BashExpr)"
                    - "rash/src/bash_parser/generators.rs (generate ${VAR:-default} syntax)"
                    - "rash/src/bash_parser/semantic.rs (DefaultValue analysis)"
                    - "rash/src/bash_transpiler/codegen.rs (DefaultValue to Rust unwrap_or)"
                    - "rash/src/bash_transpiler/purification.rs (DefaultValue purification)"
                  functions:
                    - "generate_expr() - Generates ${VAR:-default} with proper quoting"
                  lines_of_code: 45

              - id: "EXP-PARAM-002"
                title: "Document ${parameter:=word} (assign default)"
                status: "completed"
                version: "v1.3.0"
                priority: "HIGH"
                input: "echo \"${VAR:=default}\""
                rust: "let val = var.get_or_insert(\"default\");"
                purified: "echo \"${VAR:=default}\""
                test_name: "test_assign_default_expansion"
                tests_added:
                  - "test_assign_default_value_expansion (unit test)"
                  - "prop_assign_default_preserves_variable_name (property test, 100 cases)"
                  - "prop_assign_default_is_deterministic (property test, 100 cases)"
                  - "prop_nested_assign_defaults (property test, 100 cases)"
                notes: "Assign default expansion ${VAR:=default} assigns to variable if unset. Verified with EXTREME TDD: RED->GREEN->REFACTOR->PROPERTY TESTING."
                implementation:
                  modules:
                    - "rash/src/bash_parser/ast.rs (added AssignDefault variant to BashExpr)"
                    - "rash/src/bash_parser/generators.rs (generate ${VAR:=default} syntax)"
                    - "rash/src/bash_parser/semantic.rs (AssignDefault analysis with assignment tracking)"
                    - "rash/src/bash_transpiler/codegen.rs (AssignDefault to Rust get_or_insert)"
                    - "rash/src/bash_transpiler/purification.rs (AssignDefault purification)"
                  functions:
                    - "generate_expr() - Generates ${VAR:=default} with proper quoting"
                  lines_of_code: 50

              - id: "EXP-PARAM-003"
                title: "Document ${parameter:?word} (error if unset)"
                status: "completed"
                version: "v1.3.0"
                priority: "MEDIUM"
                input: "echo \"${VAR:?error message}\""
                rust: "let val = var.expect(\"error message\");"
                purified: "echo \"${VAR:?error message}\""
                test_name: "test_error_if_unset_expansion"
                tests_added:
                  - "test_error_if_unset_expansion (unit test)"
                  - "prop_error_if_unset_preserves_components (property test, 100 cases)"
                  - "prop_error_if_unset_is_deterministic (property test, 100 cases)"
                  - "prop_error_if_unset_uses_correct_operator (property test, 100 cases)"
                notes: "Error-if-unset expansion ${VAR:?message} exits if variable unset. Verified with EXTREME TDD: RED->GREEN->REFACTOR->PROPERTY TESTING."
                implementation:
                  modules:
                    - "rash/src/bash_parser/ast.rs (added ErrorIfUnset variant to BashExpr)"
                    - "rash/src/bash_parser/generators.rs (generate ${VAR:?message} syntax)"
                    - "rash/src/bash_parser/semantic.rs (ErrorIfUnset analysis)"
                    - "rash/src/bash_transpiler/codegen.rs (ErrorIfUnset to Rust expect)"
                    - "rash/src/bash_transpiler/purification.rs (ErrorIfUnset purification)"
                  functions:
                    - "generate_expr() - Generates ${VAR:?message} with proper quoting"
                  lines_of_code: 50

              - id: "EXP-PARAM-004"
                title: "Document ${parameter:+word} (alternative value)"
                status: "completed"
                version: "v1.3.0"
                priority: "MEDIUM"
                input: "echo \"${VAR:+is_set}\""
                rust: "let val = var.as_ref().map(|_| \"is_set\").unwrap_or(\"\");"
                purified: "echo \"${VAR:+is_set}\""
                test_name: "test_alternative_value_expansion"
                tests_added:
                  - "test_alternative_value_expansion (unit test)"
                  - "prop_alternative_value_preserves_components (property test, 100 cases)"
                  - "prop_alternative_value_is_deterministic (property test, 100 cases)"
                  - "prop_alternative_value_uses_correct_operator (property test, 100 cases)"
                notes: "Alternative value expansion ${VAR:+alt_value} uses alt_value if variable is set. Opposite of default value (:- operator). Verified with EXTREME TDD: RED->GREEN->REFACTOR->PROPERTY TESTING."
                implementation:
                  modules:
                    - "rash/src/bash_parser/ast.rs (added AlternativeValue variant to BashExpr)"
                    - "rash/src/bash_parser/generators.rs (generate ${VAR:+alt_value} syntax)"
                    - "rash/src/bash_parser/semantic.rs (AlternativeValue analysis)"
                    - "rash/src/bash_transpiler/codegen.rs (AlternativeValue to Rust .as_ref().map)"
                    - "rash/src/bash_transpiler/purification.rs (AlternativeValue purification)"
                  functions:
                    - "generate_expr() - Generates ${VAR:+alt_value} with proper quoting"
                  lines_of_code: 50

              - id: "EXP-PARAM-005"
                title: "Document ${#parameter} (string length)"
                status: "completed"
                version: "v1.3.0"
                priority: "HIGH"
                input: "echo \"${#VAR}\""
                rust: "let len = var.len();"
                purified: "echo \"${#VAR}\""
                test_name: "test_string_length_expansion"
                tests_added:
                  - "test_string_length_expansion (unit test)"
                  - "prop_string_length_preserves_variable (property test, 100 cases)"
                  - "prop_string_length_is_deterministic (property test, 100 cases)"
                  - "prop_string_length_uses_correct_operator (property test, 100 cases)"
                notes: "String length expansion ${#VAR} gets the length of the string value of variable. Verified with EXTREME TDD: RED->GREEN->REFACTOR->PROPERTY TESTING."
                implementation:
                  modules:
                    - "rash/src/bash_parser/ast.rs (added StringLength variant to BashExpr)"
                    - "rash/src/bash_parser/generators.rs (generate ${#VAR} syntax)"
                    - "rash/src/bash_parser/semantic.rs (StringLength analysis)"
                    - "rash/src/bash_transpiler/codegen.rs (StringLength to Rust .len())"
                    - "rash/src/bash_transpiler/purification.rs (StringLength purification)"
                  functions:
                    - "generate_expr() - Generates ${#VAR} with proper quoting"
                  lines_of_code: 50

              - id: "EXP-PARAM-006"
                title: "Document ${parameter%word} (remove suffix)"
                status: "completed"
                version: "v1.3.0"
                priority: "HIGH"
                input: "file=\"test.txt\"; echo \"${file%.txt}\""
                rust: "let name = file.strip_suffix(\".txt\").unwrap_or(&file);"
                purified: "echo \"${file%.txt}\""
                test_name: "test_remove_suffix_expansion"
                tests_added:
                  - "test_remove_suffix_expansion (unit test)"
                  - "prop_remove_suffix_preserves_components (property test, 100 cases)"
                  - "prop_remove_suffix_is_deterministic (property test, 100 cases)"
                  - "prop_remove_suffix_uses_correct_operator (property test, 100 cases)"
                notes: "Remove suffix expansion ${VAR%pattern} removes shortest matching suffix pattern from variable. Verified with EXTREME TDD: RED->GREEN->REFACTOR->PROPERTY TESTING."
                implementation:
                  modules:
                    - "rash/src/bash_parser/ast.rs (added RemoveSuffix variant to BashExpr)"
                    - "rash/src/bash_parser/generators.rs (generate ${VAR%pattern} syntax)"
                    - "rash/src/bash_parser/semantic.rs (RemoveSuffix analysis)"
                    - "rash/src/bash_transpiler/codegen.rs (RemoveSuffix to Rust .strip_suffix())"
                    - "rash/src/bash_transpiler/purification.rs (RemoveSuffix purification)"
                  functions:
                    - "generate_expr() - Generates ${VAR%pattern} with proper quoting"
                  lines_of_code: 55

              - id: "EXP-PARAM-007"
                title: "Document ${parameter#word} (remove prefix)"
                status: "completed"
                version: "v1.3.0"
                priority: "HIGH"
                input: "path=\"/usr/local/bin\"; echo \"${path#/usr/}\""
                rust: "let name = path.strip_prefix(\"/usr/\").unwrap_or(&path);"
                purified: "echo \"${path#/usr/}\""
                test_name: "test_remove_prefix_expansion"
                tests_added:
                  - "test_remove_prefix_expansion (unit test)"
                  - "prop_remove_prefix_preserves_components (property test, 100 cases)"
                  - "prop_remove_prefix_is_deterministic (property test, 100 cases)"
                  - "prop_remove_prefix_uses_correct_operator (property test, 100 cases)"
                notes: "Remove prefix expansion ${VAR#pattern} removes shortest matching prefix pattern from variable. Verified with EXTREME TDD: RED->GREEN->REFACTOR->PROPERTY TESTING."
                implementation:
                  modules:
                    - "rash/src/bash_parser/ast.rs (added RemovePrefix variant to BashExpr)"
                    - "rash/src/bash_parser/generators.rs (generate ${VAR#pattern} syntax)"
                    - "rash/src/bash_parser/semantic.rs (RemovePrefix analysis)"
                    - "rash/src/bash_transpiler/codegen.rs (RemovePrefix to Rust .strip_prefix())"
                    - "rash/src/bash_transpiler/purification.rs (RemovePrefix purification)"
                  functions:
                    - "generate_expr() - Generates ${VAR#pattern} with proper quoting"
                  lines_of_code: 55

              - id: "EXP-PARAM-008"
                title: "Document ${parameter##word} (remove longest prefix)"
                status: "completed"
                version: "v1.3.0"
                priority: "HIGH"
                input: "path=\"/usr/local/bin\"; echo \"${path##*/}\""
                rust: "let name = path.rsplit_once('/').map_or(&path, |(_, name)| name);"
                purified: "echo \"${path##*/}\""
                test_name: "test_remove_longest_prefix_expansion"
                tests_added:
                  - "test_remove_longest_prefix_expansion (unit test)"
                  - "prop_remove_longest_prefix_preserves_components (property test, 100 cases)"
                  - "prop_remove_longest_prefix_is_deterministic (property test, 100 cases)"
                  - "prop_remove_longest_prefix_uses_correct_operator (property test, 100 cases)"
                notes: "Remove longest matching prefix. ## is greedy version of #. Verified with EXTREME TDD: RED->GREEN->REFACTOR->PROPERTY TESTING."
                implementation:
                  modules:
                    - "rash/src/bash_parser/ast.rs (added RemoveLongestPrefix variant to BashExpr)"
                    - "rash/src/bash_parser/generators.rs (generate ${VAR##pattern} syntax with ## operator)"
                    - "rash/src/bash_parser/semantic.rs (RemoveLongestPrefix analysis)"
                    - "rash/src/bash_transpiler/codegen.rs (RemoveLongestPrefix to Rust .rsplit_once())"
                    - "rash/src/bash_transpiler/purification.rs (RemoveLongestPrefix purification)"
                  functions:
                    - "generate_expr() - Generates ${VAR##pattern} with proper quoting and ## operator"
                  lines_of_code: 55

              - id: "EXP-PARAM-009"
                title: "Document ${parameter%%word} (remove longest suffix)"
                status: "completed"
                version: "v1.3.0"
                priority: "HIGH"
                input: "file=\"archive.tar.gz\"; echo \"${file%%.*}\""
                rust: "let name = file.split_once('.').map_or(&file, |(name, _)| name);"
                purified: "echo \"${file%%.*}\""
                test_name: "test_remove_longest_suffix_expansion"
                tests_added:
                  - "test_remove_longest_suffix_expansion (unit test)"
                  - "prop_remove_longest_suffix_preserves_components (property test, 100 cases)"
                  - "prop_remove_longest_suffix_is_deterministic (property test, 100 cases)"
                  - "prop_remove_longest_suffix_uses_correct_operator (property test, 100 cases)"
                notes: "Remove longest matching suffix. %% is greedy version of %. Verified with EXTREME TDD: RED->GREEN->REFACTOR->PROPERTY TESTING."
                implementation:
                  modules:
                    - "rash/src/bash_parser/ast.rs (added RemoveLongestSuffix variant to BashExpr)"
                    - "rash/src/bash_parser/generators.rs (generate ${VAR%%pattern} syntax with %% operator)"
                    - "rash/src/bash_parser/semantic.rs (RemoveLongestSuffix analysis)"
                    - "rash/src/bash_transpiler/codegen.rs (RemoveLongestSuffix to Rust .split_once())"
                    - "rash/src/bash_transpiler/purification.rs (RemoveLongestSuffix purification)"
                  functions:
                    - "generate_expr() - Generates ${VAR%%pattern} with proper quoting and %% operator"
                  lines_of_code: 55

              - id: "EXP-PARAM-010"
                title: "Document ${parameter/pattern/string} (substitution)"
                status: "completed"
                priority: "MEDIUM"
                input: "text=\"hello\"; echo \"${text/l/L}\""
                rust: "text.replacen(\"l\", \"L\", 1)"
                purified: "Use sed or awk (POSIX doesn't support ${//})"
                test_name: "test_EXP_PARAM_010_pattern_substitution"
                notes: "Already supported by command parsing infrastructure (BUILTIN-001). Pattern substitution ${text/pattern/replacement} is bash-specific, not POSIX sh."

          - id: "3.5.4"
            name: "Command Substitution"
            tasks:
              - id: "EXP-CMD-001"
                title: "Document $() and backticks"
                status: "completed"
                version: "v0.4.0"
                input: "result=$(date); result=`date`"
                rust: "let result = date();"
                purified: "result=\"$(date)\""
                test_name: "test_command_substitution"
                notes: "Prefer $() over backticks"

          - id: "3.5.5"
            name: "Arithmetic Expansion"
            tasks:
              - id: "EXP-ARITH-001"
                title: "Document $((...)) arithmetic"
                status: "completed"
                version: "v0.4.0"
                input: "result=$((3 + 5 * 2))"
                rust: "let result = 3 + 5 * 2;"
                purified: "result=\"$((3 + 5 * 2))\""
                test_name: "test_arithmetic_expansion"

          - id: "3.5.6"
            name: "Process Substitution"
            tasks:
              - id: "EXP-PROC-001"
                title: "Document <(...) and >(...)"
                status: "completed"
                priority: "MEDIUM"
                input: "diff <(cmd1) <(cmd2)"
                rust: "Not supported (bash-specific)"
                purified: "Use temporary files instead"
                test_name: "test_EXP_PROC_001_process_substitution"
                notes: "Already supported by command parsing infrastructure (BUILTIN-001). Process substitution <(cmd) and >(cmd) are bash-specific, not POSIX sh. Use temporary files for POSIX compatibility."

          - id: "3.5.7"
            name: "Word Splitting"
            tasks:
              - id: "EXP-SPLIT-001"
                title: "Document IFS-based splitting purification"
                status: "completed"
                priority: "MEDIUM"
                input: "IFS=':'; read -ra PARTS <<< \"$PATH\""
                rust: "let parts: Vec<_> = path.split(':').collect();"
                purified: "Use explicit tr or cut (avoid IFS manipulation)"
                test_name: "test_EXP_SPLIT_001_word_splitting"
                notes: "Already supported by assignment parsing infrastructure (BUILTIN-001). IFS variable assignment is supported, but for purification recommend using explicit tr, cut, or awk for deterministic word splitting instead of IFS manipulation."

          - id: "3.5.8"
            name: "Filename Expansion (Globbing)"
            tasks:
              - id: "EXP-GLOB-001"
                title: "Document glob patterns"
                status: "completed"
                version: "v1.3.0"
                priority: "MEDIUM"
                input: "for f in *.txt; do echo $f; done"
                rust: "for f in glob(\"*.txt\") { println!(\"{}\", f); }"
                purified: "for f in *.txt; do printf '%s\\n' \"$f\"; done"
                test_name: "test_glob_pattern_transformation"
                tests_added:
                  - "test_glob_pattern_transformation (unit test)"
                  - "prop_glob_patterns_preserved (property test, 100 cases)"
                  - "prop_glob_transformation_is_deterministic (property test, 100 cases)"
                  - "prop_glob_wildcards_preserved (property test, 100 cases)"
                notes: "Glob patterns preserved in purified output. Feature already existed in BashExpr::Glob. Verified with EXTREME TDD: Property Testing."
                implementation:
                  modules:
                    - "rash/src/bash_parser/ast.rs (BashExpr::Glob variant already existed)"
                    - "rash/src/bash_parser/generators.rs (glob pattern generation)"
                    - "rash/src/bash_transpiler/codegen.rs (glob to Rust)"
                  functions:
                    - "generate_expr() - Generates glob patterns in for loops"
                  lines_of_code: 15

      - id: "3.6"
        name: "Redirections"
        tasks:
          - id: "REDIR-001"
            title: "Document < redirection (input)"
            status: "completed"
            priority: "MEDIUM"
            input: "wc -l < file.txt; grep pattern < input.txt; sort < unsorted.txt > sorted.txt"
            rust: "File::open(\"file.txt\")?; Command::new(\"grep\").arg(\"pattern\").arg(\"input.txt\").output()?"
            purified: "wc -l < \"file.txt\"; grep \"pattern\" < \"input.txt\""
            test_name: "test_REDIR_001_basic_input_redirection"
            notes: "Input redirection (<) is POSIX-compliant and FULLY SUPPORTED. Connects stdin to file contents, more efficient than cat file | cmd (no pipe/subshell). File descriptor 0 redirected. Common pattern: while read loop with < file. Can combine with output redirection (sort < in.txt > out.txt). Rust mapping: File::open() + BufReader or Command with file args. Error handling: file not found/no read permission/is directory. Common use cases: count lines (wc -l <), sort file, search in file, process line-by-line (while read < file), transform contents (tr < in > out), filter and count (grep < | wc -l). Bash extensions NOT SUPPORTED: <<< here-strings (Bash 2.05b+), <(cmd) process substitution."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_REDIR_001_basic_input_redirection (passing)"
                - "test_REDIR_001_input_vs_file_argument (passing)"
                - "test_REDIR_001_while_read_pattern (passing)"
                - "test_REDIR_001_multiple_redirections (passing)"
                - "test_REDIR_001_rust_file_open_mapping (passing)"
                - "test_REDIR_001_error_handling (passing)"
                - "test_REDIR_001_common_use_cases (passing)"
                - "test_REDIR_001_bash_vs_posix_input_redir (passing)"
              lines_of_code: 402
              documentation: "Comprehensive documentation of input redirection: basic < syntax, vs file arguments, while read pattern, multiple redirections, Rust File::open() mapping, error handling, 6 common use cases, and Bash vs POSIX comparison table."
            version: "v6.6.0"

          - id: "REDIR-002"
            title: "Document > and >> redirection (output)"
            status: "completed"
            priority: "MEDIUM"
            input: "echo \"text\" > file.txt; echo \"more\" >> file.txt; cmd 2> errors.txt; cmd > output.txt 2>&1"
            rust: "File::create(\"file.txt\")?; OpenOptions::new().append(true).open(\"file.txt\")?; Command::new(\"cmd\").output()?"
            purified: "echo \"text\" > \"file.txt\"; echo \"more\" >> \"file.txt\"; cmd 2> \"errors.txt\"; cmd > \"output.txt\" 2>&1"
            test_name: "test_REDIR_002_basic_output_redirection"
            notes: "Output redirection (>, >>) is POSIX-compliant and FULLY SUPPORTED. > truncates file, >> appends. stderr (2>), merge (2>&1) supported. Bash extensions NOT SUPPORTED: &> (Bash shortcut), >& (csh-style), >| (force), >(cmd) process substitution."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_REDIR_002_basic_output_redirection (passing)"
                - "test_REDIR_002_append_redirection (passing)"
                - "test_REDIR_002_overwrite_vs_append (passing)"
                - "test_REDIR_002_stderr_redirection (passing)"
                - "test_REDIR_002_combined_io_redirection (passing)"
                - "test_REDIR_002_rust_file_mapping (passing)"
                - "test_REDIR_002_common_use_cases (passing)"
                - "test_REDIR_002_bash_vs_posix_output_redir (passing)"
              lines_of_code: 345
            version: "v6.6.0"

          - id: "REDIR-003"
            title: "Document &> redirection (stdout+stderr)"
            status: "completed"
            priority: "HIGH"
            input: "cmd &> output.txt; cmd >& combined.txt; cmd &>> log.txt"
            rust: "Command::new(\"cmd\").output()? // Use > file 2>&1 in shell"
            purified: "cmd > \"output.txt\" 2>&1; cmd > \"combined.txt\" 2>&1; cmd >> \"log.txt\" 2>&1"
            test_name: "test_REDIR_003_combined_redirection_not_supported"
            notes: "Combined redirection (&>, >&, &>>) is Bash extension, NOT SUPPORTED. POSIX equivalent is > file 2>&1 (SUPPORTED). Purification strategy: convert &> to > file 2>&1, &>> to >> file 2>&1. Order matters: > file BEFORE 2>&1."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_REDIR_003_combined_redirection_not_supported (passing)"
                - "test_REDIR_003_csh_style_redirection_not_supported (passing)"
                - "test_REDIR_003_append_combined_not_supported (passing)"
                - "test_REDIR_003_posix_equivalent (passing)"
                - "test_REDIR_003_purification_strategy (passing)"
                - "test_REDIR_003_order_matters (passing)"
                - "test_REDIR_003_common_use_cases (passing)"
                - "test_REDIR_003_bash_vs_posix_combined_redir (passing)"
              lines_of_code: 331
            version: "v6.6.0"

          - id: "REDIR-004"
            title: "Document << heredoc"
            status: "completed"
            priority: "HIGH"
            input: "cat << EOF\\nHello\\nWorld\\nEOF; cat << 'EOF'\\n$VAR\\nEOF; cat <<- EOF\\n\\tIndented\\nEOF"
            rust: "let content = \"Hello\\nWorld\\n\"; // Or use stdin piping"
            purified: "cat << EOF\\nHello\\nWorld\\nEOF"
            test_name: "test_REDIR_004_basic_heredoc_supported"
            notes: "Here documents (<<) are POSIX-compliant and FULLY SUPPORTED. Basic << syntax provides multi-line stdin. Quoted delimiter ('EOF') disables expansion. <<- variant strips leading tabs. Delimiter rules: must be alone on line, case-sensitive, content ends at unquoted delimiter."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_REDIR_004_basic_heredoc_supported (passing)"
                - "test_REDIR_004_heredoc_with_variables (passing)"
                - "test_REDIR_004_quoted_delimiter_no_expansion (passing)"
                - "test_REDIR_004_heredoc_with_indentation (passing)"
                - "test_REDIR_004_heredoc_delimiters (passing)"
                - "test_REDIR_004_heredoc_use_cases (passing)"
                - "test_REDIR_004_rust_string_literal_mapping (passing)"
                - "test_REDIR_004_bash_vs_posix_heredocs (passing)"
              lines_of_code: 387
            version: "v6.6.0"

          - id: "REDIR-005"
            title: "Document <<< herestring"
            status: "completed"
            priority: "MEDIUM"
            input: "cmd <<< \"input string\"; grep pattern <<< \"$VAR\""
            rust: "// Use echo | cmd in shell"
            purified: "echo \"input string\" | cmd; echo \"$VAR\" | grep pattern"
            test_name: "test_REDIR_005_herestring_not_supported"
            notes: "Here-strings (<<<) are Bash 2.05b+ extension, NOT SUPPORTED. POSIX equivalent: echo \"string\" | cmd (SUPPORTED). Purification strategy: convert <<< \"string\" → echo \"string\" | cmd. Newline behavior: <<< adds newline, echo adds newline, printf '%s' doesn't."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_REDIR_005_herestring_not_supported (passing)"
                - "test_REDIR_005_herestring_with_variables (passing)"
                - "test_REDIR_005_posix_echo_pipe_equivalent (passing)"
                - "test_REDIR_005_purification_strategy (passing)"
                - "test_REDIR_005_herestring_vs_heredoc (passing)"
                - "test_REDIR_005_newline_behavior (passing)"
                - "test_REDIR_005_common_use_cases (passing)"
                - "test_REDIR_005_bash_vs_posix_herestrings (passing)"
              lines_of_code: 349
            version: "v6.6.0"

  - id: 4
    name: "Shell Builtin Commands"
    sections:
      - id: "4.1"
        name: "Bourne Shell Builtins"
        tasks:
          - id: "BUILTIN-001"
            title: "Document : (no-op)"
            status: "completed"
            priority: "LOW"
            input: ": # comment"
            rust: "// comment"
            purified: ": # comment"
            test_name: "test_BUILTIN_001_noop_colon"
            notes: "Lexer recognizes ':' as command, parser stops at comments"

          - id: "BUILTIN-002"
            title: "Document . (source)"
            status: "completed"
            priority: "MEDIUM"
            input: ". ./config.sh"
            rust: "include!(\"config.rs\")"
            purified: ". \"./config.sh\""
            test_name: "test_BUILTIN_002_source_command"
            notes: "Already supported by bare word parsing (BUILTIN-001 enabled this)"

          - id: "BUILTIN-003"
            title: "Document break"
            status: "completed"
            version: "v0.8.0"
            input: "while true; do break; done"
            rust: "while true { break; }"
            purified: "while true; do break; done"
            test_name: "test_break_statement"

          - id: "BUILTIN-004"
            title: "Document continue"
            status: "completed"
            version: "v0.8.0"
            input: "for i in 1 2 3; do continue; done"
            rust: "for i in 1..=3 { continue; }"
            purified: "for i in 1 2 3; do continue; done"
            test_name: "test_continue_statement"

          - id: "BUILTIN-005"
            title: "Document cd"
            status: "completed"
            priority: "MEDIUM"
            input: "cd /tmp; cd -; cd; cd ~; cd ~/documents"
            rust: "std::env::set_current_dir(\"/tmp\"), std::env::set_current_dir(&env::var(\"OLDPWD\")), std::env::set_current_dir(&env::home_dir())"
            purified: "cd \"/tmp\"; cd -; cd; cd ~; cd \"$HOME/documents\""
            test_name: "test_BUILTIN_005_cd_command_supported"
            notes: "cd command is POSIX-COMPLIANT (SUPPORTED). cd changes current working directory, updates $PWD and $OLDPWD automatically. POSIX forms: cd /path (basic navigation), cd - (previous directory via $OLDPWD), cd (no args, go to $HOME), cd ~ (tilde expansion to $HOME), cd ~/path (tilde expansion). Bash extensions NOT SUPPORTED: -L (follow symlinks), -P (physical directory), -e (exit on error), -@ (extended attributes), CDPATH (directory search path, bash/ksh extension). Environment variables: $PWD (current directory, updated by cd), $OLDPWD (previous directory, updated by cd), $HOME (home directory, used by cd with no args). Exit status: 0 (success), 1 (failure - directory doesn't exist, no permissions, etc.). Common use cases (6): (1) cd /tmp (navigate to directory), (2) cd or cd ~ (go to home directory), (3) cd - (go to previous directory, toggle between two dirs), (4) cd ~/documents (navigate to home subdirectory), (5) cd \"$PROJECT_DIR\" (navigate with variable), (6) cd /tmp || exit 1 (error handling). Edge cases (6): (1) cd with no args goes to $HOME, (2) cd - with no $OLDPWD returns error, (3) cd to nonexistent directory returns 1 and prints error, (4) cd with permissions denied returns 1, (5) cd to symlink follows symlink by default, (6) cd with spaces requires quoting (cd \"My Documents\"). Best practices (5): (1) always quote paths with spaces (cd \"$dir\"), (2) check exit status for error handling (cd /tmp || exit 1), (3) use cd - to toggle between two directories, (4) use absolute paths for determinism in automation scripts, (5) avoid CDPATH in portable scripts (not POSIX). Rust mapping: cd /path → std::env::set_current_dir(\"/path\"), cd - → std::env::set_current_dir(&env::var(\"OLDPWD\")), cd → std::env::set_current_dir(&env::home_dir()), cd ~ → std::env::set_current_dir(&env::home_dir()). Purified bash: cd /path → cd \"/path\" (quote for safety), cd - → cd - (POSIX supported), cd → cd (POSIX supported), cd ~ → cd ~ (POSIX tilde expansion), cd -L /path → cd \"/path\" (strip bash flags), cd -P /path → cd \"/path\" (strip bash flags). Implementation: 8 passing tests document cd command mechanics, POSIX compliance, bash extensions distinction, error handling, quoting behavior, environment variables, common patterns, and edge cases. Tests use match/Ok/Err pattern for graceful error handling, working regardless of parser implementation completeness."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_BUILTIN_005_cd_command_supported (passing)"
                - "test_BUILTIN_005_cd_basic_navigation (passing)"
                - "test_BUILTIN_005_cd_hyphen_previous_directory (passing)"
                - "test_BUILTIN_005_cd_no_args_home (passing)"
                - "test_BUILTIN_005_cd_tilde_expansion (passing)"
                - "test_BUILTIN_005_cd_error_handling (passing)"
                - "test_BUILTIN_005_cd_with_spaces_quoting (passing)"
                - "test_BUILTIN_005_cd_comparison_table (passing)"
              lines_of_code: 382
            version: "v6.6.0"

          - id: "BUILTIN-006"
            title: "Document echo"
            status: "completed"
            version: "v0.4.0"
            input: "echo \"Hello World\""
            rust: "println!(\"Hello World\")"
            purified: "printf '%s\\n' \"Hello World\""
            test_name: "test_echo_to_printf"
            notes: "Prefer printf over echo"

          - id: "BUILTIN-007"
            title: "Document eval"
            status: "completed"
            version: "v6.6.0"
            priority: "LOW"
            input: "cmd=\"echo hello\"; eval $cmd"
            rust: "Not supported (dynamic execution unsafe)"
            purified: "Remove (security risk, not deterministic)"
            test_name: "test_BUILTIN_007_eval_not_supported"
            notes: "eval is intentionally NOT SUPPORTED - security risk (code injection), non-deterministic. 4 tests document why eval must be removed from scripts."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_BUILTIN_007_eval_not_supported (passing)"
                - "test_BUILTIN_007_eval_security_risk (passing)"
                - "test_BUILTIN_007_eval_non_deterministic (passing)"
                - "test_BUILTIN_007_eval_refactoring_alternative (passing)"
              lines_of_code: 143
              documentation: "Comprehensive documentation of eval security risks: code injection (CWE-78), arbitrary command execution, non-deterministic behavior. Includes refactoring strategy to explicit commands."
              security_risks:
                - "Code injection vulnerability (arbitrary command execution)"
                - "Cannot be statically analyzed or verified"
                - "Classic attack vector in shell scripts"
                - "CWE-78: OS Command Injection"
                - "Severity: CRITICAL when used with user input"
              determinism_issues:
                - "eval depends on runtime variable values"
                - "Same script may execute different commands each run"
                - "Cannot be purified to deterministic POSIX sh"
                - "Violates idempotency principle"
              refactoring_strategy:
                - "Instead of: cmd=\"echo hello\"; eval $cmd"
                - "Use: echo hello (explicit, static, deterministic)"
                - "Linter should flag eval usage as CRITICAL security issue"
                - "No safe equivalent - must be removed from purified scripts"

          - id: "BUILTIN-008"
            title: "Document exec"
            status: "completed"
            version: "v6.6.0"
            priority: "LOW"
            input: "exec ./new-script.sh"
            rust: "std::process::Command::new(\"./new-script.sh\").exec()"
            purified: "Remove (replaces process, not idempotent)"
            test_name: "test_BUILTIN_008_exec_not_supported"
            notes: "exec is intentionally NOT SUPPORTED - non-idempotent (replaces process), cannot be re-run. 4 tests document why exec must be removed from scripts."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_BUILTIN_008_exec_not_supported (passing)"
                - "test_BUILTIN_008_exec_breaks_idempotency (passing)"
                - "test_BUILTIN_008_exec_fd_redirection (passing)"
                - "test_BUILTIN_008_exec_refactoring_alternative (passing)"
              lines_of_code: 146
              documentation: "Comprehensive documentation of exec idempotency issues: process replacement, global state modification, cannot be re-run. Includes refactoring strategy to explicit script invocation."
              idempotency_issues:
                - "exec replaces the current process (shell terminates)"
                - "Cannot be run multiple times (process is gone after first run)"
                - "Breaks 'safe to re-run' principle"
                - "No way to undo or reverse"
                - "exec with FD redirection modifies global shell state permanently"
              determinism_issues:
                - "exec changes global process state permanently"
                - "Side effects cannot be rolled back"
                - "Script cannot continue after exec"
              refactoring_strategy:
                - "Instead of: exec ./new-script.sh (replaces process)"
                - "Use: ./new-script.sh (runs script, returns control)"
                - "Linter should flag exec usage as idempotency violation"
                - "No safe equivalent - must be removed from purified scripts"

          - id: "BUILTIN-009"
            title: "Document exit"
            status: "completed"
            priority: "MEDIUM"
            input: "exit 0; exit 1; exit; exit $?"
            rust: "std::process::exit(0), std::process::exit(1), std::process::exit(last_exit_status)"
            purified: "exit 0; exit 1; exit; exit $?"
            test_name: "test_BUILTIN_009_exit_command_supported"
            notes: "exit command is POSIX-COMPLIANT (SUPPORTED). exit terminates shell with specified exit code (0-255). exit with no args uses $? (last command exit status). POSIX forms: exit 0 (success), exit 1 (error), exit [0-255] (specific codes), exit (no args, uses $?), exit $? (explicit last status). Bash extensions NOT SUPPORTED: exit >255 (wraps modulo 256 to 0-255 in bash), exit <0 (wraps modulo 256 in bash, e.g., exit -1 becomes 255). Standard exit codes (POSIX): 0 (success), 1 (general error), 2 (misuse of shell builtin), 126 (command cannot execute, permission problem), 127 (command not found), 128 (invalid argument to exit), 128+N (fatal error signal N, e.g., 130 = 128+2 for SIGINT/Ctrl-C), 255 (exit status out of range). Exit behavior: exit in script terminates entire script (even from function), exit in subshell terminates only subshell (not parent), exit in function terminates entire script (not just function). exit vs return: exit terminates entire script, return returns from function only (function-local), use return (not exit) in functions to avoid terminating script. Common use cases (6): (1) exit 0 (success at end of script), (2) exit 1 (error exit on failure), (3) [ -z \"$VAR\" ] && exit 1 (conditional exit), (4) command || exit (exit if command fails), (5) exit 2 (custom error code for specific error type), (6) if [ error ]; then exit 1; fi (early return pattern). Edge cases (6): (1) exit with no args uses $? from last command, (2) exit >255 wraps modulo 256 in bash (NOT SUPPORTED, normalize to 0-255), (3) exit <0 wraps modulo 256 in bash (NOT SUPPORTED, normalize to 0-255), (4) exit in subshell terminates subshell only, (5) exit in function terminates entire script, (6) exit in trap depends on trap type (EXIT, ERR, etc.). Best practices (7): (1) use exit 0 for success at end of script, (2) use exit 1 for general errors, (3) use specific exit codes 2-125 for different error types, (4) document exit codes in script header, (5) use return (not exit) in functions to avoid terminating script, (6) check $? before exit to propagate error codes, (7) avoid exit codes >125 (reserved for signals and special meanings). Rust mapping: exit 0 → std::process::exit(0), exit 1 → std::process::exit(1), exit → std::process::exit(last_exit_status), exit $? → std::process::exit(last_exit_status). Purification: exit 0 → exit 0 (POSIX supported), exit 1 → exit 1 (POSIX supported), exit → exit (POSIX supported, uses $?), exit 256 → exit 0 (normalize to 0-255 range), exit -1 → exit 255 (normalize to 0-255 range). Implementation: 8 passing tests document exit command mechanics, POSIX compliance, bash extensions distinction, exit vs return, standard exit codes, conditional patterns, edge cases, and best practices. Tests use match/Ok/Err pattern for graceful error handling, working regardless of parser implementation completeness."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_BUILTIN_009_exit_command_supported (passing)"
                - "test_BUILTIN_009_exit_with_status_code (passing)"
                - "test_BUILTIN_009_exit_no_args (passing)"
                - "test_BUILTIN_009_exit_vs_return (passing)"
                - "test_BUILTIN_009_exit_standard_codes (passing)"
                - "test_BUILTIN_009_exit_conditional (passing)"
                - "test_BUILTIN_009_exit_edge_cases (passing)"
                - "test_BUILTIN_009_exit_comparison_table (passing)"
              lines_of_code: 465
            version: "v6.6.0"

          - id: "BUILTIN-010"
            title: "Document export"
            status: "completed"
            priority: "HIGH"
            input: "export PATH=\"/usr/local/bin:$PATH\"; export VAR=\"value\"; export USER"
            rust: "std::env::set_var(\"PATH\", \"/usr/local/bin:$PATH\"), std::env::set_var(\"VAR\", \"value\"), std::env::set_var(\"USER\", existing_value)"
            purified: "export PATH=\"/usr/local/bin:$PATH\"; export VAR=\"value\"; export USER"
            test_name: "test_BUILTIN_010_export_command_supported"
            notes: "export command is POSIX-COMPLIANT (SUPPORTED). export sets and exports environment variables to child processes. POSIX forms (5): (1) export VAR=value (set and export), (2) export VAR (export existing variable), (3) export VAR=\"value\" (with quoting), (4) export -p (print exported variables), (5) export VAR1=val1 VAR2=val2 (multiple exports). Bash extensions NOT SUPPORTED (3): (1) export -n VAR (unexport, remove export attribute), (2) export -f func (export function definitions, bash-specific), (3) export ARRAY (array export, bash arrays not POSIX). export vs variable assignment: VAR=value sets variable in current shell only (not exported), export VAR=value sets and exports to child processes, child processes inherit exported variables, non-exported variables are local to current shell. Common use cases (6): (1) export PATH=\"/usr/local/bin:$PATH\" (prepend to PATH), (2) export CONFIG_FILE=\"/etc/app.conf\" (set config location), (3) VAR=value; export VAR (export existing variable), (4) export VAR1=val1 VAR2=val2 (multiple exports in one command), (5) export -p (print all exported variables for debugging), (6) export CC=gcc CXX=g++ CFLAGS=\"-O2\" (build environment setup). Edge cases (6): (1) export with no value exports existing variable, (2) export nonexistent creates empty exported variable, (3) export with spaces requires quoting (export VAR=\"value with spaces\"), (4) export in subshell only affects subshell (not parent), (5) export in function affects entire script (exported globally), (6) later export overwrites previous value. Best practices (6): (1) quote values with spaces (export VAR=\"value with spaces\"), (2) use uppercase for exported variables (convention), (3) document required environment variables in script header, (4) check if variable is set before using (${VAR:-default}), (5) use export for variables needed by child processes, (6) avoid exporting sensitive data (passwords, tokens). Rust mapping (3): export VAR=value → std::env::set_var(\"VAR\", \"value\"), export VAR → std::env::set_var(\"VAR\", existing_value), export -p → std::env::vars() and print. Purification (5): export VAR=value → export VAR=value (POSIX supported), export VAR → export VAR (POSIX supported), export VAR=\"value\" → export VAR=\"value\" (preserve quoting), export -n VAR → unset VAR (remove variable, closest POSIX equivalent), export -f func → remove from purified scripts (not supported). Implementation: 8 passing tests document export command mechanics, POSIX compliance, bash extensions distinction, export vs assignment, multiple exports, quoting, print functionality, and comprehensive comparison. Tests use match/Ok/Err pattern for graceful error handling, working regardless of parser implementation completeness."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_BUILTIN_010_export_command_supported (passing)"
                - "test_BUILTIN_010_export_set_and_export (passing)"
                - "test_BUILTIN_010_export_existing_variable (passing)"
                - "test_BUILTIN_010_export_vs_assignment (passing)"
                - "test_BUILTIN_010_export_multiple (passing)"
                - "test_BUILTIN_010_export_quoting (passing)"
                - "test_BUILTIN_010_export_print (passing)"
                - "test_BUILTIN_010_export_comparison_table (passing)"
              lines_of_code: 370
            version: "v6.6.0"

          - id: "BUILTIN-011"
            title: "Document pwd"
            status: "completed"
            priority: "MEDIUM"
            input: "pwd; pwd -L; pwd -P; current=$(pwd)"
            rust: "std::env::current_dir(), std::fs::canonicalize(std::env::current_dir())"
            purified: "pwd; pwd -L; pwd -P; current=$(pwd)"
            test_name: "test_BUILTIN_011_pwd_command_supported"
            notes: "pwd command is POSIX-COMPLIANT (SUPPORTED). pwd prints current working directory. POSIX forms (3): (1) pwd (print current directory), (2) pwd -L (logical path, follows symlinks, default), (3) pwd -P (physical path, resolves symlinks to canonical path). No bash extensions (pwd is fully POSIX-compliant). pwd vs \$PWD: pwd is command that queries system (always accurate), \$PWD is environment variable updated by cd (can be manually modified), usually equivalent but pwd is more reliable. Common use cases (6): (1) current=\$(pwd) (save current directory), (2) old=\$(pwd); cd /tmp; cd \"\$old\" (save and restore pattern), (3) echo \"Working in \$(pwd)\" (display current location), (4) SCRIPT_DIR=\"\$(cd \"\$(dirname \"\$0\")\" && pwd)\" (get script directory reliably), (5) physical_path=\$(pwd -P) (resolve symlinks to canonical path), (6) logical_path=\$(pwd -L) (preserve symlink path). Edge cases (5): (1) directory deleted (pwd may fail if CWD deleted), (2) no permissions (pwd may fail without read permissions), (3) symlinks (pwd -L shows symlink path, pwd -P shows real path), (4) \$PWD mismatch (pwd always accurate, \$PWD can be modified manually), (5) chroot (pwd shows path relative to chroot, not actual system path). Best practices (5): (1) use pwd for portability (works in all POSIX shells), (2) use \$PWD for efficiency (no subprocess spawn), (3) use pwd -P to resolve symlinks for canonical paths, (4) save pwd before changing directories for restoration, (5) quote pwd output in assignments (dir=\"\$(pwd)\"). Rust mapping (3): pwd → std::env::current_dir(), pwd -L → std::env::current_dir() (logical path), pwd -P → std::fs::canonicalize(std::env::current_dir()) (physical path). Purification (3): pwd → pwd (POSIX supported), pwd -L → pwd -L (POSIX supported), pwd -P → pwd -P (POSIX supported). pwd is deterministic (always returns current directory). Implementation: 8 passing tests document pwd command mechanics, POSIX compliance, logical vs physical paths, pwd vs \$PWD distinction, common patterns, symlink resolution, edge cases, and comprehensive comparison. Tests use match/Ok/Err pattern for graceful error handling, working regardless of parser implementation completeness."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_BUILTIN_011_pwd_command_supported (passing)"
                - "test_BUILTIN_011_pwd_basic (passing)"
                - "test_BUILTIN_011_pwd_logical_vs_physical (passing)"
                - "test_BUILTIN_011_pwd_vs_env_var (passing)"
                - "test_BUILTIN_011_pwd_common_patterns (passing)"
                - "test_BUILTIN_011_pwd_symlink_resolution (passing)"
                - "test_BUILTIN_011_pwd_edge_cases (passing)"
                - "test_BUILTIN_011_pwd_comparison_table (passing)"
              lines_of_code: 405
            version: "v6.6.0"

          - id: "BUILTIN-012"
            title: "Document read"
            status: "completed"
            version: "v6.6.0"
            priority: "LOW"
            input: "read -r var"
            rust: "Not supported (interactive input non-deterministic)"
            purified: "Remove (use command-line args instead)"
            test_name: "test_BUILTIN_012_read_not_supported"
            notes: "read is intentionally NOT SUPPORTED - interactive input, non-deterministic. 4 tests document why read must be removed from scripts."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_BUILTIN_012_read_not_supported (passing)"
                - "test_BUILTIN_012_read_non_deterministic (passing)"
                - "test_BUILTIN_012_read_interactive_only (passing)"
                - "test_BUILTIN_012_read_refactoring_alternative (passing)"
              lines_of_code: 159
              documentation: "Comprehensive documentation of read non-determinism: interactive input, varies each run, cannot be automated. Includes refactoring strategy to command-line arguments."
              determinism_issues:
                - "read depends on user input at runtime"
                - "Different input each run → non-deterministic"
                - "Cannot predict output from static analysis"
                - "Impossible to purify to deterministic script"
              automation_issues:
                - "Requires user interaction (cannot run in CI/CD)"
                - "Fails in non-interactive environments (cron, Docker)"
                - "No user present in automated deployments"
                - "Cannot be reliably re-run without user intervention"
              refactoring_strategy:
                - "Instead of: read -p \"Enter name: \" name (interactive)"
                - "Use: name=\"$1\" (command-line argument, deterministic)"
                - "Usage: ./script.sh Alice (automated, deterministic)"
                - "Linter should flag read usage as determinism violation"

          - id: "BUILTIN-013"
            title: "Document return"
            status: "completed"
            version: "v0.4.0"
            input: "func() { return 1; }"
            rust: "fn func() -> Result<(), String> { Err(\"error\".into()) }"
            purified: "func() { return 1; }"
            test_name: "test_return_statement"

          - id: "BUILTIN-014"
            title: "Document set"
            status: "completed"
            priority: "MEDIUM"
            input: "set -e"
            rust: "Not applicable (compile-time checking)"
            purified: "set -e"
            test_name: "test_BUILTIN_014_set_flags"
            notes: "Already supported by command parsing infrastructure (BUILTIN-001)"

          - id: "BUILTIN-015"
            title: "Document shift"
            status: "completed"
            priority: "MEDIUM"
            input: "shift; echo $1"
            rust: "args.remove(0); println!(\"{}\", args[0])"
            purified: "shift; printf '%s\\n' \"$1\""
            test_name: "test_BUILTIN_015_shift_command"
            notes: "Already supported by command parsing infrastructure (BUILTIN-001)"

          - id: "BUILTIN-016"
            title: "Document test / ["
            status: "completed"
            priority: "HIGH"
            input: "if [ -f \"file.txt\" ]; then echo \"exists\"; fi"
            rust: "if std::path::Path::new(\"file.txt\").is_file() { println!(\"exists\"); }"
            purified: "if [ -f \"file.txt\" ]; then printf '%s\\n' \"exists\"; fi"
            test_name: "test_BUILTIN_016_test_command_supported"
            notes: "test / [ is POSIX SUPPORTED (HIGH priority). test evaluates conditional expressions, [ is alias for test. POSIX operators: FILE TESTS (-f/-d/-e/-r/-w/-x/-s/-L), STRING TESTS (-z/-n/=!=/\\</\\>), INTEGER TESTS (-eq/-ne/-lt/-le/-gt/-ge), LOGICAL (!/- a/-o). Bash extensions NOT SUPPORTED: [[ ]], ==, =~, unescaped < >, pattern matching. Use [ ] with = (not ==) for POSIX portability. 8 comprehensive tests document all POSIX test operators and purification strategies for bash extensions."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_BUILTIN_016_test_command_supported (passing)"
                - "test_BUILTIN_016_test_file_tests (passing)"
                - "test_BUILTIN_016_test_string_tests (passing)"
                - "test_BUILTIN_016_test_integer_tests (passing)"
                - "test_BUILTIN_016_test_logical_operators (passing)"
                - "test_BUILTIN_016_test_bash_extensions_not_supported (passing)"
                - "test_BUILTIN_016_test_common_patterns (passing)"
                - "test_BUILTIN_016_test_comparison_table (passing)"
              lines_of_code: 663
            version: "v6.6.0"

          - id: "BUILTIN-017"
            title: "Document times"
            status: "completed"
            version: "v6.6.0"
            priority: "LOW"
            input: "times"
            rust: "Not supported (profiling, non-deterministic)"
            purified: "Remove (use external profiling tools)"
            test_name: "test_BUILTIN_017_times_not_supported"
            notes: "times is intentionally NOT SUPPORTED - profiling data, non-deterministic (CPU time varies). 4 tests document why times must be removed from scripts."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_BUILTIN_017_times_not_supported (passing)"
                - "test_BUILTIN_017_times_non_deterministic (passing)"
                - "test_BUILTIN_017_times_profiling_only (passing)"
                - "test_BUILTIN_017_times_refactoring_alternative (passing)"
              lines_of_code: 167
              documentation: "Comprehensive documentation of times non-determinism: CPU time varies based on system load, not needed in production. Includes external profiling tool recommendations."
              determinism_issues:
                - "CPU time varies based on system load"
                - "Different values each run (load, CPU speed, cache, scheduling)"
                - "Cannot predict output from static analysis"
                - "Timing data is inherently non-deterministic"
              profiling_issues:
                - "times is for performance profiling only"
                - "Not needed in production scripts"
                - "Adds runtime overhead"
                - "External tools provide better metrics"
              external_tools:
                - "GNU time: /usr/bin/time -v ./script.sh"
                - "hyperfine: hyperfine './script.sh'"
                - "perf: perf stat ./script.sh"
                - "valgrind: Memory profiling"
              refactoring_strategy:
                - "Instead of: times (embedded in script)"
                - "Use: /usr/bin/time -v ./script.sh (external profiling)"
                - "Benefits: No script modification, better metrics, statistical analysis"
                - "Linter should flag times usage as determinism violation"

          - id: "BUILTIN-018"
            title: "Document trap"
            status: "completed"
            priority: "MEDIUM"
            input: "trap 'cleanup' EXIT"
            rust: "Use Drop trait"
            purified: "trap 'cleanup' EXIT"
            test_name: "test_BUILTIN_018_trap_signal_handling"
            notes: "Already supported by command parsing infrastructure (BUILTIN-001)"

          - id: "BUILTIN-019"
            title: "Document umask"
            status: "completed"
            version: "v6.6.0"
            priority: "LOW"
            input: "umask 022"
            rust: "std::fs::set_permissions()"
            purified: "umask 022"
            test_name: "test_BUILTIN_019_umask_basic"
            notes: "umask is SUPPORTED but modifies global state. 4 tests document global state implications, idempotency concerns, and chmod as alternative."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_BUILTIN_019_umask_basic (passing)"
                - "test_BUILTIN_019_umask_global_state (passing)"
                - "test_BUILTIN_019_umask_idempotency_concern (passing)"
                - "test_BUILTIN_019_umask_explicit_chmod_alternative (passing)"
              lines_of_code: 157
              documentation: "Comprehensive documentation of umask: global state modification, idempotency concerns, best practices. Recommends chmod as explicit alternative."
              global_state_issues:
                - "umask modifies process-wide file creation mask"
                - "Affects all subsequent file operations"
                - "Cannot be scoped (applies to entire shell process)"
                - "Side effects persist across script boundaries"
              idempotency_concerns:
                - "umask changes global state permanently"
                - "Running script multiple times stacks umask calls"
                - "May override system/user defaults"
                - "Difficult to restore original value"
              best_practices:
                - "Set umask at start of script if needed"
                - "Document why specific umask is required"
                - "Save and restore original umask: old=$(umask); umask 022; ...; umask $old"
                - "Consider explicit chmod instead of umask"
              chmod_alternative:
                - "chmod is more explicit and localized"
                - "No global state modification"
                - "Clear intent in code"
                - "Easier to audit and understand"

          - id: "BUILTIN-020"
            title: "Document unset"
            status: "completed"
            priority: "HIGH"
            input: "unset VAR; unset -v VAR2; unset -f func; unset A B C"
            rust: "vars.remove(\"VAR\"); functions.remove(\"func\");"
            purified: "unset VAR; unset -v VAR2; unset -f func; unset A B C"
            test_name: "test_BUILTIN_020_unset_command_supported"
            notes: "unset is POSIX SUPPORTED (HIGH priority). Removes variables and functions from shell environment. POSIX forms: unset VAR (default), unset -v VAR (explicit variable), unset -f FUNC (function), unset multiple. Exit status: 0 (success or nonexistent), non-zero (readonly/error). Bash extensions NOT SUPPORTED: unset -n nameref, unset array[index], unset assoc[key]. CRITICAL DISTINCTION: unset VAR (removes completely) vs VAR=\"\" (set but empty). ${VAR-default} for UNSET only, ${VAR:-default} for UNSET OR EMPTY. 8 comprehensive tests document all unset behaviors, exit status, common patterns, bash extensions, and unset vs empty assignment."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_BUILTIN_020_unset_command_supported (passing)"
                - "test_BUILTIN_020_unset_variables (passing)"
                - "test_BUILTIN_020_unset_functions (passing)"
                - "test_BUILTIN_020_unset_exit_status (passing)"
                - "test_BUILTIN_020_unset_common_patterns (passing)"
                - "test_BUILTIN_020_unset_bash_extensions_not_supported (passing)"
                - "test_BUILTIN_020_unset_vs_empty_assignment (passing)"
                - "test_BUILTIN_020_unset_comparison_table (passing)"
              lines_of_code: 703
            version: "v6.6.0"

      - id: "4.2"
        name: "Bash Builtin Commands"
        tasks:
          - id: "BASH-BUILTIN-001"
            title: "Document alias"
            status: "completed"
            priority: "MEDIUM"
            input: "alias ll='ls -la'"
            rust: "Not supported (interactive feature)"
            purified: "Remove (use functions instead)"
            test_name: "test_BASH_BUILTIN_001_alias_to_function"
            notes: "Already supported by command parsing infrastructure (BUILTIN-001)"

          - id: "BASH-BUILTIN-002"
            title: "Document declare/typeset"
            status: "completed"
            priority: "MEDIUM"
            input: "declare -i num=5"
            rust: "let num: i32 = 5;"
            purified: "num=5"
            test_name: "test_BASH_BUILTIN_002_declare_to_assignment"
            notes: "Already supported by command parsing infrastructure (BUILTIN-001)"

          - id: "BASH-BUILTIN-003"
            title: "Document let"
            status: "completed"
            version: "v6.6.0"
            priority: "LOW"
            input: "let \"x = 5 + 3\""
            rust: "let x = 5 + 3;"
            purified: "x=$((5 + 3))"
            test_name: "test_BASH_BUILTIN_003_let_basic"
            notes: "let is Bash-specific. 4 tests document let and recommend POSIX $((...)) alternative for portability."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_BASH_BUILTIN_003_let_basic (passing)"
                - "test_BASH_BUILTIN_003_let_increment (passing)"
                - "test_BASH_BUILTIN_003_let_posix_alternative (passing)"
                - "test_BASH_BUILTIN_003_let_refactoring (passing)"
              lines_of_code: 156
              documentation: "Comprehensive documentation of let command and POSIX $((...)) alternative. Includes conversion rules for operators (+=, ++, --)."
              posix_issues:
                - "let is Bash-specific (not available in sh, dash)"
                - "$((...)) is POSIX-compliant (works in all shells)"
                - "let requires quoting, $((...)) does not"
              conversion_rules:
                - "let \"x = expr\" → x=$((expr))"
                - "let \"x += 1\" → x=$((x + 1))"
                - "let \"x++\" → x=$((x + 1))"
                - "let \"x--\" → x=$((x - 1))"
              portability:
                - "let: Bash, zsh only"
                - "$((...)):  All POSIX shells (sh, dash, bash, zsh, ksh)"
              purification_strategy:
                - "Convert all let to $((...)) for POSIX compliance"
                - "More explicit and readable"
                - "Standard shell arithmetic"

          - id: "BASH-BUILTIN-004"
            title: "Document local"
            status: "completed"
            priority: "MEDIUM"
            input: "func() { local var=5; }"
            rust: "fn func() { let var = 5; }"
            purified: "func() { _var=5; }"
            test_name: "test_BASH_BUILTIN_004_local_to_scoped_var"
            notes: "Parser updated to handle Token::Local keyword (lines 95, 277-292 in parser.rs)"

          - id: "BASH-BUILTIN-005"
            title: "Document printf"
            status: "completed"
            priority: "HIGH"
            input: "printf '%s %d\\n' \"Number:\" 42; printf '%.2f\\n' 3.14"
            rust: "println!(\"{} {}\", \"Number:\", 42); println!(\"{:.2}\", 3.14);"
            purified: "printf '%s %d\\n' \"Number:\" 42; printf '%.2f\\n' 3.14"
            test_name: "test_BASH_BUILTIN_005_printf_command_supported"
            notes: "printf is POSIX SUPPORTED (HIGH priority, portable echo alternative). Formats and prints data with precise control. POSIX features: format specifiers (%s/%d/%f/%x/%o), escape sequences (\\n/\\t/\\\\/\\'/\\\"), width/precision (%10s/%-10s/%05d/%.2f). WHY printf over echo: POSIX-standardized (echo varies), explicit newline control, format control, consistent escapes, multiple arguments. Bash extensions NOT SUPPORTED: %(...)T date (use date command), %b escapes in arg (use format escapes), %q quote (manual), -v var (use command substitution). Echo replacement: echo \"text\" → printf '%s\\n' \"text\", echo -n → printf '%s', echo -e → printf with escapes. 8 comprehensive tests document all format specifiers, escape sequences, width/precision, printf vs echo, bash extensions, common patterns, and comparison table."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_BASH_BUILTIN_005_printf_command_supported (passing)"
                - "test_BASH_BUILTIN_005_printf_format_specifiers (passing)"
                - "test_BASH_BUILTIN_005_printf_escape_sequences (passing)"
                - "test_BASH_BUILTIN_005_printf_width_precision (passing)"
                - "test_BASH_BUILTIN_005_printf_vs_echo (passing)"
                - "test_BASH_BUILTIN_005_printf_bash_extensions_not_supported (passing)"
                - "test_BASH_BUILTIN_005_printf_common_patterns (passing)"
                - "test_BASH_BUILTIN_005_printf_comparison_table (passing)"
              lines_of_code: 638
            version: "v6.6.0"

          - id: "BASH-BUILTIN-006"
            title: "Document readarray/mapfile"
            status: "completed"
            version: "v6.6.0"
            priority: "LOW"
            input: "readarray -t lines < file.txt"
            rust: "let lines: Vec<_> = read_lines(\"file.txt\")?;"
            purified: "while IFS= read -r line; do ... done < file.txt (POSIX)"
            test_name: "test_BASH_BUILTIN_006_readarray_not_supported"
            notes: "readarray/mapfile is Bash 4.0+ extension, NOT SUPPORTED. 5 passing tests document readarray as Bash-specific, POSIX while read alternative, transformation strategies, mapfile alias, and memory efficiency comparison."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_BASH_BUILTIN_006_readarray_not_supported (passing)"
                - "test_BASH_BUILTIN_006_posix_while_read_alternative (passing)"
                - "test_BASH_BUILTIN_006_transformation_strategy (passing)"
                - "test_BASH_BUILTIN_006_mapfile_alias_not_supported (passing)"
                - "test_BASH_BUILTIN_006_memory_efficiency_comparison (passing)"
              lines_of_code: 265
              documentation: "Comprehensive documentation of readarray/mapfile as Bash 4.0+ extension. NOT POSIX-compliant. POSIX alternative: while IFS= read -r loop. Transformation strategies for 3 common scenarios (process lines, store for later, count lines). Memory efficiency: while read is O(1) vs readarray O(n)."
              why_not_supported:
                - "Bash 4.0+ only (not in dash, ash, busybox sh)"
                - "Requires array support (not in POSIX sh)"
                - "Loads entire file into memory (not efficient for large files)"
              posix_alternative:
                - "while IFS= read -r line; do ... done < file.txt"
                - "IFS= prevents word splitting"
                - "read -r prevents backslash escaping"
                - "Streaming (one line at a time, memory efficient)"
              transformation_scenarios:
                - "Process all lines: while read loop replaces array iteration"
                - "Store for later: Use numbered variables (line_1, line_2, etc.)"
                - "Count lines: Increment counter in while loop"
              memory_efficiency:
                - "readarray: O(n) memory (loads entire file)"
                - "while read: O(1) memory (single line buffer)"
                - "while read handles files of ANY size"
              mapfile_alias:
                - "mapfile = readarray (exact same functionality)"
                - "Both require Bash 4.0+"
                - "Both NOT POSIX-compliant"

  - id: 5
    name: "Shell Variables"
    sections:
      - id: "5.1"
        name: "Bourne Shell Variables"
        tasks:
          - id: "VAR-001"
            title: "Document HOME"
            status: "completed"
            priority: "HIGH"
            input: "cd \"$HOME\"; cd ~/documents; cd"
            rust: "std::env::set_current_dir(std::env::var(\"HOME\").unwrap());"
            purified: "cd \"$HOME\"; cd \"$HOME/documents\"; cd"
            test_name: "test_VAR_001_home_variable_supported"
            notes: "HOME is POSIX SUPPORTED (HIGH priority, fundamental user directory). User's home directory full path, set at login from /etc/passwd. POSIX forms: $HOME, ${HOME}, cd (no args) → $HOME, ~ → $HOME. CRITICAL: HOME read-only by convention (never modify). Best practices: always quote \"$HOME\", check exists [ -d \"$HOME\" ], check set [ -z \"$HOME\" ], use for user files, never modify, portable tilde (~ POSIX, ~user bash extension), use $HOME in scripts, ~ interactively. HOME vs tilde: $HOME is env var, ~ is expansion, cd ~ == cd \"$HOME\", ~/dir == \"$HOME/dir\", \"~/dir\" WRONG (no expansion in quotes). Security: always quote (prevents injection), validate exists, check ownership (paranoid), avoid symlinks, use mktemp. Edge cases: HOME not set, non-existent, spaces, special chars, empty, root /, fallback ${HOME:-/tmp}. System: set from /etc/passwd, cd uses HOME, ~ expands, utilities use (.bashrc, .ssh, .gitconfig). 8 comprehensive tests document HOME usage, common patterns, vs tilde, best practices, edge cases, system interaction, security, and comparison table."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_VAR_001_home_variable_supported (passing)"
                - "test_VAR_001_home_common_patterns (passing)"
                - "test_VAR_001_home_vs_tilde (passing)"
                - "test_VAR_001_home_best_practices (passing)"
                - "test_VAR_001_home_edge_cases (passing)"
                - "test_VAR_001_home_system_interaction (passing)"
                - "test_VAR_001_home_security_considerations (passing)"
                - "test_VAR_001_home_comparison_table (passing)"
              lines_of_code: 724
            version: "v6.6.0"

          - id: "VAR-002"
            title: "Document PATH"
            status: "completed"
            priority: "HIGH"
            input: "PATH=\"/usr/local/bin:$PATH\"; export PATH; command -v ls"
            rust: "std::env::var(\"PATH\"); std::env::set_var(\"PATH\", ...); std::process::Command::new()"
            purified: "PATH=\"/usr/local/bin:$PATH\"; export PATH; command -v ls"
            test_name: "test_VAR_002_path_variable_supported"
            notes: "PATH is POSIX SUPPORTED (HIGH priority, fundamental command lookup). PATH is colon-separated list of directories to search for commands. Set by: System at login, modified by shells/users/package managers. Used by: Shell command lookup (first match wins, left to right). PATH structure: PATH=\"/usr/local/bin:/usr/bin:/bin\" (colon delimiters). Command lookup order: (1) Builtins, (2) Functions, (3) Aliases, (4) PATH directories. CRITICAL: PATH order matters, /usr/local/bin first (user overrides system). Common patterns (10): Prepend (priority), Append (lower priority), Export, Avoid duplicates, Remove dir, Reset to minimal, Search PATH (command -v), Iterate, Check exists, Temporary PATH (subshell). PATH vs which vs command -v: command -v is POSIX RECOMMENDED (finds builtins+functions+executables, consistent exit status), which is NOT POSIX (avoid), type is bash builtin NOT POSIX (avoid). PURIFICATION: Replace which/type with command -v. Best practices (8): Always quote \"$PATH\", Export after modification, Prepend user directories, Append home directories, NEVER put \".\" in PATH (DANGEROUS Trojan horse attacks), Check PATH is set (fallback), Avoid duplicates, Use absolute paths for security-critical scripts. Security (5 CRITICAL): Never put \".\" or writable directories in PATH (hijacking attack), Use absolute paths in security scripts (/usr/bin/sudo), Reset PATH at start of security scripts, Verify command locations before executing, Protect ~/.profile permissions (chmod 644). EXAMPLE ATTACK: Attacker creates /tmp/sudo, if PATH=\"/tmp:$PATH\" attacker's sudo executes. MITIGATION: Never put writable directories in PATH, use absolute paths. Edge cases (7): PATH not set (fallback), PATH empty (fallback), PATH with spaces (must quote), PATH special chars (colons delimiters), PATH very long (system limits), PATH non-existent directories (shell silently skips), PATH duplicates (inefficient but valid). System interaction: PATH initialization (/etc/profile → ~/.profile → ~/.bashrc), Command lookup (builtins → functions → aliases → PATH search), PATH inheritance (parent exports PATH → child receives, child modifications don't affect parent). Typical PATH values: Root, User, Minimal. Rust mapping (5): std::env::var(\"PATH\"), std::env::set_var(\"PATH\", ...), std::env::split_paths(&path), std::env::join_paths([...]), std::process::Command::new(). PURIFICATION RULES (5): Replace which with command -v, Replace type with command -v, Remove \".\" from PATH, Quote all PATH references, Use absolute paths for security commands. PATH is POSIX-COMPLIANT, deterministic, security enforced (no \".\" in PATH), portable. Comprehensive comparison table: POSIX SUPPORTED (PATH=\"/dir1:/dir2\", PATH=\"/new:$PATH\", export PATH, command -v ls, colon-separated dirs, PATH with spaces quoted), NOT POSIX (which, type, whereis), FORBIDDEN (empty entry :: for current dir - security risk), SECURITY ENFORCED (no \".\" in PATH validated by bashrs)."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_VAR_002_path_variable_supported (passing)"
                - "test_VAR_002_path_common_patterns (passing)"
                - "test_VAR_002_path_vs_which_vs_command (passing)"
                - "test_VAR_002_path_best_practices (passing)"
                - "test_VAR_002_path_edge_cases (passing)"
                - "test_VAR_002_path_system_interaction (passing)"
                - "test_VAR_002_path_security_considerations (passing)"
                - "test_VAR_002_path_comparison_table (passing)"
              lines_of_code: 696
            version: "v6.6.0"

          - id: "VAR-003"
            title: "Document IFS purification"
            status: "completed"
            priority: "MEDIUM"
            input: "IFS=':'; read -ra parts <<< \"$PATH\""
            rust: "let parts: Vec<_> = path.split(':').collect();"
            purified: "Avoid IFS manipulation (use tr/cut)"
            test_name: "test_VAR_003_ifs_purification"
            notes: "Already supported by command parsing infrastructure (BUILTIN-001)"

          - id: "VAR-004"
            title: "Document PS1, PS2, PS3, PS4"
            status: "completed"
            version: "v6.6.0"
            priority: "LOW"
            input: "PS1='$ ', PS2='> ', PS3='#? ', PS4='+ '"
            rust: "Not applicable (no interactive mode)"
            purified: "Remove all prompt variables (not needed in scripts)"
            test_name: "test_VAR_004_ps1_prompt_not_supported"
            notes: "PS1, PS2, PS3, PS4 are interactive prompt variables, NOT SUPPORTED. 6 passing tests document PS1 (primary prompt), PS2 (continuation), PS3 (select), PS4 (debug trace), purification strategy, and script-mode-only philosophy."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_VAR_004_ps1_prompt_not_supported (passing)"
                - "test_VAR_004_ps2_continuation_prompt_not_supported (passing)"
                - "test_VAR_004_ps3_select_prompt_not_supported (passing)"
                - "test_VAR_004_ps4_debug_prompt_not_production (passing)"
                - "test_VAR_004_purification_removes_prompts (passing)"
                - "test_VAR_004_script_mode_only_philosophy (passing)"
              lines_of_code: 274
              documentation: "Comprehensive documentation of PS1, PS2, PS3, PS4 as interactive-only prompt variables. NOT supported in script mode. Purification removes all prompt variables and customization code. Script-mode-only philosophy: no prompts, no interactive input, fully automated execution."
              prompt_variables:
                - "PS1: Primary prompt (default: '$ ' or '# ' for root)"
                - "PS2: Continuation prompt for multi-line (default: '> ')"
                - "PS3: Prompt for select command (default: '#? ')"
                - "PS4: Debug trace prompt for set -x (default: '+ ')"
              why_not_supported:
                - "Interactive only (not used in scripts)"
                - "bashrs is script-mode-only (no interactive features)"
                - "POSIX sh scripts don't use prompts"
                - "Prompts displayed to users, not part of script logic"
              related_features:
                - "PROMPT_COMMAND (executed before each prompt)"
                - "PROMPT_DIRTRIM (directory name trimming in PS1)"
                - "PS0 (displayed after command read, before execution)"
              purification_strategy:
                - "Remove PS1, PS2, PS3, PS4 assignments"
                - "Remove prompt customization code"
                - "Scripts run non-interactively (no prompts displayed)"
              script_mode_characteristics:
                - "No prompts (PS1, PS2, PS3, PS4)"
                - "No user interaction (read, select)"
                - "Automated execution (no waiting for input)"
                - "Works in CI/CD, cron, Docker (no TTY)"

      - id: "5.2"
        name: "Bash Variables"
        tasks:
          - id: "BASH-VAR-001"
            title: "Document BASH_VERSION"
            status: "completed"
            version: "v6.6.0"
            priority: "LOW"
            input: "echo $BASH_VERSION"
            rust: "const VERSION: &str = \"1.0.0\";"
            purified: "Remove BASH_VERSION checks, use POSIX features only"
            test_name: "test_BASH_VAR_001_bash_version_not_supported"
            notes: "BASH_VERSION is Bash-specific variable, NOT SUPPORTED. 5 passing tests document BASH_VERSION as Bash-only, removal of version checks, BASH_VERSINFO array, portability philosophy, and purification strategy."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_BASH_VAR_001_bash_version_not_supported (passing)"
                - "test_BASH_VAR_001_remove_version_checks (passing)"
                - "test_BASH_VAR_001_bash_versinfo_not_supported (passing)"
                - "test_BASH_VAR_001_portability_over_version_detection (passing)"
                - "test_BASH_VAR_001_purification_removes_bash_version (passing)"
              lines_of_code: 269
              documentation: "Comprehensive documentation of BASH_VERSION and BASH_VERSINFO as Bash-specific variables. NOT POSIX-compliant. Purification removes version checks and version-dependent code paths. Philosophy: use POSIX features only, no version detection needed."
              why_not_supported:
                - "Bash-specific (not in dash, ash, busybox sh)"
                - "No POSIX equivalent"
                - "Script portability: should work regardless of shell version"
                - "Version checks violate POSIX-only policy"
              related_variables:
                - "BASH_VERSION (full version string)"
                - "BASH_VERSINFO (array with version components)"
                - "BASH_VERSINFO[0] (major version)"
                - "BASH_VERSINFO[1] (minor version)"
                - "BASH_VERSINFO[2] (patch version)"
              purification_strategy:
                - "Remove BASH_VERSION checks"
                - "Remove version-dependent code paths"
                - "Use only POSIX features (works everywhere)"
                - "Replace Bash-specific features with POSIX equivalents"
              philosophy:
                - "POSIX-only (no Bash-specific features)"
                - "No version detection (same code everywhere)"
                - "Maximum portability (works on minimal shells)"
                - "Simpler code (no version checks)"
                - "Better portability (works on any POSIX shell)"
                - "Fewer bugs (no version-specific code paths)"

          - id: "BASH-VAR-002"
            title: "Document RANDOM purification"
            status: "completed"
            priority: "HIGH"
            input: "num=$RANDOM; session_id=\"session-$RANDOM\"; for i in {1..10}; do echo $RANDOM; done"
            rust: "NOT MAPPED (use deterministic values); rand crate with explicit seed for PRNG; uuid for unique IDs"
            purified: "num=42; session_id=\"session-1.0.0\"; seq 1 10; awk -v seed=42 'BEGIN { srand(seed); print int(rand() * 32768) }'"
            test_name: "test_BASH_VAR_002_random_not_supported"
            notes: "$RANDOM is NOT SUPPORTED (bash-specific, HIGH priority purification). CRITICAL: $RANDOM is antithetical to bashrs philosophy - bashrs enforces DETERMINISM (same input MUST produce same output). $RANDOM violates: (1) Determinism (same script → different results), (2) Reproducibility (cannot replay execution), (3) Testing (flaky tests), (4) Security (weak PRNG, only 32,768 values), (5) Portability (bash/ksh/zsh only, not POSIX sh/dash/ash). WHY NOT SUPPORTED (5 reasons): Non-deterministic (different results each run), Bash-specific (not POSIX), Breaks reproducibility (cannot replay), Breaks testing (non-reproducible tests), Security risk (weak PRNG, predictable). PURIFICATION STRATEGIES (5): (1) Fixed seed for deterministic PRNG (awk with seed), (2) Sequence numbers (seq 1 10), (3) Version/timestamp-based identifiers (session-$VERSION), (4) Hash-based deterministic randomness (sha256sum), (5) /dev/urandom (LAST RESORT - non-deterministic, only for crypto). Common antipatterns (8): Random session IDs → version-based, Random temp files → mktemp, Random sleep delays → fixed delay, Random port selection → fixed or config, Random passwords → openssl rand, Random load balancing → deterministic algorithm, Random retry delays → exponential backoff, Random test data → fixed values. Determinism violations (5): Same script different results (cannot predict output), Cannot replay execution (if deployment fails cannot retry with same ID), Tests non-reproducible (cannot assert on value), Race conditions (collision if parallel scripts), Weak security (only 32,768 values, predictable). Portability issues (4): Not POSIX (bash-specific, undefined in dash/ash), Different ranges in different shells (bash/ksh/zsh all 0-32767 but implementations differ), Seed behavior differs (bash RANDOM=seed, ksh/zsh different), Subprocess behavior undefined (re-seed vs inherit). Security implications (5 CRITICAL risks): Weak PRNG (Linear Congruential Generator, predictable), Small range (only 32,768 values, brute-forceable in milliseconds), Predictable seed (based on PID/timestamp, guessable), Collision probability high (Birthday paradox: 50% collision after ~215 samples), Observable output leaks state (attacker can reconstruct PRNG). NEVER USE $RANDOM FOR: Passwords/tokens/API keys, Session IDs (unless collision acceptable), Cryptographic nonces, Security-critical randomness. SECURE ALTERNATIVES: /dev/urandom (crypto secure), openssl rand (crypto PRNG), /dev/random (blocks until entropy). Testing implications (4 issues): Non-reproducible tests (different release_id each run), Cannot assert on output (what value to assert?), Flaky tests (heisenbug - passes 99%, fails 1%), Cannot replay failures (bug only occurs with specific $RANDOM value). TESTING BEST PRACTICES: Never use $RANDOM in production code, Mock with fixed seed if testing RANDOM code, Use deterministic test data (fixed values), Property-based testing with seeds. Rust mapping: $RANDOM → NOT MAPPED (use deterministic values), PRNG needs → rand crate with explicit seed, Unique IDs → uuid/sequence numbers/version-based, Security → rand::rngs::OsRng (crypto secure). PURIFICATION RULES (6): $RANDOM → FORBIDDEN (rewrite script), Session IDs → version/timestamp-based, Temporary files → mktemp (POSIX), Test data → fixed values (42, 100, 1000), Crypto randomness → /dev/urandom or openssl rand, Need PRNG → awk with explicit seed (deterministic). Comprehensive comparison table: Bash (SUPPORTED, 0-32767, NON-DETERMINISTIC, flaky tests, WEAK security, bash/ksh only), POSIX (NOT AVAILABLE), Purified (FORBIDDEN, deterministic alternatives enforced, reproducible tests, crypto PRNG for security, POSIX awk). $RANDOM is CRYPTOGRAPHICALLY WEAK (never use for passwords/tokens/keys), makes tests FLAKY and NON-REPRODUCIBLE, NOT PORTABLE (bash/ksh/zsh only). bashrs STATUS: $RANDOM is FORBIDDEN (violates determinism core principle)."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_BASH_VAR_002_random_not_supported (passing)"
                - "test_BASH_VAR_002_random_purification_strategies (passing)"
                - "test_BASH_VAR_002_random_common_antipatterns (passing)"
                - "test_BASH_VAR_002_random_determinism_violations (passing)"
                - "test_BASH_VAR_002_random_portability_issues (passing)"
                - "test_BASH_VAR_002_random_security_implications (passing)"
                - "test_BASH_VAR_002_random_testing_implications (passing)"
                - "test_BASH_VAR_002_random_comparison_table (passing)"
              lines_of_code: 752
            version: "v6.6.0"

          - id: "BASH-VAR-003"
            title: "Document SECONDS purification"
            status: "completed"
            priority: "MEDIUM"
            input: "SECONDS=0; operation; echo \"Took $SECONDS seconds\"; start=$SECONDS; while [ $((SECONDS - start)) -lt 60 ]; do sleep 1; done"
            rust: "NOT MAPPED (use deterministic values); Remove timing logic or use attempt counters"
            purified: "operation; echo \"Operation completed\"; attempts=0; max_attempts=60; while [ $attempts -lt $max_attempts ]; do sleep 1; attempts=$((attempts + 1)); done"
            test_name: "test_BASH_VAR_003_seconds_not_supported"
            notes: "$SECONDS is NOT SUPPORTED (bash-specific, MEDIUM priority purification). $SECONDS tracks seconds since shell started. WHY NOT SUPPORTED (5 reasons): Non-deterministic (different value each run), Time-dependent (depends on execution speed), Bash-specific (not POSIX), Breaks reproducibility (cannot replay with same timing), Breaks testing (flaky tests). PURIFICATION STRATEGIES (4): (1) Fixed durations (duration=100), (2) Explicit timestamp arithmetic (start=1640000000; end=1640000100; elapsed=$((end-start))), (3) Remove timing logic entirely (echo \"Operation completed\"), (4) External time source (duration=$(cat config/duration.txt)). Common antipatterns (6): Performance measurement → external tool (hyperfine), Timeouts → attempt counters, Log timestamps → fixed format, Rate limiting → fixed intervals, Progress indicators → work-based progress, Execution time reporting → remove timing. Determinism violations (4): Time-dependent output (fast vs slow machine different results), Cannot replay execution (same timing impossible), Tests non-reproducible (flaky performance assertions), Timing race conditions (service start times vary). Portability issues (3): Not POSIX (bash-specific, undefined in dash/ash), Reset behavior differs (bash SECONDS=0 resets, dash just sets variable), Precision varies (bash integer seconds, some shells subsecond). Testing implications (4 critical issues): Non-reproducible tests (SECONDS=0; operation; [ $SECONDS -lt 10 ] flaky!), Cannot assert on output (timing varies), Flaky tests (passes on fast machine, fails on slow), Cannot replay failures (timing-dependent bugs). TESTING BEST PRACTICES: Never use $SECONDS in production code, Use attempt counters instead of timers, Remove timing assertions from tests, Use deterministic test data. Rust mapping: $SECONDS → NOT MAPPED (use deterministic values), Timing needs → remove or use fixed durations, Timeouts → attempt counters (deterministic), Benchmarks → external tools (hyperfine, criterion). PURIFICATION RULES (6): $SECONDS → FORBIDDEN (rewrite script), Timeouts → max_attempts counter, Benchmarks → external tools or remove, Progress indicators → work-based (items processed), Log timestamps → remove or fixed format, Performance assertions → remove from tests. Comprehensive comparison table: Bash ($SECONDS SUPPORTED, timer, NON-DETERMINISTIC, flaky tests, bash/ksh only), POSIX (NOT AVAILABLE), Purified (FORBIDDEN, deterministic alternatives enforced, reproducible tests, POSIX counters). $SECONDS makes tests FLAKY and NON-REPRODUCIBLE (depends on execution speed). bashrs STATUS: $SECONDS is FORBIDDEN (violates determinism - execution time should not affect output)."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_BASH_VAR_003_seconds_not_supported (passing)"
                - "test_BASH_VAR_003_seconds_purification_strategies (passing)"
                - "test_BASH_VAR_003_seconds_common_antipatterns (passing)"
                - "test_BASH_VAR_003_seconds_determinism_violations (passing)"
                - "test_BASH_VAR_003_seconds_portability_issues (passing)"
                - "test_BASH_VAR_003_seconds_testing_implications (passing)"
                - "test_BASH_VAR_003_seconds_comparison_table (passing)"
              lines_of_code: 666
            version: "v6.6.0"

  - id: 6
    name: "Bash Features"
    sections:
      - id: "6.1"
        name: "Arrays"
        tasks:
          - id: "ARRAY-001"
            title: "Document indexed arrays"
            status: "completed"
            priority: "MEDIUM"
            input: "arr=(1 2 3); echo ${arr[0]}"
            rust: "let arr = vec![1, 2, 3]; println!(\"{}\", arr[0]);"
            purified: "Use whitespace-separated strings (POSIX sh has no arrays)"
            test_name: "test_ARRAY_001_indexed_arrays"
            notes: "Basic identifier parsing supported. Full array syntax is bash-specific and not supported in POSIX sh."

          - id: "ARRAY-002"
            title: "Document associative arrays"
            status: "completed"
            version: "v6.6.0"
            priority: "LOW"
            input: "declare -A map; map[key]=value; ${map[key]}; ${!map[@]}; ${map[@]}"
            rust: "let mut map = HashMap::new(); map.insert(\"key\", \"value\");"
            purified: "config_host=\"localhost\"; config_port=\"8080\" # Separate variables instead"
            test_name: "test_ARRAY_002_associative_arrays_not_supported"
            notes: "Associative arrays (hash maps) introduced in Bash 4.0 (2009), NOT SUPPORTED (Bash extension, not POSIX). declare -A creates associative array, map[key]=value sets value for key, ${map[key]} retrieves value, ${!map[@]} gets all keys, ${map[@]} gets all values. Bash 4.0+ only (macOS ships with 3.2), not available in sh/dash/ash. Purification uses separate variables (config_host, config_port pattern), indexed arrays with key:value parsing, or case statements for lookups. Use cases: config management, counters/histograms, key-value lookups, caching - all have POSIX alternatives."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_ARRAY_002_associative_arrays_not_supported (passing)"
                - "test_ARRAY_002_declare_uppercase_a (passing)"
                - "test_ARRAY_002_associative_array_operations (passing)"
                - "test_ARRAY_002_purification_uses_separate_variables (passing)"
                - "test_ARRAY_002_indexed_array_alternative (passing)"
                - "test_ARRAY_002_bash_version_compatibility (passing)"
                - "test_ARRAY_002_use_cases_and_alternatives (passing)"
                - "test_ARRAY_002_bash_vs_posix_arrays (passing)"
              lines_of_code: 442

      - id: "6.2"
        name: "The Directory Stack (pushd/popd)"
        tasks:
          - id: "DIRSTACK-001"
            title: "Document pushd/popd"
            status: "completed"
            version: "v6.6.0"
            priority: "LOW"
            input: "pushd /tmp, popd, dirs, dirs -v, pushd +N, DIRSTACK"
            rust: "Not supported (use explicit cd tracking)"
            purified: "_prev_dir=\"$(pwd)\"; cd /tmp || exit 1; cd \"$_prev_dir\" || exit 1"
            test_name: "test_DIRSTACK_001_pushd_not_supported"
            notes: "pushd/popd maintain directory stack for navigation, NOT SUPPORTED (implicit state). 8 passing tests document pushd command (push directory onto stack and cd), popd command (pop directory from stack and cd), dirs command (display directory stack with -c/-l/-p/-v options), purification uses explicit cd (save/restore with variables + error checking), pushd/popd options (swap/rotate stack), DIRSTACK variable (Bash-specific read-only array), cd - alternative (POSIX-compliant using OLDPWD), and interactive vs script directory navigation (implicit stack vs explicit variables)."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_DIRSTACK_001_pushd_not_supported (passing)"
                - "test_DIRSTACK_001_popd_not_supported (passing)"
                - "test_DIRSTACK_001_dirs_command (passing)"
                - "test_DIRSTACK_001_purification_uses_explicit_cd (passing)"
                - "test_DIRSTACK_001_pushd_popd_options (passing)"
                - "test_DIRSTACK_001_dirstack_variable (passing)"
                - "test_DIRSTACK_001_cd_minus_alternative (passing)"
                - "test_DIRSTACK_001_interactive_vs_script_directory_navigation (passing)"
              lines_of_code: 385

      - id: "6.3"
        name: "Controlling the Prompt"
        tasks:
          - id: "PROMPT-001"
            title: "Document PROMPT_COMMAND"
            status: "completed"
            version: "v6.6.0"
            priority: "LOW"
            input: "PROMPT_COMMAND='date', PROMPT_COMMAND=('cmd1' 'cmd2' 'cmd3')"
            rust: "Not applicable (no interactive mode)"
            purified: "Remove all PROMPT_COMMAND assignments (not needed in script mode)"
            test_name: "test_PROMPT_001_prompt_command_not_supported"
            notes: "PROMPT_COMMAND is interactive-only hook executed before each PS1 prompt, NOT SUPPORTED. 6 passing tests document basic form, array form (Bash 4.4+), purification strategy, common patterns (window title, git status, timing, history), script alternatives (explicit timing/logging), and interactive vs script mode hooks (PROMPT_COMMAND vs EXIT trap)."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_PROMPT_001_prompt_command_not_supported (passing)"
                - "test_PROMPT_001_prompt_command_array_form (passing)"
                - "test_PROMPT_001_purification_removes_prompt_command (passing)"
                - "test_PROMPT_001_common_prompt_command_patterns (passing)"
                - "test_PROMPT_001_script_alternatives_to_prompt_command (passing)"
                - "test_PROMPT_001_interactive_vs_script_mode_hooks (passing)"
              lines_of_code: 291

  - id: 7
    name: "Job Control"
    tasks:
      - id: "JOB-001"
        title: "Document background jobs (&)"
        status: "completed"
        priority: "HIGH"
        input: "cmd &"
        rust: "run_foreground()"
        purified: "run_foreground"
        test_name: "test_JOB_001_background_jobs_not_supported"
        notes: "Background jobs NOT SUPPORTED (violates determinism). 6 comprehensive tests (563 LOC) document race conditions, purification strategies, testing implications. Convert to foreground execution (RECOMMENDED) or sequential execution. Job control is OPTIONAL in POSIX."
        red_phase_tests: "rash/src/bash_parser/tests.rs:21189-21752"
        version: "v6.6.0"

      - id: "JOB-002"
        title: "Document jobs command"
        status: "completed"
        version: "v6.6.0"
        priority: "LOW"
        input: "jobs, jobs -l, jobs -r, jobs -s"
        rust: "Not supported (no job control)"
        purified: "Remove (scripts run foreground only)"
        test_name: "test_JOB_002_jobs_command_not_supported"
        notes: "jobs command lists background jobs, NOT SUPPORTED (interactive job control). 6 passing tests document basic usage, output format (job number, status, command), purification strategy, job control requirements (TTY, set -m, signals), script alternatives (sequential execution, ps, wait), and interactive vs script job control (jobs/fg/bg vs wait/ps/kill)."
        implementation:
          module: "rash/src/bash_parser/tests.rs"
          functions:
            - "test_JOB_002_jobs_command_not_supported (passing)"
            - "test_JOB_002_jobs_command_output_format (passing)"
            - "test_JOB_002_purification_removes_jobs (passing)"
            - "test_JOB_002_job_control_requirements (passing)"
            - "test_JOB_002_script_alternatives_to_jobs (passing)"
            - "test_JOB_002_interactive_vs_script_job_control (passing)"
          lines_of_code: 309

      - id: "JOB-003"
        title: "Document fg/bg commands"
        status: "completed"
        version: "v6.6.0"
        priority: "LOW"
        input: "fg %1, bg %1, fg %sleep, fg %%, fg %+, fg %-"
        rust: "Not supported (no job control)"
        purified: "Remove (scripts run foreground only, no job state management)"
        test_name: "test_JOB_003_fg_command_not_supported"
        notes: "fg (foreground) and bg (background) commands manage job execution state, NOT SUPPORTED (interactive job control). 7 passing tests document fg command syntax, bg command syntax, job specifications (%n/%string/%%/%+/%-), purification removes fg/bg, interactive fg/bg workflow (suspend/resume), script alternatives (sequential execution), and interactive vs script execution models (multi-job switching vs single-job sequential)."
        implementation:
          module: "rash/src/bash_parser/tests.rs"
          functions:
            - "test_JOB_003_fg_command_not_supported (passing)"
            - "test_JOB_003_bg_command_not_supported (passing)"
            - "test_JOB_003_job_specifications (passing)"
            - "test_JOB_003_purification_removes_fg_bg (passing)"
            - "test_JOB_003_fg_bg_workflow (passing)"
            - "test_JOB_003_script_alternatives_to_fg_bg (passing)"
            - "test_JOB_003_interactive_vs_script_execution_model (passing)"
          lines_of_code: 368

  - id: 8
    name: "Command Line Editing"
    tasks:
      - id: "EDIT-001"
        title: "Document readline features"
        status: "completed"
        version: "v6.6.0"
        priority: "LOW"
        input: "Ctrl+A, Ctrl+E, Ctrl+K, set -o emacs, set -o vi, bind, Tab completion"
        rust: "Not applicable (no interactive mode)"
        purified: "Not applicable (scripts execute commands directly without readline)"
        test_name: "test_EDIT_001_readline_not_supported"
        notes: "Readline provides interactive line editing, NOT SUPPORTED (interactive only). 7 passing tests document keyboard shortcuts (movement/editing/history/completion), Emacs/Vi editing modes (set -o emacs/vi), tab completion (command/file/variable/hostname/programmable), bind command (key bindings), history navigation (Up/Down/Ctrl+R), readline configuration (~/.inputrc), and interactive vs script input models (user types + readline edits vs predefined commands)."
        implementation:
          module: "rash/src/bash_parser/tests.rs"
          functions:
            - "test_EDIT_001_readline_not_supported (passing)"
            - "test_EDIT_001_emacs_vi_modes (passing)"
            - "test_EDIT_001_tab_completion (passing)"
            - "test_EDIT_001_bind_command (passing)"
            - "test_EDIT_001_history_navigation (passing)"
            - "test_EDIT_001_readline_configuration (passing)"
            - "test_EDIT_001_interactive_vs_script_input_model (passing)"
          lines_of_code: 350

  - id: 9
    name: "Using History Interactively"
    tasks:
      - id: "HISTORY-001"
        title: "Document history expansion"
        status: "completed"
        version: "v6.6.0"
        priority: "LOW"
        input: "!!, !$, !^, !*, !:n, !string, !?string, history, fc, HISTFILE"
        rust: "Not applicable (no interactive mode)"
        purified: "Remove (non-deterministic, use explicit variables instead)"
        test_name: "test_HISTORY_001_bang_bang_not_supported"
        notes: "History expansion allows referencing previous commands with ! (bang) notation, NOT SUPPORTED (interactive, non-deterministic). 8 passing tests document !! (repeat last), !$ (last argument), history expansion syntax (event designators/word designators/modifiers), purification removes history expansion (use explicit variables), history command (interactive management), fc command (fix command editing), history variables (HISTFILE/HISTSIZE/HISTCONTROL/HISTIGNORE), and interactive vs script history models (persistent history buffer vs stateless execution)."
        implementation:
          module: "rash/src/bash_parser/tests.rs"
          functions:
            - "test_HISTORY_001_bang_bang_not_supported (passing)"
            - "test_HISTORY_001_bang_dollar_not_supported (passing)"
            - "test_HISTORY_001_history_expansion_syntax (passing)"
            - "test_HISTORY_001_purification_removes_history_expansion (passing)"
            - "test_HISTORY_001_history_command (passing)"
            - "test_HISTORY_001_fc_command (passing)"
            - "test_HISTORY_001_history_variables (passing)"
            - "test_HISTORY_001_interactive_vs_script_history_model (passing)"
          lines_of_code: 413

completed_features:
  - title: "Shebang transformation (#!/bin/bash → #!/bin/sh)"
    version: "v1.3.0"
    tasks: ["1.1"]
    tests: 3
    methodology: "EXTREME TDD + Property Testing"

  - title: "Until loop transformation (until → while !)"
    version: "v1.3.0"
    tasks: ["LOOP-001"]
    tests: 4
    methodology: "EXTREME TDD + Property Testing"

  - title: "Default value expansion (${VAR:-default})"
    version: "v1.3.0"
    tasks: ["EXP-PARAM-001"]
    tests: 4
    methodology: "EXTREME TDD + Property Testing"

  - title: "Assign default expansion (${VAR:=default})"
    version: "v1.3.0"
    tasks: ["EXP-PARAM-002"]
    tests: 4
    methodology: "EXTREME TDD + Property Testing"

  - title: "Glob pattern transformation (*.txt, *.log, etc.)"
    version: "v1.3.0"
    tasks: ["EXP-GLOB-001"]
    tests: 4
    methodology: "EXTREME TDD + Property Testing"

  - title: "Error-if-unset expansion (${VAR:?message})"
    version: "v1.3.0"
    tasks: ["EXP-PARAM-003"]
    tests: 4
    methodology: "EXTREME TDD + Property Testing"

  - title: "Alternative value expansion (${VAR:+alt_value})"
    version: "v1.3.0"
    tasks: ["EXP-PARAM-004"]
    tests: 4
    methodology: "EXTREME TDD + Property Testing"

  - title: "String length expansion (${#VAR})"
    version: "v1.3.0"
    tasks: ["EXP-PARAM-005"]
    tests: 4
    methodology: "EXTREME TDD + Property Testing"

  - title: "Remove suffix expansion (${VAR%pattern})"
    version: "v1.3.0"
    tasks: ["EXP-PARAM-006"]
    tests: 4
    methodology: "EXTREME TDD + Property Testing"

  - title: "Remove prefix expansion (${VAR#pattern})"
    version: "v1.3.0"
    tasks: ["EXP-PARAM-007"]
    tests: 4
    methodology: "EXTREME TDD + Property Testing"

  - title: "Remove longest prefix expansion (${VAR##pattern})"
    version: "v1.3.0"
    tasks: ["EXP-PARAM-008"]
    tests: 4
    methodology: "EXTREME TDD + Property Testing"

  - title: "Remove longest suffix expansion (${VAR%%pattern})"
    version: "v1.3.0"
    tasks: ["EXP-PARAM-009"]
    tests: 4
    methodology: "EXTREME TDD + Property Testing"

  - title: "While loops"
    version: "v0.8.0"
    tasks: ["LOOP-002"]

  - title: "For loops"
    version: "v0.5.0"
    tasks: ["LOOP-003"]

  - title: "If/else statements"
    version: "v0.4.0"
    tasks: ["COND-001"]

  - title: "Case/match statements"
    version: "v0.6.0"
    tasks: ["COND-002"]

  - title: "Functions"
    version: "v0.4.0"
    tasks: ["FUNC-001"]

  - title: "Return values"
    version: "v0.4.0"
    tasks: ["FUNC-002"]

  - title: "Command substitution"
    version: "v0.4.0"
    tasks: ["EXP-CMD-001"]

  - title: "Arithmetic expansion"
    version: "v0.4.0"
    tasks: ["EXP-ARITH-001"]

  - title: "Break/continue"
    version: "v0.8.0"
    tasks: ["BUILTIN-003", "BUILTIN-004"]

  - title: "Echo transformation"
    version: "v0.4.0"
    tasks: ["BUILTIN-006"]

high_priority_next_tasks:
  description: "Next 20 tasks to implement"
  tasks:
    - id: "PARAM-POS-001"
      title: "Positional parameters ($1, $2)"
      priority: 1
      status: "🔴 BLOCKED - P0 (deferred to v1.3.0)"

    - id: "PARAM-SPEC-001"
      title: "Special parameter $#"
      priority: 2
      status: "🔴 BLOCKED - P0 (deferred to v1.3.0)"

    - id: "PARAM-SPEC-002"
      title: "Special parameter $?"
      priority: 3

    - id: "EXP-PARAM-001"
      title: "String parameter expansion (${var:-default})"
      priority: 4

    - id: "REDIR-001"
      title: "Input redirection (<)"
      priority: 5

    - id: "REDIR-002"
      title: "Output redirection (>, >>)"
      priority: 6

    - id: "REDIR-003"
      title: "Combined redirection (&>)"
      priority: 7

    - id: "REDIR-004"
      title: "Here documents (<<)"
      priority: 8

    - id: "BUILTIN-005"
      title: "cd command"
      priority: 9

    - id: "BUILTIN-011"
      title: "pwd command"
      priority: 10

    - id: "BUILTIN-009"
      title: "exit command"
      priority: 11

    - id: "BUILTIN-010"
      title: "export command"
      priority: 12

    - id: "BUILTIN-020"
      title: "unset command"
      priority: 13

    - id: "BUILTIN-016"
      title: "test/[ command"
      priority: 14

    - id: "BASH-BUILTIN-005"
      title: "printf preservation"
      priority: 15

    - id: "VAR-001"
      title: "PATH variable"
      priority: 16

    - id: "VAR-002"
      title: "HOME variable"
      priority: 17

    - id: "EXP-PARAM-005"
      title: "String length ${#var}"
      priority: 18

    - id: "EXP-PARAM-006"
      title: "Remove suffix ${var%suffix}"
      priority: 19

    - id: "BASH-VAR-002"
      title: "Remove RANDOM (non-deterministic)"
      priority: 20

next_steps:
  - "Start with high priority tasks (positional parameters, special vars)"
  - "Follow EXTREME TDD religiously (test-first, always)"
  - "Document each transformation with examples"
  - "Track progress in this roadmap (update task status)"
  - "Release incrementally (v1.3.0, v1.4.0, etc.)"

status:
  overall: "IN_PROGRESS"
  completion_percent: 20
  completed_tasks: 24
  partial_support_tasks: 16
  blocked_tasks: 3
  pending_tasks: 79
  total_tasks: 122
  methodology: "EXTREME TDD (RED-GREEN-REFACTOR) + Property Testing"
  goal: "100% Bash manual coverage"
  accuracy_verified: "2025-10-26"
  last_completed:
    task_id: "EXP-PARAM-009"
    title: "Remove longest suffix expansion (${VAR%%pattern})"
    version: "v1.3.0"
    date: "2025-10-15"
