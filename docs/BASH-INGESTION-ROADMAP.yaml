---
roadmap:
  title: "Bash Ingestion Roadmap - EXTREME TDD"
  goal: "Document every Bash construct transformation to Rust and Purified Bash"
  methodology: "EXTREME TDD (Test-First, RED-GREEN-REFACTOR)"
  reference: "GNU Bash Manual (bash.pdf)"
  status: "IN_PROGRESS"
  completion: "20%"

  statistics:
    total_tasks: 122
    completed: 57
    partial_support: 13
    pending: 49
    blocked: 3
    coverage_percent: 47
    accuracy_verified: "2025-10-27"
    session_update: "Completed REDIR-003 (3.6 - combined redirection &>). 8 passing tests document combined redirection (&>, >&, &>>) as Bash extensions, NOT SUPPORTED. POSIX equivalent > file 2>&1 is FULLY SUPPORTED. Bash &> syntax: cmd &> output.txt redirects both stdout and stderr to same file (Bash 4.0+ shortcut). csh-style >& syntax: cmd >& output.txt (same as &>, Bash/csh extension). Append combined &>>: cmd &>> log.txt (Bash extension for >> file 2>&1). POSIX equivalent (SUPPORTED): cmd > output.txt 2>&1 (explicit redirection). Purification strategy: convert &> file → > file 2>&1, >& file → > file 2>&1, &>> file → >> file 2>&1. Order matters in POSIX: > file 2>&1 (CORRECT: stdout to file first, then stderr to stdout which points to file), 2>&1 > file (WRONG: stderr to terminal, stdout to file). Always put > file BEFORE 2>&1. Common use cases (5): capture all output (cmd > output.txt 2>&1), append to log (cmd >> app.log 2>&1), discard all (cmd > /dev/null 2>&1), capture in variable (output=$(cmd 2>&1)), log with timestamp ((date; cmd) > log.txt 2>&1). Why order matters: first redirection happens first, second uses new fd state (> file changes fd 1, then 2>&1 duplicates fd 2 to new fd 1 location). Bash extensions NOT SUPPORTED: &> file, >& file, &>> file. POSIX combined redirection SUPPORTED: > file 2>&1, >> file 2>&1. Total tests: 4,917 (100% passing)."

extreme_tdd_workflow:
  description: "Hybrid workflow combining GNU Bash validation with REPL verification"
  methodology: "EXTREME TDD + Interactive REPL Validation"
  updated: "2025-10-26"

  steps:
    - id: 1
      name: "RED"
      description: "Write failing test first"
      example: |
        #[test]
        fn test_<TASK_ID>_<feature>_<scenario>() {
            let bash = "<bash input>";
            let rust = "<expected rust>";
            let purified = "<expected purified bash>";

            assert_eq!(bash_to_rust(bash), rust);
            assert_eq!(bash_to_purified(bash), purified);
        }

    - id: 2
      name: "GREEN"
      description: "Implement transformation"
      substeps:
        - "Update parser for bash construct"
        - "Update Rust AST generation"
        - "Update purified bash emission"

    - id: 3
      name: "REFACTOR"
      description: "Clean up implementation"
      substeps:
        - "Extract common patterns"
        - "Add helper functions"
        - "Document edge cases"

    - id: 4
      name: "REPL VERIFICATION"
      description: "Validate feature interactively in REPL"
      substeps:
        - "Run `bashrs repl` and test bash construct manually"
        - "Verify expected behavior matches specification"
        - "Test edge cases interactively"
        - "Document any REPL-specific issues discovered"
      example: |
        $ bashrs repl
        bashrs> x=5
        bashrs> echo $x
        5
        bashrs> echo ${x:-default}
        5
        bashrs> echo ${unset:-fallback}
        fallback
      notes: "Interactive validation catches integration issues that unit tests miss"

    - id: 5
      name: "PROPERTY TESTING"
      description: "Add property-based tests"
      substeps:
        - "Create proptest with 100+ generated cases"
        - "Verify determinism property"
        - "Verify idempotency property"

    - id: 6
      name: "MUTATION TESTING"
      description: "Verify test quality"
      substeps:
        - "Run cargo-mutants on modified files"
        - "Target ≥90% mutation kill rate"
        - "Fix surviving mutants"

    - id: 7
      name: "PMAT VERIFICATION"
      description: "Verify with paiml-mcp-agent-toolkit quality analysis"
      substeps:
        - "Run `pmat analyze complexity --max 10` to verify code complexity"
        - "Run `pmat quality-score --min 9.0` to verify overall quality"
        - "Run `pmat verify --spec rash.spec --impl target/debug/bashrs` if applicable"
        - "Address any quality issues detected"
      example: |
        $ pmat analyze complexity --max 10
        ✅ All functions below complexity 10

        $ pmat quality-score --min 9.0
        ✅ Quality score: 9.5/10
      notes: "pmat provides additional quality verification beyond standard tooling"

    - id: 8
      name: "DOCUMENT"
      description: "Update documentation"
      substeps:
        - "Update this roadmap YAML file"
        - "Mark task as 'completed'"
        - "Add implementation details"
        - "Add REPL verification notes"
        - "Add pmat verification results"
        - "Update CHANGELOG.md"

cli_testing_protocol:
  description: "MANDATORY CLI testing patterns using assert_cmd"
  requirement: "All CLI tests MUST use assert_cmd crate"

  test_naming_convention:
    format: "test_<TASK_ID>_<feature>_<scenario>"
    examples:
      - "test_PARAM_POS_001_positional_params_basic"
      - "test_EXP_PARAM_009_remove_longest_suffix_cli"
      - "test_LOOP_001_until_loop_cli_output"
    rationale: "Enables traceability to roadmap tasks"

  assert_cmd_pattern:
    mandatory: true
    never_use: "std::process::Command for CLI testing"
    helper_function: |
      use assert_cmd::Command;
      use predicates::prelude::*;

      fn rash_cmd() -> Command {
          Command::cargo_bin("rash")
              .expect("Failed to find rash binary")
      }

    basic_test_example: |
      #[test]
      fn test_PARSE_001_parse_basic_bash() {
          rash_cmd()
              .arg("parse")
              .arg("examples/hello.sh")
              .assert()
              .success()
              .stdout(predicate::str::contains("AST"));
      }

    error_handling_example: |
      #[test]
      fn test_PARSE_001_invalid_file_error() {
          rash_cmd()
              .arg("parse")
              .arg("nonexistent.sh")
              .assert()
              .failure()
              .stderr(predicate::str::contains("Error"));
      }

  tool_validation_protocol:
    description: "Test each feature with all relevant Rash CLI tools"
    core_tools:
      - tool: "rash parse <file>"
        purpose: "Parse bash/Makefile to AST"
        test_requirement: "MANDATORY for all features"

      - tool: "rash purify <file>"
        purpose: "Purify bash/Makefile"
        test_requirement: "MANDATORY for purification features"

      - tool: "rash transpile <file>"
        purpose: "Transpile Rust to shell"
        test_requirement: "MANDATORY for transpilation features"

      - tool: "rash lint <file>"
        purpose: "Lint bash/Makefile"
        test_requirement: "MANDATORY for linting features"

      - tool: "rash check <file>"
        purpose: "Type-check and validate"
        test_requirement: "MANDATORY for type-checking features"

    quality_tools:
      - tool: "rash ast <file>"
        purpose: "Output AST in JSON"
        test_requirement: "Recommended for debugging"

      - tool: "rash analyze <file>"
        purpose: "Analyze complexity and safety"
        test_requirement: "Recommended for production features"

  integration_test_pattern:
    description: "End-to-end CLI workflow testing"
    example: |
      #[test]
      fn test_integration_bash_to_purified() {
          let messy = "tests/fixtures/messy_deploy.sh";
          std::fs::write(messy, "SESSION_ID=$RANDOM").unwrap();

          // Step 1: Parse succeeds
          rash_cmd().arg("parse").arg(messy).assert().success();

          // Step 2: Purify produces deterministic output
          let purified = "tests/fixtures/purified_deploy.sh";
          rash_cmd()
              .arg("purify")
              .arg(messy)
              .arg("--output")
              .arg(purified)
              .assert()
              .success();

          // Step 3: Verify content
          let content = std::fs::read_to_string(purified).unwrap();
          assert!(!content.contains("$RANDOM"));

          // Step 4: Shellcheck validation
          Command::new("shellcheck")
              .arg("-s").arg("sh")
              .arg(purified)
              .assert()
              .success();

          // Cleanup
          let _ = std::fs::remove_file(messy);
          let _ = std::fs::remove_file(purified);
      }

  quality_gates:
    description: "CLI testing quality gates (all must pass)"
    requirements:
      - name: "assert_cmd usage"
        requirement: "All CLI tests use assert_cmd::Command"
        failure_severity: "QUALITY DEFECT"

      - name: "Test naming"
        requirement: "All tests follow test_<TASK_ID>_<feature>_<scenario>"
        failure_severity: "TRACEABILITY ISSUE"

      - name: "Tool validation"
        requirement: "Feature tested with all relevant CLI tools"
        failure_severity: "INCOMPLETE TESTING"

      - name: "Success cases"
        requirement: "Happy path tests pass"
        failure_severity: "FEATURE BROKEN"

      - name: "Error cases"
        requirement: "Error handling tests pass"
        failure_severity: "POOR ERROR HANDLING"

      - name: "Edge cases"
        requirement: "Boundary conditions tested"
        failure_severity: "INCOMPLETE COVERAGE"

      - name: "Property tests"
        requirement: "100+ generated cases pass"
        failure_severity: "INSUFFICIENT TESTING"

      - name: "Mutation tests"
        requirement: "≥90% kill rate"
        failure_severity: "WEAK TESTS"

      - name: "Integration tests"
        requirement: "End-to-end workflows verified"
        failure_severity: "NO E2E COVERAGE"

      - name: "Documentation"
        requirement: "CLI usage documented"
        failure_severity: "POOR UX"

chapters:
  - id: 1
    name: "Introduction"
    tasks:
      - id: "1.1"
        title: "Document bash shebang transformation"
        status: "completed"
        version: "v1.3.0"
        input: "#!/bin/bash"
        rust: "fn main() {}"
        purified: "#!/bin/sh"
        test_name: "test_shebang_transformation"
        tests_added:
          - "test_shebang_transformation (unit test)"
          - "prop_purified_bash_uses_posix_shebang (property test, 100 cases)"
          - "prop_purified_bash_preserves_commands (property test, 100 cases)"
        notes: "POSIX sh shebang always generated in purified output. Verified with EXTREME TDD: RED->GREEN->REFACTOR->PROPERTY TESTING."
        implementation:
          module: "rash/src/bash_parser/generators.rs"
          function: "generate_purified_bash()"
          lines_of_code: 170

      - id: "1.2"
        title: "Document interactive vs script mode"
        status: "completed"
        version: "v6.6.0"
        input: "Interactive bash session (read, select, TTY detection)"
        rust: "Not applicable (compile-time only)"
        purified: "Script mode only (deterministic, command-line args)"
        test_name: "test_TASK_1_2_script_mode_only_philosophy"
        notes: "bashrs supports SCRIPT MODE ONLY (deterministic, non-interactive). 4 passing tests document philosophy, unsupported features, transformation strategy, and automation requirements."
        implementation:
          module: "rash/src/bash_parser/tests.rs"
          functions:
            - "test_TASK_1_2_script_mode_only_philosophy (passing)"
            - "test_TASK_1_2_interactive_mode_not_supported (passing)"
            - "test_TASK_1_2_deterministic_script_transformation (passing)"
            - "test_TASK_1_2_automation_friendly_design (passing)"
          lines_of_code: 214
          documentation: "Comprehensive documentation of bashrs script-mode-only philosophy. Interactive features NOT SUPPORTED (read, select, TTY). Transformation strategy: read → command-line args, deterministic execution, automation-friendly design."
          philosophy:
            - "Script mode only - no interactive features"
            - "Fully deterministic (same input → same output)"
            - "Automation-friendly (works in CI/CD, Docker, cron)"
            - "Testable (no human interaction required)"
          unsupported_features:
            - "read command (use command-line args instead)"
            - "select menus (use config files or case statements)"
            - "TTY detection (assume non-TTY always)"
            - "History navigation (use git for versioning)"
            - "Tab completion (use IDE/editor)"
          supported_features:
            - "Functions, variables, control flow"
            - "File I/O, process execution"
            - "Command-line argument parsing ($1, $2, $@)"
            - "Environment variables"
            - "Exit codes, error handling"
          transformation_strategy:
            - "read var → var=\"$1\" (command-line args)"
            - "select → case statement with $1"
            - "TTY checks → assume batch mode"
          priority: "HIGH"

  - id: 2
    name: "Definitions"
    tasks:
      - id: "2.1"
        title: "Document POSIX-only constructs"
        status: "completed"
        version: "v6.6.0"
        input: "Bash-specific syntax ([[ ]], let, $'...', &>, arrays, etc.)"
        rust: "Standard Rust constructs"
        purified: "POSIX sh syntax only (#!/bin/sh, [ ], $((...)), printf, case)"
        test_name: "test_TASK_2_1_posix_only_purification_policy"
        notes: "bashrs purification policy: OUTPUT POSIX SH ONLY. 5 passing tests document POSIX-only policy, Bash extensions NOT generated, POSIX constructs always used, portability across shells, and quality gates."
        implementation:
          module: "rash/src/bash_parser/tests.rs"
          functions:
            - "test_TASK_2_1_posix_only_purification_policy (passing)"
            - "test_TASK_2_1_bash_extensions_not_generated (passing)"
            - "test_TASK_2_1_posix_constructs_always_generated (passing)"
            - "test_TASK_2_1_portability_across_shells (passing)"
            - "test_TASK_2_1_purification_quality_gates (passing)"
          lines_of_code: 319
          documentation: "Comprehensive documentation of bashrs POSIX-only purification policy. Bash extensions NEVER generated ([[ ]], let, $'...', &>, (( )), arrays, <(...), {1..10}). POSIX constructs ALWAYS generated (#!/bin/sh, [ ], $((...)), printf, case, quoted variables). Quality gates for all purified scripts."
          bash_extensions_not_generated:
            - "[[ ]] → [ ] (POSIX single brackets)"
            - "$'...' → printf with format strings"
            - "let → $((...)) (POSIX arithmetic)"
            - "&> → >file 2>&1 (POSIX redirection)"
            - "[[ =~ ]] → case or grep"
            - "(( )) → $((...)) (POSIX arithmetic)"
            - "declare -a arrays → positional parameters or multiple variables"
            - "<(...) → temporary files with mktemp"
            - "{1..10} → seq 1 10 or explicit list"
          posix_constructs_always_generated:
            - "#!/bin/sh (not #!/bin/bash)"
            - "[ ] for conditionals (not [[ ]])"
            - "$((...)) for arithmetic"
            - "printf (not echo)"
            - "case statements (not [[ =~ ]])"
            - "Quoted variables: \"$VAR\" (not $VAR)"
            - ">file 2>&1 (not &>)"
            - "$(...) command substitution (not `...`)"
            - "[ \"$x\" = \"$y\" ] (not ==)"
          portability:
            - "Works on: dash, ash, busybox sh, bash, zsh, ksh, pdksh"
            - "Tested on: dash (Debian/Ubuntu), ash (Alpine), busybox sh (containers)"
            - "Standards: IEEE Std 1003.1-2001 compliant"
          quality_gates:
            - "shellcheck -s sh (POSIX compliance check)"
            - "dash -n (syntax validation)"
            - "busybox sh (minimal shell execution)"
            - "All variables quoted (\"$VAR\" not $VAR)"
            - "No Bash-specific patterns"
            - "Determinism (no $RANDOM, timestamps, $$)"
            - "Idempotency (mkdir -p, rm -f, ln -sf)"
          priority: "HIGH"

  - id: 3
    name: "Basic Shell Features"
    sections:
      - id: "3.1"
        name: "Shell Syntax"
        subsections:
          - id: "3.1.1"
            name: "Shell Operation"
            tasks:
              - id: "3.1.1.1"
                title: "Document command execution"
                status: "completed"
                version: "v6.6.0"
                input: "echo \"hello\""
                rust: "fn main() { echo(\"hello\"); }"
                purified: "printf '%s\\n' \"hello\""
                test_name: "test_ECHO_001_simple_echo_command"
                notes: "Echo commands fully supported. POSIX printf preferred for portability. 4 passing tests verify echo parsing, 2 ignored tests document echo flag purification."
                implementation:
                  module: "rash/src/bash_parser/tests.rs"
                  functions:
                    - "test_ECHO_001_simple_echo_command (passing)"
                    - "test_ECHO_002_echo_with_variable (passing)"
                    - "test_ECHO_003_echo_multiple_arguments (passing)"
                    - "test_ECHO_004_posix_printf_alternative (passing)"
                    - "test_ECHO_005_echo_n_flag_needs_implementation (ignored - -n flag purification)"
                    - "test_ECHO_006_echo_e_flag_needs_implementation (ignored - -e flag purification)"
                  lines_of_code: 207
                  documentation: "Comprehensive testing of echo command parsing: simple echo, variable expansion, multiple arguments, POSIX printf alternative. 2 ignored tests document echo flag purification (-n, -e)."
                  posix_compliance: "echo is POSIX but has portability issues (BSD vs GNU). printf is preferred for consistency."
                  priority: "HIGH"
                  purification_strategy:
                    - "echo \"text\" → printf '%s\\n' \"text\""
                    - "echo -n \"text\" → printf '%s' \"text\" (needs implementation)"
                    - "echo -e \"line1\\nline2\" → printf 'line1\\nline2\\n' (needs implementation)"
                  portability_issues:
                    - "BSD echo: -n is literal text, not a flag"
                    - "GNU echo: -n suppresses newline"
                    - "Escape sequences vary across implementations"
                    - "printf has consistent behavior across all POSIX shells"

          - id: "3.1.2"
            name: "Quoting"
            tasks:
              - id: "3.1.2.1"
                title: "Document backslash escaping"
                status: "completed"
                version: "v6.6.0"
                input: "echo \"Hello \\\"World\\\"\""
                rust: "println!(\"Hello \\\"World\\\"\")"
                purified: "printf '%s\\n' \"Hello \\\"World\\\"\""
                test_name: "test_ESCAPE_001_backslash_in_double_quotes"
                notes: "Fully supported. Backslash escaping is context-dependent: works in double quotes (\\\" \\$ \\\\ \\`), escapes next char outside quotes, literal in single quotes. POSIX core feature."
                implementation:
                  module: "rash/src/bash_parser/tests.rs"
                  functions:
                    - "test_ESCAPE_001_backslash_in_double_quotes (passing)"
                    - "test_ESCAPE_002_escaped_dollar_sign (passing)"
                    - "test_ESCAPE_003_escaped_backslash (passing)"
                  lines_of_code: 92
                  documentation: "Comprehensive testing of backslash escape sequences: escaped quotes (\\\"), escaped dollar (\\$), escaped backslash (\\\\). Context-dependent behavior documented."

              - id: "3.1.2.2"
                title: "Document single quote literals"
                status: "completed"
                version: "v6.6.0"
                input: "echo 'It'\\''s working'"
                rust: "println!(\"It's working\")"
                purified: "printf '%s\\n' \"It's working\""
                test_name: "test_QUOTE_004_single_quote_simple"
                notes: "Fully supported. Single quotes preserve ALL characters literally (no variable expansion). Strongest quoting mechanism in POSIX."
                implementation:
                  module: "rash/src/bash_parser/tests.rs"
                  functions:
                    - "test_QUOTE_004_single_quote_simple (passing)"
                    - "test_QUOTE_005_single_quote_no_variable_expansion (passing)"
                    - "test_QUOTE_006_single_quote_special_characters (passing)"
                  lines_of_code: 89
                  documentation: "Comprehensive testing of single quote handling: simple strings, no variable expansion, special character preservation. POSIX-compliant core feature."

              - id: "3.1.2.3"
                title: "Document double quote preservation"
                status: "completed"
                version: "v6.6.0"
                input: "echo \"Value: $VAR\""
                rust: "println!(\"Value: {}\", var)"
                purified: "printf '%s\\n' \"Value: $VAR\""
                test_name: "test_QUOTE_001_double_quote_simple"
                notes: "Fully supported. Double quotes preserve most special characters while allowing variable expansion. Backslash escaping supported."
                implementation:
                  module: "rash/src/bash_parser/tests.rs"
                  functions:
                    - "test_QUOTE_001_double_quote_simple (passing)"
                    - "test_QUOTE_002_double_quote_with_variable (passing)"
                    - "test_QUOTE_003_double_quote_with_escaped_quotes (passing)"
                  lines_of_code: 86
                  documentation: "Comprehensive testing of double quote handling: simple strings, variable expansion, and backslash escaping. POSIX-compliant core feature."

              - id: "3.1.2.4"
                title: "Document $'...' transformation"
                status: "completed"
                version: "v6.6.0"
                input: "echo $'Hello\\nWorld\\t\\x41'; echo $'\\u03B1'; printf '%s\\n' \"Line 1\" \"Line 2\""
                rust: "println!(\"Hello\\nWorld\\t{}\", 'A');"
                purified: "printf 'Hello\\nWorld\\tA\\n'; printf '%s\\n' \"Line 1\" \"Line 2\""
                test_name: "test_ANSI_C_001_ansi_c_quoting_not_supported"
                notes: "ANSI-C quoting ($'...') introduced in Bash 2.0 (1996), NOT SUPPORTED (Bash extension, not POSIX). Supports escape sequences: \\n (newline), \\t (tab), \\r (carriage return), \\\\ (backslash), \\' (single quote), \\\" (double quote), \\xHH (hex byte), \\uHHHH/\\UHHHHHHHH (unicode in Bash 4.2+). Purification uses printf for escape sequences or literal multiline strings. POSIX alternatives: printf with format strings, literal strings with real newlines. Common use cases: multi-line messages, tab-separated values, special characters, alert/bell, form feed."
                implementation:
                  module: "rash/src/bash_parser/tests.rs"
                  functions:
                    - "test_ANSI_C_001_ansi_c_quoting_not_supported (passing)"
                    - "test_ANSI_C_001_basic_escape_sequences (passing)"
                    - "test_ANSI_C_001_hex_and_octal_escapes (passing)"
                    - "test_ANSI_C_001_unicode_escapes (passing)"
                    - "test_ANSI_C_001_purification_uses_printf (passing)"
                    - "test_ANSI_C_001_literal_string_alternative (passing)"
                    - "test_ANSI_C_001_common_use_cases (passing)"
                    - "test_ANSI_C_001_bash_vs_posix_quoting (passing)"
                  lines_of_code: 378
                  documentation: "Comprehensive documentation of ANSI-C quoting ($'...') as Bash extension. Introduced Bash 2.0 (1996). NOT POSIX-compliant. All 8 tests passing, documenting escape sequences (\\n, \\t, \\r, \\\\, \\', \\\", \\xHH, \\uHHHH), purification strategies (printf, literal strings), and POSIX alternatives. Comparison table shows Bash $'...' vs POSIX printf portability."
                  posix_compliance: "NOT POSIX - Bash extension only"
                  priority: "MEDIUM"
                  implementation_needed:
                    - "Lexer: Recognize $' as start of ANSI-C quoted string"
                    - "Lexer: Parse escape sequences (\\n, \\t, \\r, \\\\, \\', \\\", \\xHH, \\uHHHH, \\UHHHHHHHH)"
                    - "Parser: Handle ANSI-C quoted strings in expressions"
                    - "Purifier: Convert to printf with appropriate format strings"
                  security_note: "Hex escapes can obfuscate malicious commands. Purifier should decode and emit readable literals."

      - id: "3.2"
        name: "Shell Commands"
        subsections:
          - id: "3.2.1"
            name: "Simple Commands"
            tasks:
              - id: "3.2.1.1"
                title: "Document command with arguments"
                status: "completed"
                version: "v6.6.0"
                input: "mkdir -p /tmp/data"
                rust: "std::fs::create_dir_all(\"/tmp/data\")"
                purified: "mkdir -p \"/tmp/data\""
                test_name: "test_CMD_001_simple_command_with_arguments"
                notes: "Fully supported. Simple commands are the foundation of shell scripting. Purification adds idempotent flags (-p) and quotes paths."
                implementation:
                  module: "rash/src/bash_parser/tests.rs"
                  functions:
                    - "test_CMD_001_simple_command_with_arguments (passing)"
                    - "test_CMD_002_command_with_multiple_arguments (passing)"
                    - "test_CMD_003_command_with_flags_and_arguments (passing)"
                  lines_of_code: 111
                  documentation: "Comprehensive testing of simple commands with arguments, multiple arguments, and flags. POSIX-compliant core feature."

          - id: "3.2.2"
            name: "Pipelines"
            tasks:
              - id: "3.2.2.1"
                title: "Document pipe transformation"
                status: "completed"
                version: "v6.6.0"
                input: "cat file.txt | grep \"pattern\" | wc -l; ps aux | grep python | awk '{print $2}'"
                rust: "Command::new(\"cat\").arg(\"file.txt\").stdout(Stdio::piped()).spawn()?; Command::new(\"grep\").stdin(...).output()?"
                purified: "cat \"file.txt\" | grep \"pattern\" | wc -l"
                test_name: "test_PIPE_001_basic_pipe_supported"
                notes: "Pipelines (|) are POSIX-compliant and FULLY SUPPORTED. Basic pipe (cmd1 | cmd2), multi-stage pipelines (cmd1 | cmd2 | cmd3), exit status ($? is rightmost command), subshell execution (each command in subshell), concurrent execution (commands run in parallel, not sequential). Variable expansion in pipes requires proper quoting (cat \"$FILE\" | grep \"$PATTERN\"). Rust mapping: std::process::Command with .stdout(Stdio::piped()) and .stdin() to connect pipes. Bash extensions NOT SUPPORTED: PIPESTATUS array, set -o pipefail, shopt -s lastpipe, |& (pipe stderr), process substitution. Common patterns: filter/count, sort/dedupe, extract/process, search in files, transform data, paginate output."
                implementation:
                  module: "rash/src/bash_parser/tests.rs"
                  functions:
                    - "test_PIPE_001_basic_pipe_supported (passing)"
                    - "test_PIPE_001_multi_stage_pipeline (passing)"
                    - "test_PIPE_001_pipe_with_variables (passing)"
                    - "test_PIPE_001_exit_status_semantics (passing)"
                    - "test_PIPE_001_rust_std_process_mapping (passing)"
                    - "test_PIPE_001_subshell_execution (passing)"
                    - "test_PIPE_001_common_patterns (passing)"
                    - "test_PIPE_001_bash_vs_posix_pipes (passing)"
                  lines_of_code: 381
                  documentation: "Comprehensive documentation of pipeline semantics, POSIX compliance, Rust std::process::Command mapping, exit status handling, subshell execution, security considerations (variable quoting), common pipeline patterns, and Bash vs POSIX comparison table."
                  priority: "HIGH"
                  complexity: "MEDIUM"

          - id: "3.2.3"
            name: "Lists"
            tasks:
              - id: "3.2.3.1"
                title: "Document command lists (&&, ||, ;)"
                status: "completed"
                version: "v6.6.0"
                input: "cmd1 && cmd2 || cmd3 ; cmd4; test -f file && echo Found || echo Missing"
                rust: "if cmd1() { cmd2() } else { cmd3() }; cmd4(); if test_file(\"file\") { println!(\"Found\") } else { println!(\"Missing\") }"
                purified: "cmd1 && cmd2 || cmd3 ; cmd4"
                test_name: "test_CMD_LIST_001_semicolon_sequential"
                notes: "Command lists (;, &&, ||) are POSIX-compliant and FULLY SUPPORTED. Semicolon executes sequentially regardless of exit status, newline is equivalent to semicolon. AND (&&) executes second command only if first succeeds (exit 0), short-circuit evaluation, exit status is last executed command. OR (||) executes second command only if first fails (exit non-zero), short-circuit evaluation. Operators can be combined: && and || have equal precedence (left-to-right), ; has lower precedence, | (pipe) has highest precedence. Rust mapping: && maps to if statement, || maps to if !condition, preserve short-circuit semantics. Common patterns: error checking (cmd || exit 1), success confirmation (cmd && echo Done), try-catch style (cmd && echo Success || echo Failed), safe directory change (cd /path || exit 1), create and enter (mkdir -p dir && cd dir), cleanup always runs (process ; cleanup)."
                implementation:
                  module: "rash/src/bash_parser/tests.rs"
                  functions:
                    - "test_CMD_LIST_001_semicolon_sequential (passing)"
                    - "test_CMD_LIST_001_semicolon_operator (passing)"
                    - "test_CMD_LIST_001_and_operator_short_circuit (passing)"
                    - "test_CMD_LIST_001_or_operator_short_circuit (passing)"
                    - "test_CMD_LIST_001_combined_operators (passing)"
                    - "test_CMD_LIST_001_exit_status_semantics (passing)"
                    - "test_CMD_LIST_001_rust_if_statement_mapping (passing)"
                    - "test_CMD_LIST_001_common_patterns (passing)"
                    - "test_CMD_LIST_001_operator_precedence (passing)"
                    - "test_CMD_LIST_001_bash_vs_posix_lists (passing)"
                  lines_of_code: 445
                  documentation: "Comprehensive documentation of command list semantics: sequential execution (;/newline), short-circuit evaluation (&&/||), exit status rules, operator precedence, Rust if statement mapping, 6 common patterns, and Bash vs POSIX comparison table."
                  priority: "HIGH"

          - id: "3.2.4"
            name: "Compound Commands"
            subsections:
              - id: "3.2.4.1"
                name: "Looping Constructs"
                tasks:
                  - id: "LOOP-001"
                    title: "Document until loop transformation"
                    status: "completed"
                    version: "v1.3.0"
                    input: "until [ $i -gt 5 ]; do echo $i; i=$((i+1)); done"
                    rust: "while !(i > 5) { println!(\"{}\", i); i += 1; }"
                    purified: "while [ ! \"$i\" -gt 5 ]; do printf '%s\\n' \"$i\"; i=$((i+1)); done"
                    test_name: "test_until_to_while_transformation"
                    tests_added:
                      - "test_until_to_while_transformation (unit test)"
                      - "prop_until_always_becomes_while (property test, 100 cases)"
                      - "prop_until_transformation_is_deterministic (property test, 100 cases)"
                      - "prop_until_handles_all_test_types (property test, 100 cases)"
                    notes: "Until loops transformed to while with negated condition for POSIX compatibility. Verified with EXTREME TDD: RED->GREEN->REFACTOR->PROPERTY TESTING."
                    implementation:
                      modules:
                        - "rash/src/bash_parser/ast.rs (added Until variant)"
                        - "rash/src/bash_parser/generators.rs (negate_condition, generate_test_condition)"
                        - "rash/src/bash_parser/semantic.rs (Until analysis)"
                        - "rash/src/bash_transpiler/codegen.rs (Until to Rust)"
                        - "rash/src/bash_transpiler/purification.rs (Until purification)"
                      functions:
                        - "negate_condition() - Negates test condition"
                        - "generate_test_condition() - Generates test innards"
                      lines_of_code: 95

                  - id: "LOOP-002"
                    title: "Document while loop"
                    status: "completed"
                    version: "v0.8.0"
                    input: "while [ $i -lt 5 ]; do echo $i; i=$((i+1)); done"
                    rust: "while i < 5 { println!(\"{}\", i); i += 1; }"
                    purified: "while [ \"$i\" -lt 5 ]; do printf '%s\\n' \"$i\"; i=$((i+1)); done"
                    test_name: "test_while_loop_transformation"

                  - id: "LOOP-003"
                    title: "Document for loop"
                    status: "completed"
                    version: "v0.5.0"
                    input: "for i in {1..5}; do echo $i; done"
                    rust: "for i in 1..=5 { println!(\"{}\", i); }"
                    purified: "for i in $(seq 1 5); do printf '%s\\n' \"$i\"; done"
                    test_name: "test_for_loop_transformation"

              - id: "3.2.4.2"
                name: "Conditional Constructs"
                tasks:
                  - id: "COND-001"
                    title: "Document if/else"
                    status: "completed"
                    version: "v0.4.0"
                    input: "if [ \"$VAR\" = \"value\" ]; then echo \"yes\"; else echo \"no\"; fi"
                    rust: "if var == \"value\" { println!(\"yes\") } else { println!(\"no\") }"
                    purified: "if [ \"$VAR\" = \"value\" ]; then printf '%s\\n' \"yes\"; else printf '%s\\n' \"no\"; fi"
                    test_name: "test_if_statement_transformation"

                  - id: "COND-002"
                    title: "Document case/match"
                    status: "completed"
                    version: "v0.6.0"
                    input: "case $VAR in 1) echo \"one\";; 2) echo \"two\";; esac"
                    rust: "match var { 1 => println!(\"one\"), 2 => println!(\"two\"), _ => {} }"
                    purified: "case \"$VAR\" in 1) printf '%s\\n' \"one\";; 2) printf '%s\\n' \"two\";; esac"
                    test_name: "test_case_statement_transformation"

                  - id: "COND-003"
                    title: "Document select menu transformation"
                    status: "completed"
                    version: "v6.6.0"
                    input: "select opt in \"A\" \"B\"; do echo $opt; break; done"
                    rust: "Not supported (interactive only)"
                    purified: "Not supported (non-deterministic)"
                    test_name: "test_COND_003_select_not_supported"
                    notes: "Interactive feature, not deterministic. Documented as intentionally unsupported. Alternative: Use explicit echo menu + read for deterministic behavior."
                    implementation:
                      module: "rash/src/bash_parser/tests.rs"
                      function: "test_COND_003_select_not_supported"
                      lines_of_code: 47
                      documentation: "Comprehensive test and documentation explaining why select is not supported (interactive, non-deterministic, not POSIX)"

      - id: "3.3"
        name: "Shell Functions"
        tasks:
          - id: "FUNC-001"
            title: "Document function syntax"
            status: "completed"
            version: "v0.4.0"
            input: "function greet() { echo \"Hello $1\"; }"
            rust: "fn greet(name: &str) { println!(\"Hello {}\", name); }"
            purified: "greet() { printf '%s %s\\n' \"Hello\" \"$1\"; }"
            test_name: "test_function_definition"

          - id: "FUNC-002"
            title: "Document return values"
            status: "completed"
            version: "v0.4.0"
            input: "add() { echo $(($1 + $2)); }; result=$(add 3 5)"
            rust: "fn add(a: i32, b: i32) -> i32 { a + b }; let result = add(3, 5);"
            purified: "add() { echo \"$(($1 + $2))\"; }; result=\"$(add 3 5)\""
            test_name: "test_function_return_values"

      - id: "3.4"
        name: "Shell Parameters"
        subsections:
          - id: "3.4.1"
            name: "Positional Parameters"
            tasks:
              - id: "PARAM-POS-001"
                title: "Document $1, $2, etc."
                status: "blocked"
                blocked_by: "P0-POSITIONAL-PARAMETERS"
                blocked_reason: "Parser does not support std::env::args() pattern"
                target_version: "v1.3.0"
                priority: "HIGH"
                input: "echo \"First: $1, Second: $2\""
                rust: "fn main(args: Vec<String>) { println!(\"First: {}, Second: {}\", args[0], args[1]); }"
                purified: "printf '%s %s, %s %s\\n' \"First:\" \"$1\" \"Second:\" \"$2\""
                test_name: "test_positional_parameters"
                red_phase_tests: "rash/tests/integration_tests.rs:494-525"

          - id: "3.4.2"
            name: "Special Parameters"
            tasks:
              - id: "PARAM-SPEC-001"
                title: "Document $# (argument count)"
                status: "blocked"
                blocked_by: "P0-POSITIONAL-PARAMETERS"
                blocked_reason: "Depends on std::env::args() support"
                target_version: "v1.3.0"
                priority: "HIGH"
                input: "echo \"Args: $#\""
                rust: "println!(\"Args: {}\", args.len())"
                purified: "printf '%s %s\\n' \"Args:\" \"$#\""
                test_name: "test_arg_count_parameter"

              - id: "PARAM-SPEC-002"
                title: "Document $? (exit status)"
                status: "partial"
                priority: "HIGH"
                input: "cmd; echo \"Exit: $?\""
                rust: "get_status()"
                purified: "get_status"
                test_name: "test_exit_status_baseline"
                notes: "Function calls work (get_status), $? capture pattern recognition is enhancement."
                red_phase_tests: "rash/tests/integration_tests.rs:2486-2564"
                version: "v1.2.1"

              - id: "PARAM-SPEC-003"
                title: "Document $$ (process ID) purification"
                status: "partial"
                priority: "HIGH"
                input: "echo \"PID: $$\""
                rust: "use_fixed_id()"
                purified: "use_fixed_id"
                test_name: "test_process_id_purification_baseline"
                notes: "Verified $$ not generated in user code (trap cleanup usage is acceptable). Function calls work (use_fixed_id)."
                red_phase_tests: "rash/tests/integration_tests.rs:2163-2242"
                version: "v1.2.1"

              - id: "PARAM-SPEC-004"
                title: "Document $! (background PID) purification"
                status: "partial"
                priority: "HIGH"
                input: "cmd & echo \"BG: $!\""
                rust: "run_sync()"
                purified: "run_sync"
                test_name: "test_background_pid_purification_baseline"
                notes: "Verified & and $! not generated (synchronous execution only). Function calls work (run_sync)."
                red_phase_tests: "rash/tests/integration_tests.rs:2251-2335"
                version: "v1.2.1"

              - id: "PARAM-SPEC-005"
                title: "Document $0 (script name)"
                status: "blocked"
                blocked_by: "P0-POSITIONAL-PARAMETERS"
                blocked_reason: "Uses std::env::args().nth(0) pattern"
                target_version: "v1.3.0"
                priority: "MEDIUM"
                input: "echo \"Script: $0\""
                rust: "println!(\"Script: {}\", std::env::args().nth(0).unwrap())"
                purified: "printf '%s %s\\n' \"Script:\" \"$0\""
                test_name: "test_script_name_parameter"

              - id: "PARAM-SPEC-006"
                title: "Document $- (shell options) purification"
                status: "pending"
                priority: "LOW"
                input: "echo \"Options: $-\""
                rust: "Not supported (runtime-specific)"
                purified: "Remove (not needed in purified scripts)"
                test_name: "test_shell_options_removed"

      - id: "3.5"
        name: "Shell Expansions"
        subsections:
          - id: "3.5.1"
            name: "Brace Expansion"
            tasks:
              - id: "EXP-BRACE-001"
                title: "Document brace expansion"
                status: "partial"
                priority: "MEDIUM"
                input: "echo {1..5}"
                rust: "generate_sequence(1, 5)"
                purified: "generate_sequence 1 5"
                test_name: "test_brace_expansion_baseline"
                notes: "Function calls work (generate_sequence start end), range pattern recognition is enhancement."
                red_phase_tests: "rash/tests/session8_tests.rs:114-165"
                version: "v1.2.1"

          - id: "3.5.2"
            name: "Tilde Expansion"
            tasks:
              - id: "EXP-TILDE-001"
                title: "Document ~ expansion"
                status: "partial"
                priority: "MEDIUM"
                input: "cd ~/docs"
                rust: "use_home_path()"
                purified: "use_home_path"
                test_name: "test_tilde_expansion_baseline"
                notes: "Function calls work (use_home_path), home_dir() pattern recognition is enhancement."
                red_phase_tests: "rash/tests/session8_tests.rs:167-222"
                version: "v1.2.1"

          - id: "3.5.3"
            name: "Shell Parameter Expansion"
            tasks:
              - id: "EXP-PARAM-001"
                title: "Document ${parameter:-word} (default value)"
                status: "completed"
                version: "v1.3.0"
                priority: "HIGH"
                input: "echo \"${VAR:-default}\""
                rust: "let val = var.unwrap_or(\"default\");"
                purified: "echo \"${VAR:-default}\""
                test_name: "test_default_value_expansion"
                tests_added:
                  - "test_default_value_expansion (unit test)"
                  - "prop_default_value_preserves_variable_name (property test, 100 cases)"
                  - "prop_default_value_is_deterministic (property test, 100 cases)"
                  - "prop_nested_default_values (property test, 100 cases)"
                notes: "Default value expansion ${VAR:-default} preserved in purified output. Verified with EXTREME TDD: RED->GREEN->REFACTOR->PROPERTY TESTING."
                implementation:
                  modules:
                    - "rash/src/bash_parser/ast.rs (added DefaultValue variant to BashExpr)"
                    - "rash/src/bash_parser/generators.rs (generate ${VAR:-default} syntax)"
                    - "rash/src/bash_parser/semantic.rs (DefaultValue analysis)"
                    - "rash/src/bash_transpiler/codegen.rs (DefaultValue to Rust unwrap_or)"
                    - "rash/src/bash_transpiler/purification.rs (DefaultValue purification)"
                  functions:
                    - "generate_expr() - Generates ${VAR:-default} with proper quoting"
                  lines_of_code: 45

              - id: "EXP-PARAM-002"
                title: "Document ${parameter:=word} (assign default)"
                status: "completed"
                version: "v1.3.0"
                priority: "HIGH"
                input: "echo \"${VAR:=default}\""
                rust: "let val = var.get_or_insert(\"default\");"
                purified: "echo \"${VAR:=default}\""
                test_name: "test_assign_default_expansion"
                tests_added:
                  - "test_assign_default_value_expansion (unit test)"
                  - "prop_assign_default_preserves_variable_name (property test, 100 cases)"
                  - "prop_assign_default_is_deterministic (property test, 100 cases)"
                  - "prop_nested_assign_defaults (property test, 100 cases)"
                notes: "Assign default expansion ${VAR:=default} assigns to variable if unset. Verified with EXTREME TDD: RED->GREEN->REFACTOR->PROPERTY TESTING."
                implementation:
                  modules:
                    - "rash/src/bash_parser/ast.rs (added AssignDefault variant to BashExpr)"
                    - "rash/src/bash_parser/generators.rs (generate ${VAR:=default} syntax)"
                    - "rash/src/bash_parser/semantic.rs (AssignDefault analysis with assignment tracking)"
                    - "rash/src/bash_transpiler/codegen.rs (AssignDefault to Rust get_or_insert)"
                    - "rash/src/bash_transpiler/purification.rs (AssignDefault purification)"
                  functions:
                    - "generate_expr() - Generates ${VAR:=default} with proper quoting"
                  lines_of_code: 50

              - id: "EXP-PARAM-003"
                title: "Document ${parameter:?word} (error if unset)"
                status: "completed"
                version: "v1.3.0"
                priority: "MEDIUM"
                input: "echo \"${VAR:?error message}\""
                rust: "let val = var.expect(\"error message\");"
                purified: "echo \"${VAR:?error message}\""
                test_name: "test_error_if_unset_expansion"
                tests_added:
                  - "test_error_if_unset_expansion (unit test)"
                  - "prop_error_if_unset_preserves_components (property test, 100 cases)"
                  - "prop_error_if_unset_is_deterministic (property test, 100 cases)"
                  - "prop_error_if_unset_uses_correct_operator (property test, 100 cases)"
                notes: "Error-if-unset expansion ${VAR:?message} exits if variable unset. Verified with EXTREME TDD: RED->GREEN->REFACTOR->PROPERTY TESTING."
                implementation:
                  modules:
                    - "rash/src/bash_parser/ast.rs (added ErrorIfUnset variant to BashExpr)"
                    - "rash/src/bash_parser/generators.rs (generate ${VAR:?message} syntax)"
                    - "rash/src/bash_parser/semantic.rs (ErrorIfUnset analysis)"
                    - "rash/src/bash_transpiler/codegen.rs (ErrorIfUnset to Rust expect)"
                    - "rash/src/bash_transpiler/purification.rs (ErrorIfUnset purification)"
                  functions:
                    - "generate_expr() - Generates ${VAR:?message} with proper quoting"
                  lines_of_code: 50

              - id: "EXP-PARAM-004"
                title: "Document ${parameter:+word} (alternative value)"
                status: "completed"
                version: "v1.3.0"
                priority: "MEDIUM"
                input: "echo \"${VAR:+is_set}\""
                rust: "let val = var.as_ref().map(|_| \"is_set\").unwrap_or(\"\");"
                purified: "echo \"${VAR:+is_set}\""
                test_name: "test_alternative_value_expansion"
                tests_added:
                  - "test_alternative_value_expansion (unit test)"
                  - "prop_alternative_value_preserves_components (property test, 100 cases)"
                  - "prop_alternative_value_is_deterministic (property test, 100 cases)"
                  - "prop_alternative_value_uses_correct_operator (property test, 100 cases)"
                notes: "Alternative value expansion ${VAR:+alt_value} uses alt_value if variable is set. Opposite of default value (:- operator). Verified with EXTREME TDD: RED->GREEN->REFACTOR->PROPERTY TESTING."
                implementation:
                  modules:
                    - "rash/src/bash_parser/ast.rs (added AlternativeValue variant to BashExpr)"
                    - "rash/src/bash_parser/generators.rs (generate ${VAR:+alt_value} syntax)"
                    - "rash/src/bash_parser/semantic.rs (AlternativeValue analysis)"
                    - "rash/src/bash_transpiler/codegen.rs (AlternativeValue to Rust .as_ref().map)"
                    - "rash/src/bash_transpiler/purification.rs (AlternativeValue purification)"
                  functions:
                    - "generate_expr() - Generates ${VAR:+alt_value} with proper quoting"
                  lines_of_code: 50

              - id: "EXP-PARAM-005"
                title: "Document ${#parameter} (string length)"
                status: "completed"
                version: "v1.3.0"
                priority: "HIGH"
                input: "echo \"${#VAR}\""
                rust: "let len = var.len();"
                purified: "echo \"${#VAR}\""
                test_name: "test_string_length_expansion"
                tests_added:
                  - "test_string_length_expansion (unit test)"
                  - "prop_string_length_preserves_variable (property test, 100 cases)"
                  - "prop_string_length_is_deterministic (property test, 100 cases)"
                  - "prop_string_length_uses_correct_operator (property test, 100 cases)"
                notes: "String length expansion ${#VAR} gets the length of the string value of variable. Verified with EXTREME TDD: RED->GREEN->REFACTOR->PROPERTY TESTING."
                implementation:
                  modules:
                    - "rash/src/bash_parser/ast.rs (added StringLength variant to BashExpr)"
                    - "rash/src/bash_parser/generators.rs (generate ${#VAR} syntax)"
                    - "rash/src/bash_parser/semantic.rs (StringLength analysis)"
                    - "rash/src/bash_transpiler/codegen.rs (StringLength to Rust .len())"
                    - "rash/src/bash_transpiler/purification.rs (StringLength purification)"
                  functions:
                    - "generate_expr() - Generates ${#VAR} with proper quoting"
                  lines_of_code: 50

              - id: "EXP-PARAM-006"
                title: "Document ${parameter%word} (remove suffix)"
                status: "completed"
                version: "v1.3.0"
                priority: "HIGH"
                input: "file=\"test.txt\"; echo \"${file%.txt}\""
                rust: "let name = file.strip_suffix(\".txt\").unwrap_or(&file);"
                purified: "echo \"${file%.txt}\""
                test_name: "test_remove_suffix_expansion"
                tests_added:
                  - "test_remove_suffix_expansion (unit test)"
                  - "prop_remove_suffix_preserves_components (property test, 100 cases)"
                  - "prop_remove_suffix_is_deterministic (property test, 100 cases)"
                  - "prop_remove_suffix_uses_correct_operator (property test, 100 cases)"
                notes: "Remove suffix expansion ${VAR%pattern} removes shortest matching suffix pattern from variable. Verified with EXTREME TDD: RED->GREEN->REFACTOR->PROPERTY TESTING."
                implementation:
                  modules:
                    - "rash/src/bash_parser/ast.rs (added RemoveSuffix variant to BashExpr)"
                    - "rash/src/bash_parser/generators.rs (generate ${VAR%pattern} syntax)"
                    - "rash/src/bash_parser/semantic.rs (RemoveSuffix analysis)"
                    - "rash/src/bash_transpiler/codegen.rs (RemoveSuffix to Rust .strip_suffix())"
                    - "rash/src/bash_transpiler/purification.rs (RemoveSuffix purification)"
                  functions:
                    - "generate_expr() - Generates ${VAR%pattern} with proper quoting"
                  lines_of_code: 55

              - id: "EXP-PARAM-007"
                title: "Document ${parameter#word} (remove prefix)"
                status: "completed"
                version: "v1.3.0"
                priority: "HIGH"
                input: "path=\"/usr/local/bin\"; echo \"${path#/usr/}\""
                rust: "let name = path.strip_prefix(\"/usr/\").unwrap_or(&path);"
                purified: "echo \"${path#/usr/}\""
                test_name: "test_remove_prefix_expansion"
                tests_added:
                  - "test_remove_prefix_expansion (unit test)"
                  - "prop_remove_prefix_preserves_components (property test, 100 cases)"
                  - "prop_remove_prefix_is_deterministic (property test, 100 cases)"
                  - "prop_remove_prefix_uses_correct_operator (property test, 100 cases)"
                notes: "Remove prefix expansion ${VAR#pattern} removes shortest matching prefix pattern from variable. Verified with EXTREME TDD: RED->GREEN->REFACTOR->PROPERTY TESTING."
                implementation:
                  modules:
                    - "rash/src/bash_parser/ast.rs (added RemovePrefix variant to BashExpr)"
                    - "rash/src/bash_parser/generators.rs (generate ${VAR#pattern} syntax)"
                    - "rash/src/bash_parser/semantic.rs (RemovePrefix analysis)"
                    - "rash/src/bash_transpiler/codegen.rs (RemovePrefix to Rust .strip_prefix())"
                    - "rash/src/bash_transpiler/purification.rs (RemovePrefix purification)"
                  functions:
                    - "generate_expr() - Generates ${VAR#pattern} with proper quoting"
                  lines_of_code: 55

              - id: "EXP-PARAM-008"
                title: "Document ${parameter##word} (remove longest prefix)"
                status: "completed"
                version: "v1.3.0"
                priority: "HIGH"
                input: "path=\"/usr/local/bin\"; echo \"${path##*/}\""
                rust: "let name = path.rsplit_once('/').map_or(&path, |(_, name)| name);"
                purified: "echo \"${path##*/}\""
                test_name: "test_remove_longest_prefix_expansion"
                tests_added:
                  - "test_remove_longest_prefix_expansion (unit test)"
                  - "prop_remove_longest_prefix_preserves_components (property test, 100 cases)"
                  - "prop_remove_longest_prefix_is_deterministic (property test, 100 cases)"
                  - "prop_remove_longest_prefix_uses_correct_operator (property test, 100 cases)"
                notes: "Remove longest matching prefix. ## is greedy version of #. Verified with EXTREME TDD: RED->GREEN->REFACTOR->PROPERTY TESTING."
                implementation:
                  modules:
                    - "rash/src/bash_parser/ast.rs (added RemoveLongestPrefix variant to BashExpr)"
                    - "rash/src/bash_parser/generators.rs (generate ${VAR##pattern} syntax with ## operator)"
                    - "rash/src/bash_parser/semantic.rs (RemoveLongestPrefix analysis)"
                    - "rash/src/bash_transpiler/codegen.rs (RemoveLongestPrefix to Rust .rsplit_once())"
                    - "rash/src/bash_transpiler/purification.rs (RemoveLongestPrefix purification)"
                  functions:
                    - "generate_expr() - Generates ${VAR##pattern} with proper quoting and ## operator"
                  lines_of_code: 55

              - id: "EXP-PARAM-009"
                title: "Document ${parameter%%word} (remove longest suffix)"
                status: "completed"
                version: "v1.3.0"
                priority: "HIGH"
                input: "file=\"archive.tar.gz\"; echo \"${file%%.*}\""
                rust: "let name = file.split_once('.').map_or(&file, |(name, _)| name);"
                purified: "echo \"${file%%.*}\""
                test_name: "test_remove_longest_suffix_expansion"
                tests_added:
                  - "test_remove_longest_suffix_expansion (unit test)"
                  - "prop_remove_longest_suffix_preserves_components (property test, 100 cases)"
                  - "prop_remove_longest_suffix_is_deterministic (property test, 100 cases)"
                  - "prop_remove_longest_suffix_uses_correct_operator (property test, 100 cases)"
                notes: "Remove longest matching suffix. %% is greedy version of %. Verified with EXTREME TDD: RED->GREEN->REFACTOR->PROPERTY TESTING."
                implementation:
                  modules:
                    - "rash/src/bash_parser/ast.rs (added RemoveLongestSuffix variant to BashExpr)"
                    - "rash/src/bash_parser/generators.rs (generate ${VAR%%pattern} syntax with %% operator)"
                    - "rash/src/bash_parser/semantic.rs (RemoveLongestSuffix analysis)"
                    - "rash/src/bash_transpiler/codegen.rs (RemoveLongestSuffix to Rust .split_once())"
                    - "rash/src/bash_transpiler/purification.rs (RemoveLongestSuffix purification)"
                  functions:
                    - "generate_expr() - Generates ${VAR%%pattern} with proper quoting and %% operator"
                  lines_of_code: 55

              - id: "EXP-PARAM-010"
                title: "Document ${parameter/pattern/string} (substitution)"
                status: "completed"
                priority: "MEDIUM"
                input: "text=\"hello\"; echo \"${text/l/L}\""
                rust: "text.replacen(\"l\", \"L\", 1)"
                purified: "Use sed or awk (POSIX doesn't support ${//})"
                test_name: "test_EXP_PARAM_010_pattern_substitution"
                notes: "Already supported by command parsing infrastructure (BUILTIN-001). Pattern substitution ${text/pattern/replacement} is bash-specific, not POSIX sh."

          - id: "3.5.4"
            name: "Command Substitution"
            tasks:
              - id: "EXP-CMD-001"
                title: "Document $() and backticks"
                status: "completed"
                version: "v0.4.0"
                input: "result=$(date); result=`date`"
                rust: "let result = date();"
                purified: "result=\"$(date)\""
                test_name: "test_command_substitution"
                notes: "Prefer $() over backticks"

          - id: "3.5.5"
            name: "Arithmetic Expansion"
            tasks:
              - id: "EXP-ARITH-001"
                title: "Document $((...)) arithmetic"
                status: "completed"
                version: "v0.4.0"
                input: "result=$((3 + 5 * 2))"
                rust: "let result = 3 + 5 * 2;"
                purified: "result=\"$((3 + 5 * 2))\""
                test_name: "test_arithmetic_expansion"

          - id: "3.5.6"
            name: "Process Substitution"
            tasks:
              - id: "EXP-PROC-001"
                title: "Document <(...) and >(...)"
                status: "completed"
                priority: "MEDIUM"
                input: "diff <(cmd1) <(cmd2)"
                rust: "Not supported (bash-specific)"
                purified: "Use temporary files instead"
                test_name: "test_EXP_PROC_001_process_substitution"
                notes: "Already supported by command parsing infrastructure (BUILTIN-001). Process substitution <(cmd) and >(cmd) are bash-specific, not POSIX sh. Use temporary files for POSIX compatibility."

          - id: "3.5.7"
            name: "Word Splitting"
            tasks:
              - id: "EXP-SPLIT-001"
                title: "Document IFS-based splitting purification"
                status: "completed"
                priority: "MEDIUM"
                input: "IFS=':'; read -ra PARTS <<< \"$PATH\""
                rust: "let parts: Vec<_> = path.split(':').collect();"
                purified: "Use explicit tr or cut (avoid IFS manipulation)"
                test_name: "test_EXP_SPLIT_001_word_splitting"
                notes: "Already supported by assignment parsing infrastructure (BUILTIN-001). IFS variable assignment is supported, but for purification recommend using explicit tr, cut, or awk for deterministic word splitting instead of IFS manipulation."

          - id: "3.5.8"
            name: "Filename Expansion (Globbing)"
            tasks:
              - id: "EXP-GLOB-001"
                title: "Document glob patterns"
                status: "completed"
                version: "v1.3.0"
                priority: "MEDIUM"
                input: "for f in *.txt; do echo $f; done"
                rust: "for f in glob(\"*.txt\") { println!(\"{}\", f); }"
                purified: "for f in *.txt; do printf '%s\\n' \"$f\"; done"
                test_name: "test_glob_pattern_transformation"
                tests_added:
                  - "test_glob_pattern_transformation (unit test)"
                  - "prop_glob_patterns_preserved (property test, 100 cases)"
                  - "prop_glob_transformation_is_deterministic (property test, 100 cases)"
                  - "prop_glob_wildcards_preserved (property test, 100 cases)"
                notes: "Glob patterns preserved in purified output. Feature already existed in BashExpr::Glob. Verified with EXTREME TDD: Property Testing."
                implementation:
                  modules:
                    - "rash/src/bash_parser/ast.rs (BashExpr::Glob variant already existed)"
                    - "rash/src/bash_parser/generators.rs (glob pattern generation)"
                    - "rash/src/bash_transpiler/codegen.rs (glob to Rust)"
                  functions:
                    - "generate_expr() - Generates glob patterns in for loops"
                  lines_of_code: 15

      - id: "3.6"
        name: "Redirections"
        tasks:
          - id: "REDIR-001"
            title: "Document < redirection (input)"
            status: "completed"
            priority: "MEDIUM"
            input: "wc -l < file.txt; grep pattern < input.txt; sort < unsorted.txt > sorted.txt"
            rust: "File::open(\"file.txt\")?; Command::new(\"grep\").arg(\"pattern\").arg(\"input.txt\").output()?"
            purified: "wc -l < \"file.txt\"; grep \"pattern\" < \"input.txt\""
            test_name: "test_REDIR_001_basic_input_redirection"
            notes: "Input redirection (<) is POSIX-compliant and FULLY SUPPORTED. Connects stdin to file contents, more efficient than cat file | cmd (no pipe/subshell). File descriptor 0 redirected. Common pattern: while read loop with < file. Can combine with output redirection (sort < in.txt > out.txt). Rust mapping: File::open() + BufReader or Command with file args. Error handling: file not found/no read permission/is directory. Common use cases: count lines (wc -l <), sort file, search in file, process line-by-line (while read < file), transform contents (tr < in > out), filter and count (grep < | wc -l). Bash extensions NOT SUPPORTED: <<< here-strings (Bash 2.05b+), <(cmd) process substitution."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_REDIR_001_basic_input_redirection (passing)"
                - "test_REDIR_001_input_vs_file_argument (passing)"
                - "test_REDIR_001_while_read_pattern (passing)"
                - "test_REDIR_001_multiple_redirections (passing)"
                - "test_REDIR_001_rust_file_open_mapping (passing)"
                - "test_REDIR_001_error_handling (passing)"
                - "test_REDIR_001_common_use_cases (passing)"
                - "test_REDIR_001_bash_vs_posix_input_redir (passing)"
              lines_of_code: 402
              documentation: "Comprehensive documentation of input redirection: basic < syntax, vs file arguments, while read pattern, multiple redirections, Rust File::open() mapping, error handling, 6 common use cases, and Bash vs POSIX comparison table."
            version: "v6.6.0"

          - id: "REDIR-002"
            title: "Document > and >> redirection (output)"
            status: "completed"
            priority: "MEDIUM"
            input: "echo \"text\" > file.txt; echo \"more\" >> file.txt; cmd 2> errors.txt; cmd > output.txt 2>&1"
            rust: "File::create(\"file.txt\")?; OpenOptions::new().append(true).open(\"file.txt\")?; Command::new(\"cmd\").output()?"
            purified: "echo \"text\" > \"file.txt\"; echo \"more\" >> \"file.txt\"; cmd 2> \"errors.txt\"; cmd > \"output.txt\" 2>&1"
            test_name: "test_REDIR_002_basic_output_redirection"
            notes: "Output redirection (>, >>) is POSIX-compliant and FULLY SUPPORTED. > truncates file, >> appends. stderr (2>), merge (2>&1) supported. Bash extensions NOT SUPPORTED: &> (Bash shortcut), >& (csh-style), >| (force), >(cmd) process substitution."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_REDIR_002_basic_output_redirection (passing)"
                - "test_REDIR_002_append_redirection (passing)"
                - "test_REDIR_002_overwrite_vs_append (passing)"
                - "test_REDIR_002_stderr_redirection (passing)"
                - "test_REDIR_002_combined_io_redirection (passing)"
                - "test_REDIR_002_rust_file_mapping (passing)"
                - "test_REDIR_002_common_use_cases (passing)"
                - "test_REDIR_002_bash_vs_posix_output_redir (passing)"
              lines_of_code: 345
            version: "v6.6.0"

          - id: "REDIR-003"
            title: "Document &> redirection (stdout+stderr)"
            status: "completed"
            priority: "HIGH"
            input: "cmd &> output.txt; cmd >& combined.txt; cmd &>> log.txt"
            rust: "Command::new(\"cmd\").output()? // Use > file 2>&1 in shell"
            purified: "cmd > \"output.txt\" 2>&1; cmd > \"combined.txt\" 2>&1; cmd >> \"log.txt\" 2>&1"
            test_name: "test_REDIR_003_combined_redirection_not_supported"
            notes: "Combined redirection (&>, >&, &>>) is Bash extension, NOT SUPPORTED. POSIX equivalent is > file 2>&1 (SUPPORTED). Purification strategy: convert &> to > file 2>&1, &>> to >> file 2>&1. Order matters: > file BEFORE 2>&1."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_REDIR_003_combined_redirection_not_supported (passing)"
                - "test_REDIR_003_csh_style_redirection_not_supported (passing)"
                - "test_REDIR_003_append_combined_not_supported (passing)"
                - "test_REDIR_003_posix_equivalent (passing)"
                - "test_REDIR_003_purification_strategy (passing)"
                - "test_REDIR_003_order_matters (passing)"
                - "test_REDIR_003_common_use_cases (passing)"
                - "test_REDIR_003_bash_vs_posix_combined_redir (passing)"
              lines_of_code: 331
            version: "v6.6.0"

          - id: "REDIR-004"
            title: "Document << heredoc"
            status: "partial"
            priority: "HIGH"
            input: "cat << EOF\\nHello\\nWorld\\nEOF"
            rust: "print_heredoc()"
            purified: "print_heredoc"
            test_name: "test_heredoc_baseline"
            notes: "Function calls work (print_heredoc), multi-line string literal recognition is enhancement."
            red_phase_tests: "rash/tests/integration_tests.rs:2073-2154"
            version: "v1.2.1"

          - id: "REDIR-005"
            title: "Document <<< herestring"
            status: "partial"
            priority: "MEDIUM"
            input: "cmd <<< \"input string\""
            rust: "pass_string(\"input data\")"
            purified: "pass_string 'input data'"
            test_name: "test_herestring_baseline"
            notes: "Function calls work (pass_string data), printf | pipe pattern recognition is enhancement."
            red_phase_tests: "rash/tests/integration_tests.rs:2573-2648"
            version: "v1.2.1"

  - id: 4
    name: "Shell Builtin Commands"
    sections:
      - id: "4.1"
        name: "Bourne Shell Builtins"
        tasks:
          - id: "BUILTIN-001"
            title: "Document : (no-op)"
            status: "completed"
            priority: "LOW"
            input: ": # comment"
            rust: "// comment"
            purified: ": # comment"
            test_name: "test_BUILTIN_001_noop_colon"
            notes: "Lexer recognizes ':' as command, parser stops at comments"

          - id: "BUILTIN-002"
            title: "Document . (source)"
            status: "completed"
            priority: "MEDIUM"
            input: ". ./config.sh"
            rust: "include!(\"config.rs\")"
            purified: ". \"./config.sh\""
            test_name: "test_BUILTIN_002_source_command"
            notes: "Already supported by bare word parsing (BUILTIN-001 enabled this)"

          - id: "BUILTIN-003"
            title: "Document break"
            status: "completed"
            version: "v0.8.0"
            input: "while true; do break; done"
            rust: "while true { break; }"
            purified: "while true; do break; done"
            test_name: "test_break_statement"

          - id: "BUILTIN-004"
            title: "Document continue"
            status: "completed"
            version: "v0.8.0"
            input: "for i in 1 2 3; do continue; done"
            rust: "for i in 1..=3 { continue; }"
            purified: "for i in 1 2 3; do continue; done"
            test_name: "test_continue_statement"

          - id: "BUILTIN-005"
            title: "Document cd"
            status: "partial"
            priority: "MEDIUM"
            input: "cd /tmp"
            rust: "cd(\"/tmp\")"
            purified: "cd \"/tmp\""
            test_name: "test_cd_command_baseline"
            notes: "Function calls work (cd \"/tmp\"), std::env::set_current_dir recognition is enhancement."
            red_phase_tests: "rash/tests/integration_tests.rs:1037-1113"
            version: "v1.2.1"

          - id: "BUILTIN-006"
            title: "Document echo"
            status: "completed"
            version: "v0.4.0"
            input: "echo \"Hello World\""
            rust: "println!(\"Hello World\")"
            purified: "printf '%s\\n' \"Hello World\""
            test_name: "test_echo_to_printf"
            notes: "Prefer printf over echo"

          - id: "BUILTIN-007"
            title: "Document eval"
            status: "completed"
            version: "v6.6.0"
            priority: "LOW"
            input: "cmd=\"echo hello\"; eval $cmd"
            rust: "Not supported (dynamic execution unsafe)"
            purified: "Remove (security risk, not deterministic)"
            test_name: "test_BUILTIN_007_eval_not_supported"
            notes: "eval is intentionally NOT SUPPORTED - security risk (code injection), non-deterministic. 4 tests document why eval must be removed from scripts."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_BUILTIN_007_eval_not_supported (passing)"
                - "test_BUILTIN_007_eval_security_risk (passing)"
                - "test_BUILTIN_007_eval_non_deterministic (passing)"
                - "test_BUILTIN_007_eval_refactoring_alternative (passing)"
              lines_of_code: 143
              documentation: "Comprehensive documentation of eval security risks: code injection (CWE-78), arbitrary command execution, non-deterministic behavior. Includes refactoring strategy to explicit commands."
              security_risks:
                - "Code injection vulnerability (arbitrary command execution)"
                - "Cannot be statically analyzed or verified"
                - "Classic attack vector in shell scripts"
                - "CWE-78: OS Command Injection"
                - "Severity: CRITICAL when used with user input"
              determinism_issues:
                - "eval depends on runtime variable values"
                - "Same script may execute different commands each run"
                - "Cannot be purified to deterministic POSIX sh"
                - "Violates idempotency principle"
              refactoring_strategy:
                - "Instead of: cmd=\"echo hello\"; eval $cmd"
                - "Use: echo hello (explicit, static, deterministic)"
                - "Linter should flag eval usage as CRITICAL security issue"
                - "No safe equivalent - must be removed from purified scripts"

          - id: "BUILTIN-008"
            title: "Document exec"
            status: "completed"
            version: "v6.6.0"
            priority: "LOW"
            input: "exec ./new-script.sh"
            rust: "std::process::Command::new(\"./new-script.sh\").exec()"
            purified: "Remove (replaces process, not idempotent)"
            test_name: "test_BUILTIN_008_exec_not_supported"
            notes: "exec is intentionally NOT SUPPORTED - non-idempotent (replaces process), cannot be re-run. 4 tests document why exec must be removed from scripts."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_BUILTIN_008_exec_not_supported (passing)"
                - "test_BUILTIN_008_exec_breaks_idempotency (passing)"
                - "test_BUILTIN_008_exec_fd_redirection (passing)"
                - "test_BUILTIN_008_exec_refactoring_alternative (passing)"
              lines_of_code: 146
              documentation: "Comprehensive documentation of exec idempotency issues: process replacement, global state modification, cannot be re-run. Includes refactoring strategy to explicit script invocation."
              idempotency_issues:
                - "exec replaces the current process (shell terminates)"
                - "Cannot be run multiple times (process is gone after first run)"
                - "Breaks 'safe to re-run' principle"
                - "No way to undo or reverse"
                - "exec with FD redirection modifies global shell state permanently"
              determinism_issues:
                - "exec changes global process state permanently"
                - "Side effects cannot be rolled back"
                - "Script cannot continue after exec"
              refactoring_strategy:
                - "Instead of: exec ./new-script.sh (replaces process)"
                - "Use: ./new-script.sh (runs script, returns control)"
                - "Linter should flag exec usage as idempotency violation"
                - "No safe equivalent - must be removed from purified scripts"

          - id: "BUILTIN-009"
            title: "Document exit"
            status: "partial"
            priority: "MEDIUM"
            input: "exit 0"
            rust: "exit_with_code(0)"
            purified: "exit 0"
            test_name: "test_exit_command_baseline"
            notes: "Function calls work (exit_with_code 0), std::process::exit recognition is enhancement."
            red_phase_tests: "rash/tests/integration_tests.rs:1194-1240"
            version: "v1.2.1"

          - id: "BUILTIN-010"
            title: "Document export"
            status: "partial"
            priority: "HIGH"
            input: "export VAR=\"value\""
            rust: "set_env(\"VAR\", \"value\")"
            purified: "set_env VAR value"
            test_name: "test_export_command_baseline"
            notes: "Function calls work (set_env VAR value), std::env::set_var recognition is enhancement."
            red_phase_tests: "rash/tests/integration_tests.rs:1242-1288"
            version: "v1.2.1"

          - id: "BUILTIN-011"
            title: "Document pwd"
            status: "partial"
            priority: "MEDIUM"
            input: "current=$(pwd)"
            rust: "pwd()"
            purified: "pwd"
            test_name: "test_pwd_command_baseline"
            notes: "Function calls work (pwd), std::env::current_dir recognition is enhancement."
            red_phase_tests: "rash/tests/integration_tests.rs:1115-1194"
            version: "v1.2.1"

          - id: "BUILTIN-012"
            title: "Document read"
            status: "completed"
            version: "v6.6.0"
            priority: "LOW"
            input: "read -r var"
            rust: "Not supported (interactive input non-deterministic)"
            purified: "Remove (use command-line args instead)"
            test_name: "test_BUILTIN_012_read_not_supported"
            notes: "read is intentionally NOT SUPPORTED - interactive input, non-deterministic. 4 tests document why read must be removed from scripts."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_BUILTIN_012_read_not_supported (passing)"
                - "test_BUILTIN_012_read_non_deterministic (passing)"
                - "test_BUILTIN_012_read_interactive_only (passing)"
                - "test_BUILTIN_012_read_refactoring_alternative (passing)"
              lines_of_code: 159
              documentation: "Comprehensive documentation of read non-determinism: interactive input, varies each run, cannot be automated. Includes refactoring strategy to command-line arguments."
              determinism_issues:
                - "read depends on user input at runtime"
                - "Different input each run → non-deterministic"
                - "Cannot predict output from static analysis"
                - "Impossible to purify to deterministic script"
              automation_issues:
                - "Requires user interaction (cannot run in CI/CD)"
                - "Fails in non-interactive environments (cron, Docker)"
                - "No user present in automated deployments"
                - "Cannot be reliably re-run without user intervention"
              refactoring_strategy:
                - "Instead of: read -p \"Enter name: \" name (interactive)"
                - "Use: name=\"$1\" (command-line argument, deterministic)"
                - "Usage: ./script.sh Alice (automated, deterministic)"
                - "Linter should flag read usage as determinism violation"

          - id: "BUILTIN-013"
            title: "Document return"
            status: "completed"
            version: "v0.4.0"
            input: "func() { return 1; }"
            rust: "fn func() -> Result<(), String> { Err(\"error\".into()) }"
            purified: "func() { return 1; }"
            test_name: "test_return_statement"

          - id: "BUILTIN-014"
            title: "Document set"
            status: "completed"
            priority: "MEDIUM"
            input: "set -e"
            rust: "Not applicable (compile-time checking)"
            purified: "set -e"
            test_name: "test_BUILTIN_014_set_flags"
            notes: "Already supported by command parsing infrastructure (BUILTIN-001)"

          - id: "BUILTIN-015"
            title: "Document shift"
            status: "completed"
            priority: "MEDIUM"
            input: "shift; echo $1"
            rust: "args.remove(0); println!(\"{}\", args[0])"
            purified: "shift; printf '%s\\n' \"$1\""
            test_name: "test_BUILTIN_015_shift_command"
            notes: "Already supported by command parsing infrastructure (BUILTIN-001)"

          - id: "BUILTIN-016"
            title: "Document test / ["
            status: "partial"
            priority: "HIGH"
            input: "if [ -f \"file.txt\" ]; then echo \"exists\"; fi"
            rust: "test_file_exists(\"/tmp/test.txt\")"
            purified: "test_file_exists /tmp/test.txt"
            test_name: "test_test_command_baseline"
            notes: "Function calls work (test_file_exists path), std::path::Path recognition is enhancement."
            red_phase_tests: "rash/tests/integration_tests.rs:1368-1445"
            version: "v1.2.1"

          - id: "BUILTIN-017"
            title: "Document times"
            status: "completed"
            version: "v6.6.0"
            priority: "LOW"
            input: "times"
            rust: "Not supported (profiling, non-deterministic)"
            purified: "Remove (use external profiling tools)"
            test_name: "test_BUILTIN_017_times_not_supported"
            notes: "times is intentionally NOT SUPPORTED - profiling data, non-deterministic (CPU time varies). 4 tests document why times must be removed from scripts."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_BUILTIN_017_times_not_supported (passing)"
                - "test_BUILTIN_017_times_non_deterministic (passing)"
                - "test_BUILTIN_017_times_profiling_only (passing)"
                - "test_BUILTIN_017_times_refactoring_alternative (passing)"
              lines_of_code: 167
              documentation: "Comprehensive documentation of times non-determinism: CPU time varies based on system load, not needed in production. Includes external profiling tool recommendations."
              determinism_issues:
                - "CPU time varies based on system load"
                - "Different values each run (load, CPU speed, cache, scheduling)"
                - "Cannot predict output from static analysis"
                - "Timing data is inherently non-deterministic"
              profiling_issues:
                - "times is for performance profiling only"
                - "Not needed in production scripts"
                - "Adds runtime overhead"
                - "External tools provide better metrics"
              external_tools:
                - "GNU time: /usr/bin/time -v ./script.sh"
                - "hyperfine: hyperfine './script.sh'"
                - "perf: perf stat ./script.sh"
                - "valgrind: Memory profiling"
              refactoring_strategy:
                - "Instead of: times (embedded in script)"
                - "Use: /usr/bin/time -v ./script.sh (external profiling)"
                - "Benefits: No script modification, better metrics, statistical analysis"
                - "Linter should flag times usage as determinism violation"

          - id: "BUILTIN-018"
            title: "Document trap"
            status: "completed"
            priority: "MEDIUM"
            input: "trap 'cleanup' EXIT"
            rust: "Use Drop trait"
            purified: "trap 'cleanup' EXIT"
            test_name: "test_BUILTIN_018_trap_signal_handling"
            notes: "Already supported by command parsing infrastructure (BUILTIN-001)"

          - id: "BUILTIN-019"
            title: "Document umask"
            status: "completed"
            version: "v6.6.0"
            priority: "LOW"
            input: "umask 022"
            rust: "std::fs::set_permissions()"
            purified: "umask 022"
            test_name: "test_BUILTIN_019_umask_basic"
            notes: "umask is SUPPORTED but modifies global state. 4 tests document global state implications, idempotency concerns, and chmod as alternative."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_BUILTIN_019_umask_basic (passing)"
                - "test_BUILTIN_019_umask_global_state (passing)"
                - "test_BUILTIN_019_umask_idempotency_concern (passing)"
                - "test_BUILTIN_019_umask_explicit_chmod_alternative (passing)"
              lines_of_code: 157
              documentation: "Comprehensive documentation of umask: global state modification, idempotency concerns, best practices. Recommends chmod as explicit alternative."
              global_state_issues:
                - "umask modifies process-wide file creation mask"
                - "Affects all subsequent file operations"
                - "Cannot be scoped (applies to entire shell process)"
                - "Side effects persist across script boundaries"
              idempotency_concerns:
                - "umask changes global state permanently"
                - "Running script multiple times stacks umask calls"
                - "May override system/user defaults"
                - "Difficult to restore original value"
              best_practices:
                - "Set umask at start of script if needed"
                - "Document why specific umask is required"
                - "Save and restore original umask: old=$(umask); umask 022; ...; umask $old"
                - "Consider explicit chmod instead of umask"
              chmod_alternative:
                - "chmod is more explicit and localized"
                - "No global state modification"
                - "Clear intent in code"
                - "Easier to audit and understand"

          - id: "BUILTIN-020"
            title: "Document unset"
            status: "partial"
            priority: "HIGH"
            input: "unset VAR"
            rust: "unset_var(\"VAR\")"
            purified: "unset VAR"
            test_name: "test_unset_command_baseline"
            notes: "Function calls work (unset_var VAR), automatic scoping recognition is enhancement."
            red_phase_tests: "rash/tests/integration_tests.rs:1290-1336"
            version: "v1.2.1"

      - id: "4.2"
        name: "Bash Builtin Commands"
        tasks:
          - id: "BASH-BUILTIN-001"
            title: "Document alias"
            status: "completed"
            priority: "MEDIUM"
            input: "alias ll='ls -la'"
            rust: "Not supported (interactive feature)"
            purified: "Remove (use functions instead)"
            test_name: "test_BASH_BUILTIN_001_alias_to_function"
            notes: "Already supported by command parsing infrastructure (BUILTIN-001)"

          - id: "BASH-BUILTIN-002"
            title: "Document declare/typeset"
            status: "completed"
            priority: "MEDIUM"
            input: "declare -i num=5"
            rust: "let num: i32 = 5;"
            purified: "num=5"
            test_name: "test_BASH_BUILTIN_002_declare_to_assignment"
            notes: "Already supported by command parsing infrastructure (BUILTIN-001)"

          - id: "BASH-BUILTIN-003"
            title: "Document let"
            status: "completed"
            version: "v6.6.0"
            priority: "LOW"
            input: "let \"x = 5 + 3\""
            rust: "let x = 5 + 3;"
            purified: "x=$((5 + 3))"
            test_name: "test_BASH_BUILTIN_003_let_basic"
            notes: "let is Bash-specific. 4 tests document let and recommend POSIX $((...)) alternative for portability."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_BASH_BUILTIN_003_let_basic (passing)"
                - "test_BASH_BUILTIN_003_let_increment (passing)"
                - "test_BASH_BUILTIN_003_let_posix_alternative (passing)"
                - "test_BASH_BUILTIN_003_let_refactoring (passing)"
              lines_of_code: 156
              documentation: "Comprehensive documentation of let command and POSIX $((...)) alternative. Includes conversion rules for operators (+=, ++, --)."
              posix_issues:
                - "let is Bash-specific (not available in sh, dash)"
                - "$((...)) is POSIX-compliant (works in all shells)"
                - "let requires quoting, $((...)) does not"
              conversion_rules:
                - "let \"x = expr\" → x=$((expr))"
                - "let \"x += 1\" → x=$((x + 1))"
                - "let \"x++\" → x=$((x + 1))"
                - "let \"x--\" → x=$((x - 1))"
              portability:
                - "let: Bash, zsh only"
                - "$((...)):  All POSIX shells (sh, dash, bash, zsh, ksh)"
              purification_strategy:
                - "Convert all let to $((...)) for POSIX compliance"
                - "More explicit and readable"
                - "Standard shell arithmetic"

          - id: "BASH-BUILTIN-004"
            title: "Document local"
            status: "completed"
            priority: "MEDIUM"
            input: "func() { local var=5; }"
            rust: "fn func() { let var = 5; }"
            purified: "func() { _var=5; }"
            test_name: "test_BASH_BUILTIN_004_local_to_scoped_var"
            notes: "Parser updated to handle Token::Local keyword (lines 95, 277-292 in parser.rs)"

          - id: "BASH-BUILTIN-005"
            title: "Document printf"
            status: "partial"
            priority: "HIGH"
            input: "printf '%s %d\\n' \"Number:\" 42"
            rust: "printf_formatted(\"%s %d\\n\", \"Number:\", 42)"
            purified: "printf_formatted '%s %d\n' Number: 42"
            test_name: "test_printf_preservation_baseline"
            notes: "Function calls work (printf_formatted), println! macro recognition is enhancement."
            red_phase_tests: "rash/tests/integration_tests.rs:1447-1521"
            version: "v1.2.1"

          - id: "BASH-BUILTIN-006"
            title: "Document readarray/mapfile"
            status: "completed"
            version: "v6.6.0"
            priority: "LOW"
            input: "readarray -t lines < file.txt"
            rust: "let lines: Vec<_> = read_lines(\"file.txt\")?;"
            purified: "while IFS= read -r line; do ... done < file.txt (POSIX)"
            test_name: "test_BASH_BUILTIN_006_readarray_not_supported"
            notes: "readarray/mapfile is Bash 4.0+ extension, NOT SUPPORTED. 5 passing tests document readarray as Bash-specific, POSIX while read alternative, transformation strategies, mapfile alias, and memory efficiency comparison."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_BASH_BUILTIN_006_readarray_not_supported (passing)"
                - "test_BASH_BUILTIN_006_posix_while_read_alternative (passing)"
                - "test_BASH_BUILTIN_006_transformation_strategy (passing)"
                - "test_BASH_BUILTIN_006_mapfile_alias_not_supported (passing)"
                - "test_BASH_BUILTIN_006_memory_efficiency_comparison (passing)"
              lines_of_code: 265
              documentation: "Comprehensive documentation of readarray/mapfile as Bash 4.0+ extension. NOT POSIX-compliant. POSIX alternative: while IFS= read -r loop. Transformation strategies for 3 common scenarios (process lines, store for later, count lines). Memory efficiency: while read is O(1) vs readarray O(n)."
              why_not_supported:
                - "Bash 4.0+ only (not in dash, ash, busybox sh)"
                - "Requires array support (not in POSIX sh)"
                - "Loads entire file into memory (not efficient for large files)"
              posix_alternative:
                - "while IFS= read -r line; do ... done < file.txt"
                - "IFS= prevents word splitting"
                - "read -r prevents backslash escaping"
                - "Streaming (one line at a time, memory efficient)"
              transformation_scenarios:
                - "Process all lines: while read loop replaces array iteration"
                - "Store for later: Use numbered variables (line_1, line_2, etc.)"
                - "Count lines: Increment counter in while loop"
              memory_efficiency:
                - "readarray: O(n) memory (loads entire file)"
                - "while read: O(1) memory (single line buffer)"
                - "while read handles files of ANY size"
              mapfile_alias:
                - "mapfile = readarray (exact same functionality)"
                - "Both require Bash 4.0+"
                - "Both NOT POSIX-compliant"

  - id: 5
    name: "Shell Variables"
    sections:
      - id: "5.1"
        name: "Bourne Shell Variables"
        tasks:
          - id: "VAR-001"
            title: "Document HOME"
            status: "partial"
            priority: "HIGH"
            input: "cd $HOME"
            rust: "use_home()"
            purified: "use_home"
            test_name: "test_home_variable_baseline"
            notes: "Function calls work (use_home), std::env::var(\"HOME\") recognition is enhancement."
            red_phase_tests: "rash/tests/integration_tests.rs:1523-1601"
            version: "v1.2.1"

          - id: "VAR-002"
            title: "Document PATH"
            status: "partial"
            priority: "HIGH"
            input: "PATH=\"/usr/local/bin:$PATH\""
            rust: "use_path()"
            purified: "use_path"
            test_name: "test_path_variable_baseline"
            notes: "Function calls work (use_path), std::env::var(\"PATH\") recognition is enhancement."
            red_phase_tests: "rash/tests/integration_tests.rs:1601-1686"
            version: "v1.2.1"

          - id: "VAR-003"
            title: "Document IFS purification"
            status: "completed"
            priority: "MEDIUM"
            input: "IFS=':'; read -ra parts <<< \"$PATH\""
            rust: "let parts: Vec<_> = path.split(':').collect();"
            purified: "Avoid IFS manipulation (use tr/cut)"
            test_name: "test_VAR_003_ifs_purification"
            notes: "Already supported by command parsing infrastructure (BUILTIN-001)"

          - id: "VAR-004"
            title: "Document PS1, PS2, PS3, PS4"
            status: "completed"
            version: "v6.6.0"
            priority: "LOW"
            input: "PS1='$ ', PS2='> ', PS3='#? ', PS4='+ '"
            rust: "Not applicable (no interactive mode)"
            purified: "Remove all prompt variables (not needed in scripts)"
            test_name: "test_VAR_004_ps1_prompt_not_supported"
            notes: "PS1, PS2, PS3, PS4 are interactive prompt variables, NOT SUPPORTED. 6 passing tests document PS1 (primary prompt), PS2 (continuation), PS3 (select), PS4 (debug trace), purification strategy, and script-mode-only philosophy."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_VAR_004_ps1_prompt_not_supported (passing)"
                - "test_VAR_004_ps2_continuation_prompt_not_supported (passing)"
                - "test_VAR_004_ps3_select_prompt_not_supported (passing)"
                - "test_VAR_004_ps4_debug_prompt_not_production (passing)"
                - "test_VAR_004_purification_removes_prompts (passing)"
                - "test_VAR_004_script_mode_only_philosophy (passing)"
              lines_of_code: 274
              documentation: "Comprehensive documentation of PS1, PS2, PS3, PS4 as interactive-only prompt variables. NOT supported in script mode. Purification removes all prompt variables and customization code. Script-mode-only philosophy: no prompts, no interactive input, fully automated execution."
              prompt_variables:
                - "PS1: Primary prompt (default: '$ ' or '# ' for root)"
                - "PS2: Continuation prompt for multi-line (default: '> ')"
                - "PS3: Prompt for select command (default: '#? ')"
                - "PS4: Debug trace prompt for set -x (default: '+ ')"
              why_not_supported:
                - "Interactive only (not used in scripts)"
                - "bashrs is script-mode-only (no interactive features)"
                - "POSIX sh scripts don't use prompts"
                - "Prompts displayed to users, not part of script logic"
              related_features:
                - "PROMPT_COMMAND (executed before each prompt)"
                - "PROMPT_DIRTRIM (directory name trimming in PS1)"
                - "PS0 (displayed after command read, before execution)"
              purification_strategy:
                - "Remove PS1, PS2, PS3, PS4 assignments"
                - "Remove prompt customization code"
                - "Scripts run non-interactively (no prompts displayed)"
              script_mode_characteristics:
                - "No prompts (PS1, PS2, PS3, PS4)"
                - "No user interaction (read, select)"
                - "Automated execution (no waiting for input)"
                - "Works in CI/CD, cron, Docker (no TTY)"

      - id: "5.2"
        name: "Bash Variables"
        tasks:
          - id: "BASH-VAR-001"
            title: "Document BASH_VERSION"
            status: "completed"
            version: "v6.6.0"
            priority: "LOW"
            input: "echo $BASH_VERSION"
            rust: "const VERSION: &str = \"1.0.0\";"
            purified: "Remove BASH_VERSION checks, use POSIX features only"
            test_name: "test_BASH_VAR_001_bash_version_not_supported"
            notes: "BASH_VERSION is Bash-specific variable, NOT SUPPORTED. 5 passing tests document BASH_VERSION as Bash-only, removal of version checks, BASH_VERSINFO array, portability philosophy, and purification strategy."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_BASH_VAR_001_bash_version_not_supported (passing)"
                - "test_BASH_VAR_001_remove_version_checks (passing)"
                - "test_BASH_VAR_001_bash_versinfo_not_supported (passing)"
                - "test_BASH_VAR_001_portability_over_version_detection (passing)"
                - "test_BASH_VAR_001_purification_removes_bash_version (passing)"
              lines_of_code: 269
              documentation: "Comprehensive documentation of BASH_VERSION and BASH_VERSINFO as Bash-specific variables. NOT POSIX-compliant. Purification removes version checks and version-dependent code paths. Philosophy: use POSIX features only, no version detection needed."
              why_not_supported:
                - "Bash-specific (not in dash, ash, busybox sh)"
                - "No POSIX equivalent"
                - "Script portability: should work regardless of shell version"
                - "Version checks violate POSIX-only policy"
              related_variables:
                - "BASH_VERSION (full version string)"
                - "BASH_VERSINFO (array with version components)"
                - "BASH_VERSINFO[0] (major version)"
                - "BASH_VERSINFO[1] (minor version)"
                - "BASH_VERSINFO[2] (patch version)"
              purification_strategy:
                - "Remove BASH_VERSION checks"
                - "Remove version-dependent code paths"
                - "Use only POSIX features (works everywhere)"
                - "Replace Bash-specific features with POSIX equivalents"
              philosophy:
                - "POSIX-only (no Bash-specific features)"
                - "No version detection (same code everywhere)"
                - "Maximum portability (works on minimal shells)"
                - "Simpler code (no version checks)"
                - "Better portability (works on any POSIX shell)"
                - "Fewer bugs (no version-specific code paths)"

          - id: "BASH-VAR-002"
            title: "Document RANDOM purification"
            status: "partial"
            priority: "HIGH"
            input: "num=$RANDOM"
            rust: "use_seed(42)"
            purified: "use_seed 42"
            test_name: "test_random_purification_baseline"
            notes: "Verified $RANDOM not generated (deterministic values only). Function calls work (use_seed)."
            red_phase_tests: "rash/tests/integration_tests.rs:2344-2423"
            version: "v1.2.1"

          - id: "BASH-VAR-003"
            title: "Document SECONDS purification"
            status: "partial"
            priority: "MEDIUM"
            input: "echo $SECONDS"
            rust: "use_fixed_time(100)"
            purified: "use_fixed_time 100"
            test_name: "test_seconds_purification_baseline"
            notes: "Verified $SECONDS not generated (fixed durations only). Function calls work (use_fixed_time)."
            red_phase_tests: "rash/tests/integration_tests.rs:2657-2742"
            version: "v1.2.1"

  - id: 6
    name: "Bash Features"
    sections:
      - id: "6.1"
        name: "Arrays"
        tasks:
          - id: "ARRAY-001"
            title: "Document indexed arrays"
            status: "completed"
            priority: "MEDIUM"
            input: "arr=(1 2 3); echo ${arr[0]}"
            rust: "let arr = vec![1, 2, 3]; println!(\"{}\", arr[0]);"
            purified: "Use whitespace-separated strings (POSIX sh has no arrays)"
            test_name: "test_ARRAY_001_indexed_arrays"
            notes: "Basic identifier parsing supported. Full array syntax is bash-specific and not supported in POSIX sh."

          - id: "ARRAY-002"
            title: "Document associative arrays"
            status: "completed"
            version: "v6.6.0"
            priority: "LOW"
            input: "declare -A map; map[key]=value; ${map[key]}; ${!map[@]}; ${map[@]}"
            rust: "let mut map = HashMap::new(); map.insert(\"key\", \"value\");"
            purified: "config_host=\"localhost\"; config_port=\"8080\" # Separate variables instead"
            test_name: "test_ARRAY_002_associative_arrays_not_supported"
            notes: "Associative arrays (hash maps) introduced in Bash 4.0 (2009), NOT SUPPORTED (Bash extension, not POSIX). declare -A creates associative array, map[key]=value sets value for key, ${map[key]} retrieves value, ${!map[@]} gets all keys, ${map[@]} gets all values. Bash 4.0+ only (macOS ships with 3.2), not available in sh/dash/ash. Purification uses separate variables (config_host, config_port pattern), indexed arrays with key:value parsing, or case statements for lookups. Use cases: config management, counters/histograms, key-value lookups, caching - all have POSIX alternatives."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_ARRAY_002_associative_arrays_not_supported (passing)"
                - "test_ARRAY_002_declare_uppercase_a (passing)"
                - "test_ARRAY_002_associative_array_operations (passing)"
                - "test_ARRAY_002_purification_uses_separate_variables (passing)"
                - "test_ARRAY_002_indexed_array_alternative (passing)"
                - "test_ARRAY_002_bash_version_compatibility (passing)"
                - "test_ARRAY_002_use_cases_and_alternatives (passing)"
                - "test_ARRAY_002_bash_vs_posix_arrays (passing)"
              lines_of_code: 442

      - id: "6.2"
        name: "The Directory Stack (pushd/popd)"
        tasks:
          - id: "DIRSTACK-001"
            title: "Document pushd/popd"
            status: "completed"
            version: "v6.6.0"
            priority: "LOW"
            input: "pushd /tmp, popd, dirs, dirs -v, pushd +N, DIRSTACK"
            rust: "Not supported (use explicit cd tracking)"
            purified: "_prev_dir=\"$(pwd)\"; cd /tmp || exit 1; cd \"$_prev_dir\" || exit 1"
            test_name: "test_DIRSTACK_001_pushd_not_supported"
            notes: "pushd/popd maintain directory stack for navigation, NOT SUPPORTED (implicit state). 8 passing tests document pushd command (push directory onto stack and cd), popd command (pop directory from stack and cd), dirs command (display directory stack with -c/-l/-p/-v options), purification uses explicit cd (save/restore with variables + error checking), pushd/popd options (swap/rotate stack), DIRSTACK variable (Bash-specific read-only array), cd - alternative (POSIX-compliant using OLDPWD), and interactive vs script directory navigation (implicit stack vs explicit variables)."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_DIRSTACK_001_pushd_not_supported (passing)"
                - "test_DIRSTACK_001_popd_not_supported (passing)"
                - "test_DIRSTACK_001_dirs_command (passing)"
                - "test_DIRSTACK_001_purification_uses_explicit_cd (passing)"
                - "test_DIRSTACK_001_pushd_popd_options (passing)"
                - "test_DIRSTACK_001_dirstack_variable (passing)"
                - "test_DIRSTACK_001_cd_minus_alternative (passing)"
                - "test_DIRSTACK_001_interactive_vs_script_directory_navigation (passing)"
              lines_of_code: 385

      - id: "6.3"
        name: "Controlling the Prompt"
        tasks:
          - id: "PROMPT-001"
            title: "Document PROMPT_COMMAND"
            status: "completed"
            version: "v6.6.0"
            priority: "LOW"
            input: "PROMPT_COMMAND='date', PROMPT_COMMAND=('cmd1' 'cmd2' 'cmd3')"
            rust: "Not applicable (no interactive mode)"
            purified: "Remove all PROMPT_COMMAND assignments (not needed in script mode)"
            test_name: "test_PROMPT_001_prompt_command_not_supported"
            notes: "PROMPT_COMMAND is interactive-only hook executed before each PS1 prompt, NOT SUPPORTED. 6 passing tests document basic form, array form (Bash 4.4+), purification strategy, common patterns (window title, git status, timing, history), script alternatives (explicit timing/logging), and interactive vs script mode hooks (PROMPT_COMMAND vs EXIT trap)."
            implementation:
              module: "rash/src/bash_parser/tests.rs"
              functions:
                - "test_PROMPT_001_prompt_command_not_supported (passing)"
                - "test_PROMPT_001_prompt_command_array_form (passing)"
                - "test_PROMPT_001_purification_removes_prompt_command (passing)"
                - "test_PROMPT_001_common_prompt_command_patterns (passing)"
                - "test_PROMPT_001_script_alternatives_to_prompt_command (passing)"
                - "test_PROMPT_001_interactive_vs_script_mode_hooks (passing)"
              lines_of_code: 291

  - id: 7
    name: "Job Control"
    tasks:
      - id: "JOB-001"
        title: "Document background jobs (&)"
        status: "partial"
        priority: "HIGH"
        input: "cmd &"
        rust: "run_foreground()"
        purified: "run_foreground"
        test_name: "test_background_jobs_purification_baseline"
        notes: "Verified & not generated (foreground execution only). Function calls work (run_foreground)."
        red_phase_tests: "rash/tests/integration_tests.rs:2751-2839"
        version: "v1.2.1"

      - id: "JOB-002"
        title: "Document jobs command"
        status: "completed"
        version: "v6.6.0"
        priority: "LOW"
        input: "jobs, jobs -l, jobs -r, jobs -s"
        rust: "Not supported (no job control)"
        purified: "Remove (scripts run foreground only)"
        test_name: "test_JOB_002_jobs_command_not_supported"
        notes: "jobs command lists background jobs, NOT SUPPORTED (interactive job control). 6 passing tests document basic usage, output format (job number, status, command), purification strategy, job control requirements (TTY, set -m, signals), script alternatives (sequential execution, ps, wait), and interactive vs script job control (jobs/fg/bg vs wait/ps/kill)."
        implementation:
          module: "rash/src/bash_parser/tests.rs"
          functions:
            - "test_JOB_002_jobs_command_not_supported (passing)"
            - "test_JOB_002_jobs_command_output_format (passing)"
            - "test_JOB_002_purification_removes_jobs (passing)"
            - "test_JOB_002_job_control_requirements (passing)"
            - "test_JOB_002_script_alternatives_to_jobs (passing)"
            - "test_JOB_002_interactive_vs_script_job_control (passing)"
          lines_of_code: 309

      - id: "JOB-003"
        title: "Document fg/bg commands"
        status: "completed"
        version: "v6.6.0"
        priority: "LOW"
        input: "fg %1, bg %1, fg %sleep, fg %%, fg %+, fg %-"
        rust: "Not supported (no job control)"
        purified: "Remove (scripts run foreground only, no job state management)"
        test_name: "test_JOB_003_fg_command_not_supported"
        notes: "fg (foreground) and bg (background) commands manage job execution state, NOT SUPPORTED (interactive job control). 7 passing tests document fg command syntax, bg command syntax, job specifications (%n/%string/%%/%+/%-), purification removes fg/bg, interactive fg/bg workflow (suspend/resume), script alternatives (sequential execution), and interactive vs script execution models (multi-job switching vs single-job sequential)."
        implementation:
          module: "rash/src/bash_parser/tests.rs"
          functions:
            - "test_JOB_003_fg_command_not_supported (passing)"
            - "test_JOB_003_bg_command_not_supported (passing)"
            - "test_JOB_003_job_specifications (passing)"
            - "test_JOB_003_purification_removes_fg_bg (passing)"
            - "test_JOB_003_fg_bg_workflow (passing)"
            - "test_JOB_003_script_alternatives_to_fg_bg (passing)"
            - "test_JOB_003_interactive_vs_script_execution_model (passing)"
          lines_of_code: 368

  - id: 8
    name: "Command Line Editing"
    tasks:
      - id: "EDIT-001"
        title: "Document readline features"
        status: "completed"
        version: "v6.6.0"
        priority: "LOW"
        input: "Ctrl+A, Ctrl+E, Ctrl+K, set -o emacs, set -o vi, bind, Tab completion"
        rust: "Not applicable (no interactive mode)"
        purified: "Not applicable (scripts execute commands directly without readline)"
        test_name: "test_EDIT_001_readline_not_supported"
        notes: "Readline provides interactive line editing, NOT SUPPORTED (interactive only). 7 passing tests document keyboard shortcuts (movement/editing/history/completion), Emacs/Vi editing modes (set -o emacs/vi), tab completion (command/file/variable/hostname/programmable), bind command (key bindings), history navigation (Up/Down/Ctrl+R), readline configuration (~/.inputrc), and interactive vs script input models (user types + readline edits vs predefined commands)."
        implementation:
          module: "rash/src/bash_parser/tests.rs"
          functions:
            - "test_EDIT_001_readline_not_supported (passing)"
            - "test_EDIT_001_emacs_vi_modes (passing)"
            - "test_EDIT_001_tab_completion (passing)"
            - "test_EDIT_001_bind_command (passing)"
            - "test_EDIT_001_history_navigation (passing)"
            - "test_EDIT_001_readline_configuration (passing)"
            - "test_EDIT_001_interactive_vs_script_input_model (passing)"
          lines_of_code: 350

  - id: 9
    name: "Using History Interactively"
    tasks:
      - id: "HISTORY-001"
        title: "Document history expansion"
        status: "completed"
        version: "v6.6.0"
        priority: "LOW"
        input: "!!, !$, !^, !*, !:n, !string, !?string, history, fc, HISTFILE"
        rust: "Not applicable (no interactive mode)"
        purified: "Remove (non-deterministic, use explicit variables instead)"
        test_name: "test_HISTORY_001_bang_bang_not_supported"
        notes: "History expansion allows referencing previous commands with ! (bang) notation, NOT SUPPORTED (interactive, non-deterministic). 8 passing tests document !! (repeat last), !$ (last argument), history expansion syntax (event designators/word designators/modifiers), purification removes history expansion (use explicit variables), history command (interactive management), fc command (fix command editing), history variables (HISTFILE/HISTSIZE/HISTCONTROL/HISTIGNORE), and interactive vs script history models (persistent history buffer vs stateless execution)."
        implementation:
          module: "rash/src/bash_parser/tests.rs"
          functions:
            - "test_HISTORY_001_bang_bang_not_supported (passing)"
            - "test_HISTORY_001_bang_dollar_not_supported (passing)"
            - "test_HISTORY_001_history_expansion_syntax (passing)"
            - "test_HISTORY_001_purification_removes_history_expansion (passing)"
            - "test_HISTORY_001_history_command (passing)"
            - "test_HISTORY_001_fc_command (passing)"
            - "test_HISTORY_001_history_variables (passing)"
            - "test_HISTORY_001_interactive_vs_script_history_model (passing)"
          lines_of_code: 413

completed_features:
  - title: "Shebang transformation (#!/bin/bash → #!/bin/sh)"
    version: "v1.3.0"
    tasks: ["1.1"]
    tests: 3
    methodology: "EXTREME TDD + Property Testing"

  - title: "Until loop transformation (until → while !)"
    version: "v1.3.0"
    tasks: ["LOOP-001"]
    tests: 4
    methodology: "EXTREME TDD + Property Testing"

  - title: "Default value expansion (${VAR:-default})"
    version: "v1.3.0"
    tasks: ["EXP-PARAM-001"]
    tests: 4
    methodology: "EXTREME TDD + Property Testing"

  - title: "Assign default expansion (${VAR:=default})"
    version: "v1.3.0"
    tasks: ["EXP-PARAM-002"]
    tests: 4
    methodology: "EXTREME TDD + Property Testing"

  - title: "Glob pattern transformation (*.txt, *.log, etc.)"
    version: "v1.3.0"
    tasks: ["EXP-GLOB-001"]
    tests: 4
    methodology: "EXTREME TDD + Property Testing"

  - title: "Error-if-unset expansion (${VAR:?message})"
    version: "v1.3.0"
    tasks: ["EXP-PARAM-003"]
    tests: 4
    methodology: "EXTREME TDD + Property Testing"

  - title: "Alternative value expansion (${VAR:+alt_value})"
    version: "v1.3.0"
    tasks: ["EXP-PARAM-004"]
    tests: 4
    methodology: "EXTREME TDD + Property Testing"

  - title: "String length expansion (${#VAR})"
    version: "v1.3.0"
    tasks: ["EXP-PARAM-005"]
    tests: 4
    methodology: "EXTREME TDD + Property Testing"

  - title: "Remove suffix expansion (${VAR%pattern})"
    version: "v1.3.0"
    tasks: ["EXP-PARAM-006"]
    tests: 4
    methodology: "EXTREME TDD + Property Testing"

  - title: "Remove prefix expansion (${VAR#pattern})"
    version: "v1.3.0"
    tasks: ["EXP-PARAM-007"]
    tests: 4
    methodology: "EXTREME TDD + Property Testing"

  - title: "Remove longest prefix expansion (${VAR##pattern})"
    version: "v1.3.0"
    tasks: ["EXP-PARAM-008"]
    tests: 4
    methodology: "EXTREME TDD + Property Testing"

  - title: "Remove longest suffix expansion (${VAR%%pattern})"
    version: "v1.3.0"
    tasks: ["EXP-PARAM-009"]
    tests: 4
    methodology: "EXTREME TDD + Property Testing"

  - title: "While loops"
    version: "v0.8.0"
    tasks: ["LOOP-002"]

  - title: "For loops"
    version: "v0.5.0"
    tasks: ["LOOP-003"]

  - title: "If/else statements"
    version: "v0.4.0"
    tasks: ["COND-001"]

  - title: "Case/match statements"
    version: "v0.6.0"
    tasks: ["COND-002"]

  - title: "Functions"
    version: "v0.4.0"
    tasks: ["FUNC-001"]

  - title: "Return values"
    version: "v0.4.0"
    tasks: ["FUNC-002"]

  - title: "Command substitution"
    version: "v0.4.0"
    tasks: ["EXP-CMD-001"]

  - title: "Arithmetic expansion"
    version: "v0.4.0"
    tasks: ["EXP-ARITH-001"]

  - title: "Break/continue"
    version: "v0.8.0"
    tasks: ["BUILTIN-003", "BUILTIN-004"]

  - title: "Echo transformation"
    version: "v0.4.0"
    tasks: ["BUILTIN-006"]

high_priority_next_tasks:
  description: "Next 20 tasks to implement"
  tasks:
    - id: "PARAM-POS-001"
      title: "Positional parameters ($1, $2)"
      priority: 1
      status: "🔴 BLOCKED - P0 (deferred to v1.3.0)"

    - id: "PARAM-SPEC-001"
      title: "Special parameter $#"
      priority: 2
      status: "🔴 BLOCKED - P0 (deferred to v1.3.0)"

    - id: "PARAM-SPEC-002"
      title: "Special parameter $?"
      priority: 3

    - id: "EXP-PARAM-001"
      title: "String parameter expansion (${var:-default})"
      priority: 4

    - id: "REDIR-001"
      title: "Input redirection (<)"
      priority: 5

    - id: "REDIR-002"
      title: "Output redirection (>, >>)"
      priority: 6

    - id: "REDIR-003"
      title: "Combined redirection (&>)"
      priority: 7

    - id: "REDIR-004"
      title: "Here documents (<<)"
      priority: 8

    - id: "BUILTIN-005"
      title: "cd command"
      priority: 9

    - id: "BUILTIN-011"
      title: "pwd command"
      priority: 10

    - id: "BUILTIN-009"
      title: "exit command"
      priority: 11

    - id: "BUILTIN-010"
      title: "export command"
      priority: 12

    - id: "BUILTIN-020"
      title: "unset command"
      priority: 13

    - id: "BUILTIN-016"
      title: "test/[ command"
      priority: 14

    - id: "BASH-BUILTIN-005"
      title: "printf preservation"
      priority: 15

    - id: "VAR-001"
      title: "PATH variable"
      priority: 16

    - id: "VAR-002"
      title: "HOME variable"
      priority: 17

    - id: "EXP-PARAM-005"
      title: "String length ${#var}"
      priority: 18

    - id: "EXP-PARAM-006"
      title: "Remove suffix ${var%suffix}"
      priority: 19

    - id: "BASH-VAR-002"
      title: "Remove RANDOM (non-deterministic)"
      priority: 20

next_steps:
  - "Start with high priority tasks (positional parameters, special vars)"
  - "Follow EXTREME TDD religiously (test-first, always)"
  - "Document each transformation with examples"
  - "Track progress in this roadmap (update task status)"
  - "Release incrementally (v1.3.0, v1.4.0, etc.)"

status:
  overall: "IN_PROGRESS"
  completion_percent: 20
  completed_tasks: 24
  partial_support_tasks: 16
  blocked_tasks: 3
  pending_tasks: 79
  total_tasks: 122
  methodology: "EXTREME TDD (RED-GREEN-REFACTOR) + Property Testing"
  goal: "100% Bash manual coverage"
  accuracy_verified: "2025-10-26"
  last_completed:
    task_id: "EXP-PARAM-009"
    title: "Remove longest suffix expansion (${VAR%%pattern})"
    version: "v1.3.0"
    date: "2025-10-15"
