# Sprint 27b: Command-Line Arguments Support

```yaml
sprint:
  name: "Sprint 27b - Command-Line Arguments"
  parent: "Sprint 27 - Core Shell Features Enhancement"
  status: "in_progress"
  priority: "P1_HIGH"
  duration: "2-3 hours"
  philosophy: "自働化 (Jidoka) - Build quality in through EXTREME TDD"
  methodology: "RED-GREEN-REFACTOR"

follows:
  sprint: "Sprint 27a - Environment Variables"
  pattern: "Same 4-layer architecture and TDD approach"
  success: "824 tests passing, proven methodology"
```

## Overview

Sprint 27b implements command-line argument access in Rash, enabling Rust code to read shell script arguments through stdlib functions. This follows the successful pattern from Sprint 27a (environment variables).

## Objectives

### Primary Goals

1. **Implement `arg(position)` function** - Access specific command-line argument
2. **Implement `args()` function** - Access all arguments as array
3. **Implement `arg_count()` function** - Get number of arguments
4. **Generate safe POSIX shell syntax** - `$1`, `$2`, `$@`, `$#`
5. **Maintain 100% test pass rate** - All 824+ tests must pass
6. **Apply EXTREME TDD** - RED-GREEN-REFACTOR methodology

### Success Criteria

- [x] Specification written
- [ ] 10-12 RED tests written (failing by design)
- [ ] All tests compile but fail
- [ ] 4-layer implementation complete (IR, Stdlib, Converter, Emitter)
- [ ] All tests pass (824 → 834+)
- [ ] Zero new clippy warnings
- [ ] Code formatted with cargo fmt
- [ ] Committed and pushed to GitHub
- [ ] ROADMAP updated

## Scope

### In Scope (Sprint 27b)

- ✅ `arg(position: usize)` - Get specific argument by position
- ✅ `args()` - Get all arguments as array/vector
- ✅ `arg_count()` - Get count of arguments
- ✅ POSIX shell generation: `$1`, `$2`, `$@`, `$#`
- ✅ Proper quoting for safety
- ✅ Security validation (position bounds checking)

### Out of Scope (Future Sprints)

- ❌ `$0` (script name) - Sprint 27c
- ❌ `$?` (exit code) - Sprint 27c
- ❌ `$$` (process ID) - Sprint 27d
- ❌ `$!` (background PID) - Sprint 27d
- ❌ Argument parsing/flags - Future

## Design

### Rust API

```rust
// Access specific arguments by position
fn main() {
    let first_arg = arg(1);      // First argument
    let second_arg = arg(2);     // Second argument

    // Get all arguments
    let all_args = args();       // All arguments as array

    // Get argument count
    let count = arg_count();     // Number of arguments

    println!("First: {}", first_arg);
    println!("Count: {}", count);
}
```

### Generated POSIX Shell

```bash
#!/bin/sh
# Generated by Rash v1.3.0

main() {
    first_arg="$1"
    second_arg="$2"

    # args() generates special handling for $@
    all_args="$@"

    # arg_count() uses $#
    count="$#"

    rash_println "First: ${first_arg}"
    rash_println "Count: ${count}"
}

main "$@"
```

### Shell Variable Mappings

| Rash Function | Shell Syntax | Description |
|---------------|--------------|-------------|
| `arg(1)` | `$1` | First argument |
| `arg(2)` | `$2` | Second argument |
| `arg(n)` | `$n` | Nth argument |
| `args()` | `$@` | All arguments (array) |
| `arg_count()` | `$#` | Argument count |

## Architecture

### 4-Layer Implementation Pattern

Following Sprint 27a's proven architecture:

#### Layer 1: IR (Intermediate Representation)

**File**: `src/ir/shell_ir.rs`

Add new variant to `ShellValue` enum:

```rust
pub enum ShellValue {
    // ... existing variants ...

    /// Command-line argument access: $1, $2, $@, $#
    /// Sprint 27b: Command-Line Arguments Support
    Arg {
        position: Option<usize>,  // None = all args ($@)
    },

    /// Argument count: $#
    ArgCount,
}
```

#### Layer 2: Stdlib Registry

**File**: `src/stdlib.rs`

Add to `is_stdlib_function()`:
```rust
matches!(
    name,
    // ... existing ...
    | "arg"
    | "args"
    | "arg_count"
)
```

Add metadata:
```rust
StdlibFunction {
    name: "arg",
    shell_name: "inline_positional_arg",
    module: "args",
    description: "Get command-line argument by position",
},
StdlibFunction {
    name: "args",
    shell_name: "inline_all_args",
    module: "args",
    description: "Get all command-line arguments",
},
StdlibFunction {
    name: "arg_count",
    shell_name: "inline_arg_count",
    module: "args",
    description: "Get command-line argument count",
},
```

#### Layer 3: Converter

**File**: `src/ir/mod.rs`

Add special handling in `convert_expr_to_value()`:

```rust
if name == "arg" {
    // Extract position from first argument
    let position = match &args[0] {
        Expr::Literal(Literal::Int(n)) => *n as usize,
        _ => return Err(Error::Validation(
            "arg() requires integer literal for position".to_string()
        )),
    };

    // Validate position (must be >= 1)
    if position == 0 {
        return Err(Error::Validation(
            "arg() position must be >= 1 (use arg(1) for first argument)".to_string()
        ));
    }

    return Ok(ShellValue::Arg { position: Some(position) });
}

if name == "args" {
    return Ok(ShellValue::Arg { position: None });  // None = $@
}

if name == "arg_count" {
    return Ok(ShellValue::ArgCount);
}
```

#### Layer 4: Emitter

**File**: `src/emitter/posix.rs`

Add to `emit_shell_value()`:

```rust
// Sprint 27b: Command-line argument access
ShellValue::Arg { position } => {
    match position {
        Some(n) => Ok(format!("\"${}\"", n)),        // "$1", "$2", etc.
        None => Ok("\"$@\"".to_string()),           // All args
    }
}

ShellValue::ArgCount => {
    Ok("\"$#\"".to_string())                        // Argument count
}
```

Add to `append_concat_part()`:

```rust
// Sprint 27b: Command-line argument access in concatenation
ShellValue::Arg { position } => {
    match position {
        Some(n) => result.push_str(&format!("${}", n)),
        None => result.push_str("$@"),
    }
}

ShellValue::ArgCount => {
    result.push_str("$#");
}
```

## Test Plan (RED Phase)

### Module 1: stdlib.rs (3 tests)

```rust
#[test]
fn test_stdlib_arg_function_recognized() {
    assert!(is_stdlib_function("arg"),
            "arg() should be recognized as stdlib function");
}

#[test]
fn test_stdlib_args_function_recognized() {
    assert!(is_stdlib_function("args"),
            "args() should be recognized as stdlib function");
}

#[test]
fn test_stdlib_arg_count_function_recognized() {
    assert!(is_stdlib_function("arg_count"),
            "arg_count() should be recognized as stdlib function");
}
```

### Module 2: ir/tests.rs (4 tests)

```rust
#[test]
fn test_arg_call_converts_to_ir() {
    // Test: arg(1) → Arg { position: Some(1) }
    let code = "let first = arg(1);";
    let ir = parse_and_convert(code).unwrap();

    // Should contain Arg variant with position 1
    assert!(matches_arg_ir(&ir, Some(1)));
}

#[test]
fn test_args_call_converts_to_ir() {
    // Test: args() → Arg { position: None }
    let code = "let all = args();";
    let ir = parse_and_convert(code).unwrap();

    // Should contain Arg variant with None position
    assert!(matches_arg_ir(&ir, None));
}

#[test]
fn test_arg_count_converts_to_ir() {
    // Test: arg_count() → ArgCount
    let code = "let count = arg_count();";
    let ir = parse_and_convert(code).unwrap();

    // Should contain ArgCount variant
    assert!(contains_arg_count_ir(&ir));
}

#[test]
fn test_arg_rejects_zero_position() {
    // Test: arg(0) should be rejected
    let code = "let x = arg(0);";
    let result = parse_and_convert(code);

    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("position must be >= 1"));
}
```

### Module 3: emitter/tests.rs (5 tests)

```rust
#[test]
fn test_arg_emits_positional_syntax() {
    // Test: arg(1) → "$1", arg(2) → "$2"
    let ir = ShellIR::Let {
        name: "first".to_string(),
        value: ShellValue::Arg { position: Some(1) },
        effects: EffectSet::pure(),
    };

    let output = emit(&ir, &Config::default()).unwrap();
    assert!(output.contains("first=\"$1\""));
}

#[test]
fn test_args_emits_all_args_syntax() {
    // Test: args() → "$@"
    let ir = ShellIR::Let {
        name: "all".to_string(),
        value: ShellValue::Arg { position: None },
        effects: EffectSet::pure(),
    };

    let output = emit(&ir, &Config::default()).unwrap();
    assert!(output.contains("all=\"$@\""));
}

#[test]
fn test_arg_count_emits_count_syntax() {
    // Test: arg_count() → "$#"
    let ir = ShellIR::Let {
        name: "count".to_string(),
        value: ShellValue::ArgCount,
        effects: EffectSet::pure(),
    };

    let output = emit(&ir, &Config::default()).unwrap();
    assert!(output.contains("count=\"$#\""));
}

#[test]
fn test_args_quoted_for_safety() {
    // Test: All arg accesses must be quoted
    let ir = ShellIR::Sequence(vec![
        ShellIR::Let {
            name: "x".to_string(),
            value: ShellValue::Arg { position: Some(1) },
            effects: EffectSet::pure(),
        },
        ShellIR::Let {
            name: "y".to_string(),
            value: ShellValue::Arg { position: None },
            effects: EffectSet::pure(),
        },
    ]);

    let output = emit(&ir, &Config::default()).unwrap();

    // Must have quoted versions
    assert!(output.contains("\"$1\""));
    assert!(output.contains("\"$@\""));
}

#[test]
fn test_multiple_args_in_sequence() {
    // Test: Multiple arg() calls in one statement
    let ir = ShellIR::Sequence(vec![
        ShellIR::Let {
            name: "first".to_string(),
            value: ShellValue::Arg { position: Some(1) },
            effects: EffectSet::pure(),
        },
        ShellIR::Let {
            name: "second".to_string(),
            value: ShellValue::Arg { position: Some(2) },
            effects: EffectSet::pure(),
        },
        ShellIR::Let {
            name: "count".to_string(),
            value: ShellValue::ArgCount,
            effects: EffectSet::pure(),
        },
    ]);

    let output = emit(&ir, &Config::default()).unwrap();

    assert!(output.contains("first=\"$1\""));
    assert!(output.contains("second=\"$2\""));
    assert!(output.contains("count=\"$#\""));
}
```

### Total: 12 RED Tests

- **stdlib.rs**: 3 tests (function recognition)
- **ir/tests.rs**: 4 tests (conversion + validation)
- **emitter/tests.rs**: 5 tests (shell generation + quoting)

## Security Considerations

### Position Validation

**Rule**: `arg(n)` position must be >= 1

**Rationale**:
- `$0` is script name, not an argument
- POSIX shell arguments start at `$1`
- Prevents confusion and errors

**Implementation**:
```rust
if position == 0 {
    return Err(Error::Validation(
        "arg() position must be >= 1".to_string()
    ));
}
```

### Quoting Strategy

**Rule**: All argument accesses must be quoted

**Rationale**:
- Prevents word splitting on spaces
- Safe handling of special characters
- POSIX compliance

**Examples**:
```bash
# Correct (quoted):
first="$1"
all="$@"

# Incorrect (unquoted - word splitting issues):
first=$1      # DANGEROUS
all=$@        # DANGEROUS
```

## Edge Cases

### Empty Arguments

```rust
// If no arguments provided:
arg(1)        // Returns empty string ""
args()        // Returns empty array
arg_count()   // Returns 0
```

**Shell behavior**:
```bash
$ ./script.sh
# $1 is unset → ""
# $@ is empty → ""
# $# is 0
```

### Large Position Numbers

```rust
arg(99)  // Valid - generates "$99"
arg(100) // Valid but unusual
```

**Note**: Shell supports `${10}` and above with brace syntax. Our implementation uses braces for all positions for consistency.

## Implementation Timeline

### RED Phase (30-45 minutes)

1. Write 3 stdlib tests
2. Write 4 IR conversion tests
3. Write 5 emitter tests
4. Verify all tests compile but fail
5. Commit: "test: Sprint 27b RED phase - 12 tests written"

### GREEN Phase (60-90 minutes)

1. Add `ShellValue::Arg` and `ArgCount` variants
2. Register stdlib functions
3. Implement converter logic with validation
4. Implement emitter logic
5. Run tests, fix any issues
6. Verify 834+ tests pass (824 + 10 new)
7. Run clippy, cargo fmt
8. Commit: "feat: Sprint 27b - Command-line arguments (GREEN phase)"

### REFACTOR Phase (Optional, 15-30 minutes)

1. Extract helper functions if needed
2. Add documentation comments
3. Optimize if opportunities found
4. Commit: "refactor: Sprint 27b code cleanup"

## Quality Gates

Must pass before completion:

- [ ] All tests pass (834+/834+)
- [ ] Zero compilation errors
- [ ] Zero new clippy warnings
- [ ] Code formatted with cargo fmt
- [ ] Security validation working (position >= 1)
- [ ] Proper quoting in all cases
- [ ] ROADMAP updated
- [ ] Completion report written

## Toyota Way Principles

### 自働化 (Jidoka) - Build Quality In
- Write tests BEFORE implementation (EXTREME TDD)
- Zero defects policy (100% test pass rate)
- Quality gates enforced

### 現地現物 (Genchi Genbutsu) - Direct Observation
- Test against POSIX shell requirements
- Verify quoting with real shells
- Validate security with edge cases

### 改善 (Kaizen) - Continuous Improvement
- Apply learnings from Sprint 27a
- Improve test quality
- Refine development process

### 反省 (Hansei) - Reflection
- Document test bugs if found
- Root cause analysis for failures
- Capture learnings

## References

- Sprint 27a: Environment Variables (completed successfully)
- POSIX Shell Command Language: Positional Parameters
- Bash Reference Manual: Shell Parameters

## Notes

- Follow Sprint 27a pattern exactly - it worked perfectly
- Be careful with escaping in test assertions (learned from 27a)
- Trust the TDD process - RED failures are expected and good
- Security first: validate position >= 1

---

**Status**: 🟡 **IN PROGRESS** (Specification complete, ready for RED phase)
**Next**: Write 12 RED tests
**Pattern**: EXTREME TDD (RED-GREEN-REFACTOR)
