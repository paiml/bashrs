# Sprint 27c: Exit Code Handling

```yaml
sprint:
  name: "Sprint 27c - Exit Code Handling"
  parent: "Sprint 27 - Core Shell Features Enhancement"
  status: "in_progress"
  priority: "P1_HIGH"
  duration: "1-2 hours"
  philosophy: "è‡ªåƒåŒ– (Jidoka) - Build quality in through EXTREME TDD"
  methodology: "RED-GREEN-REFACTOR"

follows:
  sprint: "Sprint 27b - Command-Line Arguments"
  pattern: "Same 4-layer architecture and TDD approach"
  success: "838 tests passing, zero errors during implementation"
```

## Overview

Sprint 27c implements exit code handling in Rash, enabling Rust code to access the exit status of the previous command through stdlib functions. This follows the successful pattern from Sprints 27a (environment variables) and 27b (command-line arguments).

## Objectives

### Primary Goals

1. **Implement `exit_code()` function** - Access last command's exit status
2. **Generate safe POSIX shell syntax** - `$?`
3. **Maintain 100% test pass rate** - All 838+ tests must pass
4. **Apply EXTREME TDD** - RED-GREEN-REFACTOR methodology
5. **Complete in 1-2 hours** - Simpler than 27a/27b (only one function)

### Success Criteria

- [ ] Specification written
- [ ] 8-10 RED tests written (failing by design)
- [ ] All tests compile but fail
- [ ] 4-layer implementation complete (IR, Stdlib, Converter, Emitter)
- [ ] All tests pass (838 â†’ 846+)
- [ ] Zero new clippy warnings
- [ ] Code formatted with cargo fmt
- [ ] Committed and pushed to GitHub
- [ ] ROADMAP updated

## Scope

### In Scope (Sprint 27c)

- âœ… `exit_code()` - Get exit status of last command ($?)
- âœ… POSIX shell generation: `$?`
- âœ… Proper quoting for safety
- âœ… Integration with command execution

### Out of Scope (Future Sprints)

- âŒ `$0` (script name) - Future sprint
- âŒ `$$` (process ID) - Sprint 27d
- âŒ `$!` (background PID) - Sprint 27d
- âŒ `$-` (shell flags) - Future
- âŒ Exit code handling/manipulation - Future

## Design

### Rust API

```rust
use rash_stdlib::{exit_code, exec};

fn main() -> Result<(), String> {
    // Run a command
    exec("ls", &["-la"])?;

    // Check exit code
    let status = exit_code();

    if status == "0" {
        println!("Success!");
    } else {
        println!("Failed with code: {}", status);
    }

    Ok(())
}
```

### Generated POSIX Shell

```bash
#!/bin/sh
# Generated by Rash v1.3.0

main() {
    # Run command
    ls -la

    # Capture exit code immediately after command
    status="$?"

    if [ "${status}" = "0" ]; then
        printf '%s\n' "Success!"
    else
        printf '%s\n' "Failed with code: ${status}"
    fi
}

main "$@"
```

### Shell Variable Mapping

| Rash Function | Shell Syntax | Description |
|---------------|--------------|-------------|
| `exit_code()` | `$?` | Exit status of last command |

## Architecture

### 4-Layer Implementation Pattern

Following Sprints 27a and 27b's proven architecture:

#### Layer 1: IR (Intermediate Representation)

**File**: `src/ir/shell_ir.rs`

Add new variant to `ShellValue` enum:

```rust
pub enum ShellValue {
    // ... existing variants ...

    /// Exit code of last command: $?
    /// Sprint 27c: Exit Code Handling
    ExitCode,
}
```

**Simpler than 27a/27b**: Only one variant needed (no parameters like EnvVar or Arg)

#### Layer 2: Stdlib Registry

**File**: `src/stdlib.rs`

Add to `is_stdlib_function()`:
```rust
matches!(
    name,
    // ... existing ...
    | "exit_code"
)
```

Add metadata:
```rust
StdlibFunction {
    name: "exit_code",
    shell_name: "inline_exit_code",
    module: "status",
    description: "Get exit status of last command (inline $?)",
},
```

#### Layer 3: Converter

**File**: `src/ir/mod.rs`

Add special handling in `convert_expr_to_value()`:

```rust
// Sprint 27c: Handle exit_code() specially
if name == "exit_code" {
    return Ok(ShellValue::ExitCode);
}
```

**Note**: Simpler than 27a/27b - no argument extraction or validation needed!

#### Layer 4: Emitter

**File**: `src/emitter/posix.rs`

Add to `emit_shell_value()`:

```rust
// Sprint 27c: Exit code access
ShellValue::ExitCode => Ok("\"$?\"".to_string()),
```

Add to `append_concat_part()`:

```rust
// Sprint 27c: Exit code in concatenation
ShellValue::ExitCode => {
    result.push_str("$?");
}
```

## Test Plan (RED Phase)

### Module 1: stdlib.rs (2 tests)

```rust
#[test]
fn test_stdlib_exit_code_function_recognized() {
    assert!(is_stdlib_function("exit_code"),
            "exit_code() should be recognized as stdlib function");
}

#[test]
fn test_stdlib_exit_code_metadata() {
    let metadata = get_stdlib_metadata("exit_code");
    assert!(metadata.is_some());
    assert_eq!(metadata.unwrap().module, "status");
}
```

### Module 2: ir/tests.rs (3 tests)

```rust
#[test]
fn test_exit_code_call_converts_to_ir() {
    // Test: exit_code() â†’ ExitCode
    let code = r#"
        fn main() -> Result<(), String> {
            let status = exit_code();
            Ok(())
        }
    "#;

    let program = syn::parse_str(code).unwrap();
    let ir = IrConverter::convert(&program).unwrap();

    // Should contain ExitCode variant
    match &ir {
        ShellIR::Sequence(items) => {
            let found = items.iter().any(|item| {
                if let ShellIR::Let { value, .. } = item {
                    matches!(value, ShellValue::ExitCode)
                } else {
                    false
                }
            });
            assert!(found, "Should contain ExitCode variant");
        }
        _ => panic!("Expected Sequence"),
    }
}

#[test]
fn test_exit_code_in_comparison() {
    // Test: exit_code() in if condition
    let code = r#"
        fn main() -> Result<(), String> {
            if exit_code() == "0" {
                println!("success");
            }
            Ok(())
        }
    "#;

    let program = syn::parse_str(code).unwrap();
    let ir = IrConverter::convert(&program).unwrap();

    // Should contain Comparison with ExitCode
    let contains_exit_code = contains_exit_code_in_ir(&ir);
    assert!(contains_exit_code, "Should contain exit_code() in comparison");
}

#[test]
fn test_multiple_exit_code_calls() {
    // Test: Multiple exit_code() calls
    let code = r#"
        fn main() -> Result<(), String> {
            let status1 = exit_code();
            let status2 = exit_code();
            Ok(())
        }
    "#;

    let program = syn::parse_str(code).unwrap();
    let ir = IrConverter::convert(&program).unwrap();

    // Should work fine (each call gets fresh $?)
    assert!(ir.is_ok());
}
```

### Module 3: emitter/tests.rs (4 tests)

```rust
#[test]
fn test_exit_code_emits_question_mark_syntax() {
    // Test: exit_code() â†’ "$?"
    let ir = ShellIR::Let {
        name: "status".to_string(),
        value: ShellValue::ExitCode,
        effects: EffectSet::pure(),
    };

    let config = Config::default();
    let output = emit_posix(&ir, &config).unwrap();

    assert!(output.contains("status=\"$?\""),
            "Should emit: status=\"$?\"");
}

#[test]
fn test_exit_code_in_comparison() {
    // Test: if exit_code() == "0"
    let ir = ShellIR::If {
        test: ShellValue::Comparison {
            op: ComparisonOp::StrEq,
            left: Box::new(ShellValue::ExitCode),
            right: Box::new(ShellValue::String("0".to_string())),
        },
        then_branch: Box::new(ShellIR::Echo {
            value: ShellValue::String("success".to_string()),
        }),
        else_branch: None,
    };

    let config = Config::default();
    let output = emit_posix(&ir, &config).unwrap();

    assert!(output.contains("[ \"$?\" = \"0\" ]"),
            "Should emit exit code comparison");
}

#[test]
fn test_exit_code_quoted_for_safety() {
    // Test: exit_code() is properly quoted
    let ir = ShellIR::Sequence(vec![
        ShellIR::Let {
            name: "x".to_string(),
            value: ShellValue::ExitCode,
            effects: EffectSet::pure(),
        },
        ShellIR::Let {
            name: "y".to_string(),
            value: ShellValue::ExitCode,
            effects: EffectSet::pure(),
        },
    ]);

    let config = Config::default();
    let output = emit_posix(&ir, &config).unwrap();

    // Must have quoted versions
    assert!(output.contains("\"$?\""),
            "Exit code accesses must be quoted");
}

#[test]
fn test_exit_code_in_concatenation() {
    // Test: "Exit code: " + exit_code()
    let ir = ShellIR::Let {
        name: "msg".to_string(),
        value: ShellValue::Concat(vec![
            ShellValue::String("Exit code: ".to_string()),
            ShellValue::ExitCode,
        ]),
        effects: EffectSet::pure(),
    };

    let config = Config::default();
    let output = emit_posix(&ir, &config).unwrap();

    assert!(output.contains("msg=\"Exit code: $?\""),
            "Should emit concatenated exit code");
}
```

### Total: 9 RED Tests

- **stdlib.rs**: 2 tests (function recognition + metadata)
- **ir/tests.rs**: 3 tests (conversion + usage patterns)
- **emitter/tests.rs**: 4 tests (shell generation + quoting + concatenation)

**Note**: Fewer tests than 27a/27b because:
- No argument extraction (unlike arg())
- No validation logic (unlike arg(0) check)
- Simpler API (single function, no parameters)

## Security Considerations

### Quoting Strategy

**Rule**: Exit code access must be quoted

**Rationale**:
- Consistent with other special variables ($1, $@, $#)
- Prevents word splitting (though $? is always numeric)
- POSIX compliance
- Best practice

**Examples**:
```bash
# Correct (quoted):
status="$?"

# Acceptable but less safe (unquoted):
status=$?

# We choose quoted for consistency
```

### Timing Consideration

**Important**: `$?` is only valid immediately after a command

```bash
# Correct:
ls -la
status="$?"  # Captures ls exit code

# Wrong:
ls -la
echo "done"
status="$?"  # This captures echo's exit code, NOT ls!
```

**Rust API Implication**:
```rust
// User must capture exit_code() immediately:
exec("ls", &["-la"])?;
let status = exit_code();  // Good - immediately after exec

// If they do this, it's their responsibility:
exec("ls", &["-la"])?;
println!("Done");
let status = exit_code();  // Captures println's exit code
```

## Edge Cases

### Multiple Calls

```rust
// Each call gets fresh $?
exec("ls")?;
let s1 = exit_code();  // ls exit code

exec("pwd")?;
let s2 = exit_code();  // pwd exit code
```

**Shell behavior**:
```bash
ls
s1="$?"  # ls exit code

pwd
s2="$?"  # pwd exit code
```

### Exit Code Range

POSIX exit codes are 0-255:
- `0` = success
- `1-255` = failure (various meanings)

Our implementation treats exit codes as strings (consistent with shell behavior).

## Implementation Timeline

### RED Phase (20-30 minutes)

**Simpler than 27a/27b**: No validation logic, fewer edge cases

1. Write 2 stdlib tests (10 min)
2. Write 3 IR conversion tests (10 min)
3. Write 4 emitter tests (10 min)
4. Verify all tests compile but fail (5 min)
5. Commit: "test: Sprint 27c RED phase - 9 tests written"

### GREEN Phase (30-45 minutes)

**Simpler than 27a/27b**: No argument parsing, no validation

1. Add `ShellValue::ExitCode` variant (5 min)
2. Register stdlib function (5 min)
3. Implement converter logic (5 min)
4. Implement emitter logic (10 min)
5. Run tests, fix any issues (10 min)
6. Verify 846+ tests pass (838 + 8 new)
7. Run clippy, cargo fmt (5 min)
8. Commit: "feat: Sprint 27c - Exit code handling (GREEN phase)"

### REFACTOR Phase (Optional, 10-15 minutes)

1. Add documentation comments if needed
2. Check for any optimization opportunities
3. Commit: "refactor: Sprint 27c code cleanup"

### Total Estimated: 1-1.5 hours

(vs 2-3 hours for 27a/27b)

## Quality Gates

Must pass before completion:

- [ ] All tests pass (846+/846+)
- [ ] Zero compilation errors
- [ ] Zero new clippy warnings
- [ ] Code formatted with cargo fmt
- [ ] Proper quoting in all cases
- [ ] ROADMAP updated
- [ ] Completion report written

## Comparison with Previous Sprints

| Metric | Sprint 27a | Sprint 27b | Sprint 27c |
|--------|------------|------------|------------|
| Functions Added | 2 | 3 | 1 |
| IR Variants | 1 (EnvVar) | 2 (Arg, ArgCount) | 1 (ExitCode) |
| Tests | 10 | 12 | 9 |
| Validation Logic | Yes (var name) | Yes (position >= 1) | No |
| Complexity | Medium | Medium | Low |
| Duration | 3 hours | 2.5 hours | 1-2 hours |

**Key Simplifications**:
- No function parameters to extract/validate
- No security validation needed
- Fewer edge cases
- Simpler test assertions

## Toyota Way Principles

### è‡ªåƒåŒ– (Jidoka) - Build Quality In
- Write tests BEFORE implementation (EXTREME TDD)
- Zero defects policy (100% test pass rate)
- Quality gates enforced

### ç¾åœ°ç¾ç‰© (Genchi Genbutsu) - Direct Observation
- Test against POSIX shell requirements
- Verify quoting with real shells
- Understand $? timing semantics

### æ”¹å–„ (Kaizen) - Continuous Improvement
- Apply learnings from Sprints 27a and 27b
- Faster execution (1-2 hours vs 2-3 hours)
- Maintain quality while improving speed

### åçœ (Hansei) - Reflection
- Document test bugs if found
- Root cause analysis for failures
- Capture learnings

## References

- Sprint 27a: Environment Variables (10 tests, 3 hours)
- Sprint 27b: Command-Line Arguments (12 tests, 2.5 hours, 0 errors)
- POSIX Shell Command Language: Special Parameters
- Bash Reference Manual: Special Parameters ($?)

## Notes

- Simplest sprint in the 27 series
- Follow Sprint 27b pattern (cleanest execution)
- Trust the TDD process - it's proven effective
- Should be faster than 27a/27b due to simplicity

---

**Status**: ğŸŸ¡ **IN PROGRESS** (Specification complete, ready for RED phase)
**Next**: Write 9 RED tests
**Pattern**: EXTREME TDD (RED-GREEN-REFACTOR)
**Expected Duration**: 1-2 hours
