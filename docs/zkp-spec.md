# Specification: Formally Verified Emitter for Tiny Bootstrap Scripts (rash)

**Document Version:** 1.1
**Date:** 2025-06-05
**Authors:** PMAT
**Status:** Draft

## 1. Introduction

This document specifies the requirements for a "Formally Verified Emitter" component within the `rash` project. The primary goal is to achieve mathematical proof of correctness for the translation of a highly restricted subset of `rash` Abstract Syntax Tree (AST) nodes into semantically equivalent POSIX shell commands. This is specifically targeted at generating **tiny bootstrap/installation scripts** where the POSIX shell is the only assumed available interpreter on a target system.

The formal verification aims to provide the highest possible assurance that the generated bootstrap scripts will behave exactly as intended according to the `rash` source.

## 2. Goals

*   **Formal Correctness:** Mathematically prove that the emitted POSIX shell commands are semantically equivalent to the input `rash` AST (for the defined tiny subset).
*   **Trustworthiness:** Provide a strong foundation of trust for critical bootstrap scripts generated by `rash`.
*   **Clarity:** The formalization should clearly define the semantics of the involved `rash` and POSIX constructs.
*   **Maintainability:** The formal proofs and specifications should be structured for clarity and potential future (minor) extensions.

## 3. Scope

### 3.1. In Scope

*   **Tiny Restricted AST Subset:** Focus exclusively on a minimal set of `rash` AST nodes essential for basic bootstrap tasks. This subset will be explicitly defined and kept extremely small. Examples:
    *   Executing a simple command with fixed arguments (e.g., `mkdir -p /path/to/dir`, `echo "message"`).
    *   Simple variable assignment (e.g., `VAR="value"`).
    *   Sequential execution of commands.
    *   Possibly `cd` to a fixed path.
*   **Emitter Module Subset:** The logic within `rash/src/emitter/posix.rs` that handles this tiny AST subset.
*   **Formal Semantics Definition:**
    *   Formalizing the operational semantics of the tiny `rash` AST subset.
    *   Formalizing the operational semantics of the corresponding tiny subset of POSIX shell command constructs.
    *   This will likely involve defining an abstract machine state (e.g., environment variables, current directory, output buffer).
*   **Formal Proof of Emitter Correctness:**
    *   Using a proof assistant (e.g., Coq, Isabelle/HOL, Lean).
    *   Formally specifying the emitter function that maps the tiny `rash` AST subset to POSIX command strings.
    *   Proving a theorem stating that for any AST in the tiny subset, the emitter function produces a POSIX string that is semantically equivalent to the input AST, according to the defined formal semantics.
*   **Verification Artifact:** The collection of formal proof scripts and the statement of the proven theorem(s).
*   **Documentation:** Clear documentation of the formalization, the tiny AST subset, and the interpretation of the formal proof.

### 3.2. Out of Scope (for this specification)

*   **Full `rash` AST Verification:** Any `rash` AST constructs beyond the explicitly defined tiny subset.
*   **Complex POSIX Shell Features:** Loops, conditionals (beyond implicit sequence), functions, subshells, advanced redirection, globbing, command substitution, signal handling, etc.
*   **Verification of POSIX Shell Interpreter Itself:** We assume the target POSIX shell (e.g., `sh`, minimal `bash`) behaves according to the formalized subset of its specification.
*   **Performance of the Formalization/Proof Process:** Correctness and clarity are paramount.
*   **Runtime Verification:** This spec focuses on the *emitter's* compile-time correctness.
*   **Alternative Verification Methods (ZKPs, PBT):** While PBT is valuable for testing, this spec focuses on achieving formal proof.
*   **Directly Executing Formal Models:** The formal models are for proof, not necessarily direct execution (though some proof assistants allow extraction).

## 4. Definitions

*   **`rash` AST:** The Abstract Syntax Tree representation of `rash` code.
*   **Tiny `rash` AST Subset:** An explicitly defined, minimal subset of `rash` AST node types and configurations sufficient for basic bootstrap scripts.
*   **Tiny POSIX Shell Subset:** An explicitly defined, minimal subset of POSIX shell command constructs corresponding to the Tiny `rash` AST Subset.
*   **Formal Semantics:** A mathematically precise definition of the behavior of language constructs, typically as rules transforming an abstract machine state.
*   **Semantic Equivalence (Formal):** Two constructs (one `rash` AST, one POSIX) are semantically equivalent if their formal semantic interpretations yield equivalent transformations on any given initial abstract machine state.
*   **Emitter Function (Formal):** A function defined within the formal system that maps an AST from the Tiny `rash` AST Subset to a string representing POSIX commands.
*   **Proof Assistant:** A software tool used to develop and check formal proofs (e.g., Coq, Isabelle/HOL, Lean).
*   **Formal Proof:** A derivation of a theorem from axioms and inference rules within a formal system, checked by a proof assistant.
*   **Verification Artifact (Formal):** The set of formal definitions (AST, POSIX, semantics, emitter) and the proof scripts demonstrating the equivalence theorem.

## 5. Functional Requirements (for the Formal Verification Effort)

*   **FR1 (Tiny AST Subset Formalization):** The syntax and operational semantics of the Tiny `rash` AST Subset shall be formally defined in the chosen proof assistant.
*   **FR2 (Tiny POSIX Subset Formalization):** The syntax and operational semantics of the corresponding Tiny POSIX Shell Subset shall be formally defined in the chosen proof assistant.
*   **FR3 (Emitter Formalization):** The `rash` AST-to-POSIX string emitter logic (for the tiny subset) shall be formalized as a function within the proof assistant.
*   **FR4 (Equivalence Theorem):** A theorem shall be stated and formally proven within the proof assistant, asserting that for any AST `A` in the Tiny `rash` AST Subset, `FormalSemantics_rash(A)` is equivalent to `FormalSemantics_POSIX(FormalEmitter(A))`.
*   **FR5 (Proof Completeness):** The formal proof shall be complete and checkable by the chosen proof assistant.

## 6. Non-Functional Requirements

*   **NFR1 (Soundness):** The chosen proof assistant and its underlying logic must be sound. The formalization itself must accurately reflect the intended semantics of `rash` and POSIX (for the subset).
*   **NFR2 (Clarity and Readability):** Formal definitions and proofs should be structured and commented to be as understandable as possible by someone familiar with formal methods and the `rash` project.
*   **NFR3 (Maintainability):** The formalization should be organized to facilitate minor updates or corrections if the tiny subset evolves slightly or errors are found.
*   **NFR4 (Documentation):** The formalization effort, including the definition of the tiny subset, the chosen formal system, and how to interpret the main theorems, must be documented.

## 7. Design and Implementation Considerations (Formal Methods Approach)

### 7.1. Choice of Proof Assistant
*   Factors: Community support, existing libraries (e.g., for string manipulation, basic OS primitives), learning curve, suitability for operational semantics.
*   Candidates: Coq, Isabelle/HOL, Lean.

### 7.2. Tiny `rash` AST Subset Definition (Example - to be finalized)
This subset must be *minimal*.
*   **`ExecuteCommand`**:
    *   `command_name`: A literal string (from a very restricted allow-list, e.g., "mkdir", "echo", "rm", "cp", "mv", "chmod", "chown", "id", "test").
    *   `args`: A list of literal strings. No variables, no substitutions.
*   **`SetEnvironmentVariable`**:
    *   `name`: A literal string (valid POSIX variable name).
    *   `value`: A literal string.
*   **`Sequence`**:
    *   `commands`: A list of other commands from this tiny subset.
*   **`ChangeDirectory`**:
    *   `path`: A literal string (absolute or very simple relative).

*Forbidden in this tiny subset:* Loops, conditionals, user-defined functions, complex variable expansion, command substitution, pipes, redirection (beyond simple STDOUT for `echo`), globbing, arithmetic, subshells, etc.

### 7.3. Formalizing Semantics
*   **Abstract State:** Define a record/tuple representing the system state:
    *   Environment variables (map from string to string).
    *   Current working directory (string).
    *   Output buffer (list of strings for STDOUT).
    *   Error buffer (list of strings for STDERR).
    *   File system (highly abstract, e.g., a map from paths to content/type, only if commands like `mkdir` are included).
    *   Exit code (integer).
*   **Operational Semantics:** Define relations or functions for each AST/POSIX construct showing how it transforms an input state to an output state.
    *   Example for `SetEnvironmentVariable(name, value)`:
        `State_in -> State_out` where `State_out.env = State_in.env` updated with `name=value`.

### 7.4. Formalizing the Emitter
*   Define a function in the proof assistant that takes a `rash` AST node (from the tiny subset) and returns a string.
    *   Example: `emit(ExecuteCommand("echo", ["hello"]))` returns the string `"echo \"hello\""`.
    *   String manipulation (concatenation, quoting) will need to be handled using the proof assistant's string library or defined carefully.

### 7.5. Stating and Proving the Main Theorem
*   The theorem will be of the form:
    `forall (ast_node : TinyRashAST) (initial_state : AbstractState),`
    `  eval_rash(ast_node, initial_state) = eval_posix(emit(ast_node), initial_state)`
    (Where `eval_rash` and `eval_posix` are the semantic functions, and `=` denotes equivalence of the resulting `AbstractState`s).
*   Proof will likely proceed by induction on the structure of `ast_node`.

## 8. Testing and Validation (of the Formalization)

While the goal is formal proof, the formalization itself needs validation:
*   **Manual Review:** Thorough review of the formal definitions of semantics and the emitter by developers and potentially external experts in formal methods.
*   **Testing via Extraction (if supported):** Some proof assistants allow extracting executable code (e.g., to Haskell, OCaml) from formal definitions. This extracted code (for the emitter and semantic interpreters) can be tested against hand-crafted examples to sanity-check the formalization.
*   **Consistency Checks:** The proof assistant itself checks for logical consistency.
*   **Small Examples:** Manually trace the formal semantics for small AST examples and their emitted POSIX code to ensure they align with intuition.

## 9. Verification Artifact

*   The complete set of source files for the chosen proof assistant containing:
    *   Formal definitions of the Tiny `rash` AST Subset.
    *   Formal definitions of the Tiny POSIX Shell Subset.
    *   Formal definitions of the abstract machine state and operational semantics.
    *   Formal definition of the Emitter function.
    *   The statement and complete, checked proof of the main equivalence theorem(s).
*   Documentation explaining how to check the proofs using the proof assistant.

## 10. Acceptance Criteria

*   A specific Tiny `rash` AST Subset suitable for minimal bootstrap scripts is defined and agreed upon.
*   The formalization (semantics of `rash` subset, POSIX subset, emitter) is completed in a chosen proof assistant.
*   The main semantic equivalence theorem is successfully proven and checked by the proof assistant.
*   The formalization and proofs are documented and reviewed.
*   The verification artifact (proof scripts) is available in the `rash` repository.

## 11. Future Considerations

*   Careful, incremental extension of the Tiny AST Subset if absolutely necessary, with corresponding updates to the formal proofs.
*   Investigating formal verification of the `rash` parser for this tiny subset (i.e., proving that `parse(string_to_rash) = ast_node`).
*   Using the verified emitter as a trusted component in a larger system.


