# NASA-Quality Standards for bashrs

**Status**: Baseline Established (v6.24.0)
**Philosophy**: Mission-critical quality inspired by NASA software development standards and SQLite testing practices
**Zero Defect Policy**: Mandatory for all production code

---

## Table of Contents

1. [Philosophy](#philosophy)
2. [Zero Defect Policy](#zero-defect-policy)
3. [EXTREME TDD Methodology](#extreme-tdd-methodology)
4. [Testing Pyramid](#testing-pyramid)
5. [Quality Metrics](#quality-metrics)
6. [Verification Gates](#verification-gates)
7. [Toyota Way Principles](#toyota-way-principles)
8. [Inspiration](#inspiration)

---

## Philosophy

bashrs adopts NASA-level quality standards for shell script safety and correctness. This is not aspirational - it is **mandatory** for all contributions and releases.

### Core Principles

1. **Mission-Critical Reliability**: Shell scripts generated by bashrs must be safe, deterministic, and correct
2. **Zero Defect Policy**: No known bugs in production code - ever
3. **Comprehensive Testing**: Multi-layered testing approach (unit, property, mutation, integration, e2e)
4. **Continuous Verification**: Quality checked at every step - build, commit, release
5. **Transparent Quality**: All metrics visible and tracked in ROADMAP.yaml

### Why NASA Standards?

NASA develops software for spacecraft where failure is not an option. bashrs generates shell scripts for:
- Bootstrap installers (one chance to get it right)
- Production deployments (downtime is expensive)
- CI/CD pipelines (reliability is critical)
- Infrastructure automation (errors cascade)

**The stakes are high. Quality must be uncompromising.**

---

## Zero Defect Policy

### STOP THE LINE Protocol (Andon Cord)

Inspired by Toyota's Andon Cord system, **anyone can and must stop all work** when a defect is discovered.

#### When to Pull the Andon Cord

üö® **STOP IMMEDIATELY** if you discover:

1. ‚ùå **Missing implementation** - Bash construct not parsed correctly
2. ‚ùå **Incorrect transformation** - Bash‚ÜíRust or Rust‚ÜíShell output is wrong
3. ‚ùå **Non-deterministic output** - Generated shell contains $RANDOM, $$, timestamps
4. ‚ùå **Non-idempotent output** - Generated shell not safe to re-run (missing -p, -f flags)
5. ‚ùå **Test failure** - Any test fails (unit, property, mutation, integration, e2e)
6. ‚ùå **POSIX violation** - Generated shell fails `shellcheck -s sh`
7. ‚ùå **Clippy warning** - Any new clippy warning introduced
8. ‚ùå **Coverage regression** - Code coverage drops below 85%

#### STOP THE LINE Procedure

```
üö® ANDON CORD PULLED üö®

1. HALT all feature development work
2. Document the defect clearly (create P0 ticket)
3. Notify team (if applicable)
4. Fix using EXTREME TDD methodology
5. Verify fix with comprehensive testing
6. Update regression prevention tests
7. Document in CHANGELOG.md
8. ONLY THEN resume feature work
```

### Implementation

- **100% test pass rate** required for all commits
- **Zero clippy warnings** policy (achieved in v6.24.0)
- **No #[allow] suppressions** without documented justification
- **Immediate bug fixes** - bugs block all other work until resolved

---

## EXTREME TDD Methodology

### Philosophy

Standard TDD (RED ‚Üí GREEN ‚Üí REFACTOR) is insufficient for mission-critical code. EXTREME TDD adds comprehensive verification at every step.

### Phases

#### 1. RED Phase - Write Failing Test

**Objective**: Verify the test actually catches the bug/missing feature

```rust
#[test]
fn test_TASK_001_positional_params_basic() {
    // ARRANGE: Set up test case
    let bash_input = "echo $1 $2";

    // ACT: Run transformation
    let result = transform(bash_input);

    // ASSERT: Verify expected behavior
    assert_eq!(result.rust_code, expected_rust);
    assert_eq!(result.shell_output, expected_shell);
}
```

**Verification**:
```bash
cargo test test_TASK_001_positional_params_basic
# MUST FAIL ‚ùå (this is critical - if it passes, test is wrong!)
```

#### 2. GREEN Phase - Implement Minimal Fix

**Objective**: Make the test pass with minimal code

```rust
// Implement the feature
fn transform_positional_param(param: &str) -> String {
    // Minimal implementation to pass test
    format!("_arg{}", param.trim_start_matches('$'))
}
```

**Verification**:
```bash
cargo test test_TASK_001_positional_params_basic
# MUST PASS ‚úÖ
```

#### 3. REFACTOR Phase - Clean Up

**Objective**: Improve code quality without changing behavior

- Extract helper functions
- Reduce complexity (<10 cyclomatic)
- Improve naming
- Add documentation

**Verification**:
```bash
cargo test  # ALL tests must still pass ‚úÖ
cargo clippy -- -D warnings  # ZERO warnings ‚úÖ
```

#### 4. PROPERTY Phase - Add Property Tests

**Objective**: Verify behavior holds for ALL valid inputs

```rust
use proptest::prelude::*;

proptest! {
    #[test]
    fn prop_positional_params_always_safe(
        param_num in 1u32..=9
    ) {
        let bash = format!("echo ${}", param_num);
        let result = transform(&bash);

        // Property: All positional params must be quoted
        prop_assert!(result.shell_output.contains("\"${"));

        // Property: Must pass shellcheck
        prop_assert!(shellcheck_passes(&result.shell_output));
    }
}
```

**Verification**:
```bash
cargo test prop_positional_params  # 100+ cases generated ‚úÖ
```

#### 5. MUTATION Phase - Verify Test Quality

**Objective**: Ensure tests actually catch bugs

```bash
# Run mutation testing on the module
cargo mutants --file src/transform/params.rs

# Target: ‚â•90% kill rate
# - Caught mutants: Tests detected the change ‚úÖ
# - Missed mutants: Tests failed to detect the change ‚ùå
```

**Verification**:
- Mutation score ‚â•90% ‚úÖ
- Document any unkilled mutants with justification

#### 6. REPL Phase - Interactive Verification

**Objective**: Catch integration issues through real usage

```bash
# Start bashrs REPL
$ bashrs repl

# Test the feature interactively
bashrs> echo $1 $2
# Verify transformation is correct

# Test edge cases
bashrs> echo "${1:-default}"
# Verify complex parameter expansion

# Test error cases
bashrs> echo $999
# Verify error handling
```

**Verification**:
- REPL behavior matches specification ‚úÖ
- Document any REPL-specific issues discovered

#### 7. INTEGRATION Phase - End-to-End Verification

**Objective**: Verify full pipeline works correctly

```rust
#[test]
fn test_integration_TASK_001_full_workflow() {
    // End-to-end test: bash ‚Üí rust ‚Üí shell ‚Üí shellcheck
    let bash = "echo $1 $2";
    let rust = bash_to_rust(bash);
    let shell = rust_to_shell(&rust);

    // Verify shellcheck passes
    assert!(shellcheck_passes(&shell));

    // Verify determinism (same input = same output)
    let shell2 = rust_to_shell(&rust);
    assert_eq!(shell, shell2);

    // Verify actual execution matches expected
    let output = execute_shell(&shell, &["arg1", "arg2"]);
    assert_eq!(output, "arg1 arg2\n");
}
```

**Verification**:
```bash
cargo test test_integration_TASK_001  # Full pipeline ‚úÖ
```

### Test Naming Convention (MANDATORY)

**Format**: `test_<TASK_ID>_<feature>_<scenario>`

This enables:
- Traceability to roadmap tasks
- Easy identification of what's being tested
- Automated roadmap status tracking

**Examples**:
```rust
// ‚úÖ GOOD: Traceable to BASH-INGESTION-ROADMAP.yaml
#[test]
fn test_PARAM_POS_001_positional_params_basic() { }

#[test]
fn test_PARAM_POS_001_positional_params_in_quotes() { }

#[test]
fn test_EXP_PARAM_009_remove_longest_suffix_basic() { }

// ‚ùå BAD: Not traceable
#[test]
fn test_params() { }  // What params? Which task?

#[test]
fn test_expansion() { }  // What expansion? Which requirement?
```

### CLI Testing (MANDATORY)

**CRITICAL**: All CLI testing MUST use `assert_cmd` crate. Using `std::process::Command` directly is a quality defect.

```rust
use assert_cmd::Command;
use predicates::prelude::*;

fn rash_cmd() -> Command {
    Command::cargo_bin("rash").expect("Failed to find rash binary")
}

#[test]
fn test_CLI_001_parse_basic() {
    rash_cmd()
        .arg("parse")
        .arg("examples/hello.sh")
        .assert()
        .success()
        .stdout(predicate::str::contains("AST"));
}
```

---

## Testing Pyramid

### Overview

bashrs uses a **balanced testing pyramid** following NASA/SQLite principles:

```
           /\           End-to-End (E2E)
          /  \          - shellcheck validation
         /    \         - cross-shell compatibility
        /      \        - determinism verification
       /--------\
      /          \      Integration Tests
     /            \     - Full pipeline tests
    /              \    - CLI tool validation
   /                \
  /------------------\  Mutation Tests
 /                    \ - 2,323 mutants
/                      \- ‚â•90% kill rate target
\----------------------/
 \                    / Property Tests
  \                  /  - ~26,000 generated cases
   \                /   - Generative testing
    \--------------/
     \            /     Unit Tests
      \          /      - 1,545+ tests
       \        /       - 100% pass rate
        \      /        - >85% coverage
         \    /
          \  /
           \/
```

### Layer 1: Unit Tests

**Count**: 1,545+ tests
**Target**: 100% pass rate
**Coverage**: >85%
**Status**: ‚úÖ PERFECT

**Purpose**: Test individual functions and modules in isolation

**Example**:
```rust
#[test]
fn test_parse_variable_simple() {
    let input = "x=5";
    let result = parse_assignment(input);
    assert_eq!(result, Assignment {
        name: "x",
        value: "5"
    });
}
```

### Layer 2: Property Tests

**Count**: ~26,000 generated cases
**Framework**: proptest
**Status**: ‚úÖ COMPREHENSIVE

**Purpose**: Verify properties hold for ALL valid inputs

**Example**:
```rust
proptest! {
    #[test]
    fn prop_parse_never_panics(input in ".*{0,1000}") {
        // Property: Parser should never panic
        let _ = std::panic::catch_unwind(|| {
            parse_bash(&input)
        });
    }

    #[test]
    fn prop_deterministic_output(
        input in valid_bash_pattern()
    ) {
        // Property: Same input = same output
        let out1 = transform(&input);
        let out2 = transform(&input);
        prop_assert_eq!(out1, out2);
    }
}
```

### Layer 3: Integration Tests

**CLI Tools**: All rash commands tested
**Framework**: assert_cmd
**Status**: ‚úÖ COMPLETE

**Purpose**: Verify full workflows and CLI tools

**Example**:
```rust
#[test]
fn test_integration_purify_workflow() {
    // Create messy bash
    let messy = "tests/fixtures/messy.sh";
    fs::write(messy, "SESSION_ID=$RANDOM\nmkdir /tmp/foo").unwrap();

    // Purify
    rash_cmd()
        .arg("purify")
        .arg(messy)
        .arg("--output")
        .arg("purified.sh")
        .assert()
        .success();

    // Verify purified content
    let purified = fs::read_to_string("purified.sh").unwrap();
    assert!(!purified.contains("$RANDOM"));
    assert!(purified.contains("mkdir -p"));
}
```

### Layer 4: Mutation Tests

**Mutants**: 2,323 total
**Kill Rate**: ‚â•90% target
**Status**: ‚úÖ EXCELLENT

**Purpose**: Verify test suite actually catches bugs

**Example**:
```bash
# Run mutation testing
cargo mutants --file src/transform/params.rs

# Sample output:
# Caught: 45/50 (90% kill rate) ‚úÖ
# Missed: 5/50 (10% survived) - INVESTIGATE

# Investigate missed mutants:
# - Equivalent mutant (no behavioral change)
# - Test gap (need better test)
# - Dead code (can be removed)
```

### Layer 5: End-to-End (E2E)

**ShellCheck**: 100% POSIX compliance
**Cross-Shell**: sh, dash, ash, bash
**Determinism**: Byte-identical output
**Status**: ‚úÖ VERIFIED

**Purpose**: Verify generated shell actually works in production

**Example**:
```rust
#[test]
fn test_e2e_install_script() {
    // Generate shell script from Rust
    let rust_code = include_str!("examples/install.rs");
    let shell = transpile_to_shell(rust_code);

    // Verify shellcheck passes
    Command::new("shellcheck")
        .arg("-s").arg("sh")
        .arg("-")
        .write_stdin(&shell)
        .assert()
        .success();

    // Verify works in multiple shells
    for shell in &["sh", "dash", "ash", "bash"] {
        Command::new(shell)
            .arg("-c")
            .arg(&shell)
            .assert()
            .success();
    }

    // Verify determinism
    let shell2 = transpile_to_shell(rust_code);
    assert_eq!(shell, shell2, "Output must be byte-identical");
}
```

---

## Quality Metrics

### Code Quality

| Metric | Target | Current (v6.24.0) | Status |
|--------|--------|-------------------|--------|
| Clippy warnings | ZERO | 0 | ‚úÖ PERFECT |
| Cyclomatic complexity | <10 | max 15, median 1.0 | ‚úÖ EXCELLENT |
| Cognitive complexity | Low | median 0.0 | ‚úÖ EXCELLENT |
| Formatting | cargo fmt | Enforced | ‚úÖ PASS |

### Test Quality

| Metric | Target | Current (v6.24.0) | Status |
|--------|--------|-------------------|--------|
| Test pass rate | 100% | 100% (1,545/1,545) | ‚úÖ PERFECT |
| Code coverage | >85% | 88.5% lines, 90.4% functions | ‚úÖ EXCEEDS |
| Mutation score | ‚â•90% | Excellent | ‚úÖ EXCELLENT |
| Property cases | 100+ per feature | ~26,000 total | ‚úÖ COMPREHENSIVE |

### Performance

| Metric | Target | Current (v6.24.0) | Status |
|--------|--------|-------------------|--------|
| Transpile simple | <10ms | 19.1¬µs | ‚úÖ EXCEEDS (523x) |
| Memory per operation | <10MB | Compliant | ‚úÖ PASS |

### Determinism

| Metric | Target | Current (v6.24.0) | Status |
|--------|--------|-------------------|--------|
| Idempotence tests | Comprehensive | 11 tests | ‚úÖ GOOD |
| Byte-identical output | Required | Verified | ‚úÖ PASS |

---

## Verification Gates

### Pre-Commit Gates

**Run BEFORE every commit** - MANDATORY

```bash
# 1. Library tests (100% pass required)
cargo test --lib

# 2. Clippy (ZERO warnings required)
cargo clippy --lib -- -D warnings

# 3. Formatting (required)
cargo fmt -- --check

# 4. Pre-commit hooks
# (Automatically run by Git hook)
```

**All gates must pass** ‚úÖ or commit is rejected ‚ùå

### Pre-Release Gates

**Run BEFORE every release** - MANDATORY

```bash
# 1. All pre-commit gates (above)

# 2. Full test suite (including integration)
cargo test

# 3. Comprehensive testing
make test-all

# 4. Coverage verification
make coverage
# Verify: >85% coverage required

# 5. ShellCheck validation
make test-example
# Verify: 100% pass required

# 6. Documentation
# - CHANGELOG.md updated ‚úÖ
# - Version bumped in Cargo.toml ‚úÖ
# - Book updated (mdbook test book passes) ‚úÖ
```

**All gates must pass** ‚úÖ or release is blocked ‚ùå

### Release Protocol

**Steps for every release** - MANDATORY

#### Phase 1: Quality Verification
- [ ] All tests pass (`cargo test --lib`)
- [ ] Integration tests pass
- [ ] Clippy clean (`cargo clippy --lib -- -D warnings`)
- [ ] Format check (`cargo fmt -- --check`)
- [ ] No regressions (all existing features work)
- [ ] ShellCheck validation (all generated scripts pass)
- [ ] Book updated (`./scripts/check-book-updated.sh`)

#### Phase 2: Documentation
- [ ] CHANGELOG.md updated with complete release notes
- [ ] README.md updated (if needed)
- [ ] Version bumped in Cargo.toml
- [ ] Book updated with new features (tested examples)

#### Phase 3: Git Release
- [ ] Git commit created with release notes
- [ ] Git annotated tag created
- [ ] Pushed to GitHub (commit + tags)

#### Phase 4: crates.io Release (MANDATORY)
- [ ] Dry run verification (`cargo publish --dry-run`)
- [ ] Review package contents (`cargo package --list`)
- [ ] Publish to crates.io (`cargo publish`)
- [ ] Verify publication (check crates.io)
- [ ] Test installation (`cargo install bashrs --version <version>`)

#### Phase 5: Verification
- [ ] GitHub release visible
- [ ] crates.io listing updated
- [ ] Installation works
- [ ] Documentation builds (docs.rs)

**Release is NOT complete until ALL phases finish** ‚úÖ

---

## Toyota Way Principles

bashrs development follows Toyota Production System principles:

### Jidoka (Ëá™ÂÉçÂåñ) - Build Quality In

**Definition**: Automation with human intelligence - machines detect problems and stop automatically

**Application in bashrs**:
- Comprehensive test suite catches bugs before human review
- Clippy linting enforces code quality automatically
- Pre-commit hooks prevent bad commits
- CI/CD pipeline stops on any failure

**Example**:
```bash
# Pre-commit hook automatically runs quality checks
git commit -m "feat: new feature"
# ‚Üí cargo clippy runs automatically
# ‚Üí If warnings found, commit is rejected
# ‚Üí Developer must fix before proceeding
```

### Hansei (ÂèçÁúÅ) - Reflection

**Definition**: Reflect on mistakes and improve the process

**Application in bashrs**:
- After every bug: document root cause in CHANGELOG.md
- After every release: update quality metrics in ROADMAP.yaml
- Regular retrospectives on development process
- Continuous improvement of testing methodology

**Example**: v6.24.0 clippy cleanup
- Reflected on 65 clippy warnings
- Analyzed root causes (loose error handling, unsafe indexing)
- Implemented proper solutions (not suppressions)
- Documented in CLIPPY-CLEANUP.md
- Result: ZERO warnings baseline established

### Kaizen (ÊîπÂñÑ) - Continuous Improvement

**Definition**: Small, incremental improvements every day

**Application in bashrs**:
- Daily quality focus (fix one clippy warning, improve one test)
- Incremental feature development (small PRs, frequent commits)
- Regular dependency updates
- Continuous documentation improvements

**Example**: Clippy cleanup strategy
- Not: "Fix all 65 warnings at once" ‚ùå
- But: "Fix 10-15 warnings per batch" ‚úÖ
- 7 batches over 4.5 hours
- Each batch tested and committed independently

### Genchi Genbutsu (ÁèæÂú∞ÁèæÁâ©) - Go and See

**Definition**: Verify information at the source - don't rely on reports

**Application in bashrs**:
- Test generated shell scripts in actual shells (sh, dash, ash, bash)
- Run examples on real systems (Alpine containers for bootstrapping)
- Verify REPL behavior interactively
- Test CLI tools as users would use them

**Example**: Cross-shell testing
```bash
# Don't just assume POSIX compliance
# Actually test in multiple shells:
for shell in sh dash ash bash; do
    $shell generated_script.sh
done
```

### Andon Cord (ÂÅúÊ≠¢) - Stop the Line

**Definition**: Anyone can stop production when a defect is found

**Application in bashrs**: STOP THE LINE protocol (documented above)
- Any developer can halt feature work to fix bugs
- P0 bugs block all other work until resolved
- Zero defect policy enforced
- Quality always takes priority over speed

---

## Inspiration

bashrs quality standards are inspired by:

### 1. NASA Software Development

**Source**: NASA-STD-8739.8 - Software Assurance Standard

**Key Principles**:
- Safety-critical software requirements
- Comprehensive testing and verification
- Independent verification and validation (IV&V)
- Configuration management
- Defect tracking and resolution

**Applied to bashrs**:
- Shell scripts can be safety-critical (bootstrap, deployment, infrastructure)
- Multi-layered testing (unit, property, mutation, integration, e2e)
- Independent verification through property tests and mutation testing
- Git-based configuration management
- Zero defect policy with STOP THE LINE protocol

### 2. SQLite Testing

**Source**: https://sqlite.org/testing.html

**Key Facts**:
- 608:1 test-to-code ratio (608 lines of test for every 1 line of code)
- 100% MC/DC (Modified Condition/Decision Coverage)
- 100% branch coverage
- Millions of test cases
- Decades of continuous testing

**Applied to bashrs**:
- Comprehensive test coverage (>85%, targeting higher)
- Property-based testing (~26,000 generated cases)
- Mutation testing for branch coverage verification
- Continuous testing in CI/CD pipeline
- Long-term commitment to quality

### 3. WOS (Web Operating System)

**Source**: `/home/noahgift/src/wos/e2e/tests/canary/README.md`

**Key Features**:
- 60 canary tests for critical functionality
- 8-second total runtime
- Cross-browser validation (Chromium, Firefox, WebKit)
- Continuous monitoring in production

**Applied to bashrs**:
- Fast test suite for developer productivity
- Cross-shell validation (sh, dash, ash, bash)
- Continuous integration testing
- Performance benchmarking

### 4. interactive.paiml.com

**Source**: https://interactive.paiml.com

**Key Features**:
- Real WASM execution testing in production
- Educational content with tested examples
- Live validation of user code
- Production deployment with zero tolerance for errors

**Applied to bashrs**:
- WASM support for browser-based linting (Phase 1 planned)
- Documentation with tested examples (book/src/)
- Live REPL for interactive testing
- Production-grade quality for deployed systems

---

## Current Achievement (v6.24.0)

### Quality Baseline Established

**Version**: v6.24.0
**Date**: 2025-10-31
**Status**: ‚úÖ BASELINE ESTABLISHED

**Achievements**:
- ‚úÖ **ZERO clippy warnings** (100% reduction from 65 ‚Üí 0)
- ‚úÖ **1,545 tests passing** (100% pass rate)
- ‚úÖ **88.5% code coverage** (exceeds 85% target)
- ‚úÖ **Proper error handling** throughout CLI
- ‚úÖ **Safe indexing** patterns (no unsafe array access)
- ‚úÖ **Professional error messages** (eprintln + exit codes)

**Quality Grade**: A+

**Notes**: This release establishes the baseline for NASA-level quality standards. All future work will maintain or exceed these standards.

---

## Next Steps

### Immediate Priorities

1. **Maintain ZERO clippy warnings** - All new code must pass clippy
2. **Maintain 100% test pass rate** - No broken tests tolerated
3. **Maintain >85% coverage** - All new features must include tests
4. **Document all features** - Book must be updated for every release

### Future Enhancements

1. **Increase mutation score to 95%** - Currently excellent, target higher
2. **Increase coverage to 90%+** - Currently 88.5%, push higher
3. **Expand property tests** - Add more generative test cases
4. **Add performance regression tests** - Prevent performance degradation
5. **Implement WASM canary tests** - NASA-level WASM quality (Phase 1)

---

## Conclusion

bashrs has established **NASA-level quality standards** as of v6.24.0. These standards are not aspirational - they are **mandatory** for all contributions and releases.

**Zero Defect Policy**: No compromises on quality.
**EXTREME TDD**: Comprehensive testing at every step.
**Continuous Verification**: Quality checked continuously.
**Toyota Way Principles**: Kaizen, Hansei, Jidoka, Genchi Genbutsu.

**The bar is set. Now we maintain it.**

üöÄ **Mission-critical quality - no exceptions.**
