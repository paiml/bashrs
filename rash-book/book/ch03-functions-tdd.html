<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chapter 3: Functions and Parameters - The Rash Programming Language</title>


        <!-- Custom HTML head -->

        <meta name="description" content="The official book for Rash - Test-Driven Rust-to-Shell Transpilation">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "coal" : "rust";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rash Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/paiml/bashrs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/paiml/bashrs/edit/main/rash-book/src/ch03-functions-tdd.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-3-functions-and-parameters"><a class="header" href="#chapter-3-functions-and-parameters">Chapter 3: Functions and Parameters</a></h1>
<!-- DOC_STATUS_START -->
<p><strong>Chapter Status</strong>: ‚úÖ 100% Working (12/12 examples)</p>
<div class="table-wrapper"><table><thead><tr><th>Status</th><th>Count</th><th>Examples</th></tr></thead><tbody>
<tr><td>‚úÖ Working</td><td>12</td><td>Ready for production use</td></tr>
<tr><td>‚ö†Ô∏è Partial</td><td>0</td><td>Some edge cases not covered</td></tr>
<tr><td>‚ùå Broken</td><td>0</td><td>Known issues, needs fixing</td></tr>
<tr><td>üìã Planned</td><td>0</td><td>Future roadmap features</td></tr>
</tbody></table>
</div>
<p><em>Last updated: 2025-10-04</em>
<em>bashrs version: 0.9.3</em></p>
<!-- DOC_STATUS_END -->
<hr />
<h2 id="the-problem"><a class="header" href="#the-problem">The Problem</a></h2>
<p>Shell functions are powerful but brittle. Missing parameter checks, unsafe variable expansion, and unclear interfaces make maintenance difficult. bashrs brings Rust‚Äôs type-safe function signatures to shell scripting.</p>
<p>In this chapter, you‚Äôll learn how bashrs transpiles Rust functions into POSIX shell functions with verified parameter handling and type safety.</p>
<h2 id="test-driven-examples"><a class="header" href="#test-driven-examples">Test-Driven Examples</a></h2>
<h3 id="example-1-basic-function-no-parameters"><a class="header" href="#example-1-basic-function-no-parameters">Example 1: Basic Function (No Parameters)</a></h3>
<p>The simplest bashrs function - no parameters, just execution:</p>
<pre><code class="language-rust ignore">fn main() {
    greet();
}

fn greet() {
    println("Hello, Shell!");
}

fn println(msg: &amp;str) {}</code></pre>
<p><strong>Generated Shell Output:</strong></p>
<pre><code class="language-sh">#!/bin/sh
# Generated by bashrs

println() {
    printf '%s\n' "$1"
}

greet() {
    println "Hello, Shell!"
}

main() {
    greet
}

main "$@"
</code></pre>
<p><strong>Key Points:</strong></p>
<ul>
<li>Functions without parameters are called without arguments</li>
<li>Each Rust function becomes a shell function</li>
<li>Functions are defined before <code>main()</code></li>
<li>Call order: <code>main "$@"</code> ‚Üí <code>main()</code> ‚Üí <code>greet()</code></li>
</ul>
<h3 id="example-2-function-with-one-parameter"><a class="header" href="#example-2-function-with-one-parameter">Example 2: Function with One Parameter</a></h3>
<p>Single parameter functions demonstrate type-safe passing:</p>
<pre><code class="language-rust ignore">fn main() {
    let name = "Alice";
    greet(name);
}

fn greet(name: &amp;str) {
    println(name);
}

fn println(msg: &amp;str) {}</code></pre>
<p><strong>Generated Shell Output:</strong></p>
<pre><code class="language-sh">#!/bin/sh
# Generated by bashrs

println() {
    printf '%s\n' "$1"
}

greet() {
    name="$1"
    println "$name"
}

main() {
    name="Alice"
    greet "$name"
}

main "$@"
</code></pre>
<p><strong>Key Points:</strong></p>
<ul>
<li>Parameters are accessed as <code>$1</code>, <code>$2</code>, etc.</li>
<li>Parameters are assigned to named local variables</li>
<li>Automatic quoting: <code>greet "$name"</code></li>
<li>Type safety enforced at transpile-time</li>
</ul>
<h3 id="example-3-multiple-parameters-same-type"><a class="header" href="#example-3-multiple-parameters-same-type">Example 3: Multiple Parameters (Same Type)</a></h3>
<p>Functions can accept multiple parameters of the same type:</p>
<pre><code class="language-rust ignore">fn main() {
    show_info("myapp", "1.0.0", "/usr/local");
}

fn show_info(name: &amp;str, version: &amp;str, prefix: &amp;str) {
    println(name);
    println(version);
    println(prefix);
}

fn println(msg: &amp;str) {}</code></pre>
<p><strong>Generated Shell Output:</strong></p>
<pre><code class="language-sh">#!/bin/sh
# Generated by bashrs

println() {
    printf '%s\n' "$1"
}

show_info() {
    name="$1"
    version="$2"
    prefix="$3"
    println "$name"
    println "$version"
    println "$prefix"
}

main() {
    show_info "myapp" "1.0.0" "/usr/local"
}

main "$@"
</code></pre>
<p><strong>Key Points:</strong></p>
<ul>
<li>Parameters are positional: <code>$1</code>, <code>$2</code>, <code>$3</code></li>
<li>Order matters (Rust enforces this)</li>
<li>Each parameter gets a named variable</li>
<li>All literals are properly quoted</li>
</ul>
<h3 id="example-4-mixed-type-parameters"><a class="header" href="#example-4-mixed-type-parameters">Example 4: Mixed Type Parameters</a></h3>
<p>Combining strings, integers, and booleans:</p>
<pre><code class="language-rust ignore">fn main() {
    configure("myapp", 8080, true);
}

fn configure(name: &amp;str, port: i32, enabled: bool) {
    show_name(name);
    show_port(port);
    show_status(enabled);
}

fn show_name(n: &amp;str) {}
fn show_port(p: i32) {}
fn show_status(s: bool) {}</code></pre>
<p><strong>Generated Shell Output:</strong></p>
<pre><code class="language-sh">#!/bin/sh
# Generated by bashrs

show_name() {
    n="$1"
}

show_port() {
    p="$1"
}

show_status() {
    s="$1"
}

configure() {
    name="$1"
    port="$2"
    enabled="$3"
    show_name "$name"
    show_port "$port"
    show_status "$enabled"
}

main() {
    configure "myapp" 8080 true
}

main "$@"
</code></pre>
<p><strong>Key Points:</strong></p>
<ul>
<li>Type mixing works seamlessly</li>
<li>Integer <code>8080</code> passed without quotes (assignment)</li>
<li>Boolean <code>true</code> passed as literal</li>
<li>When used as arguments, all are quoted</li>
</ul>
<h3 id="example-5-function-calling-another-function"><a class="header" href="#example-5-function-calling-another-function">Example 5: Function Calling Another Function</a></h3>
<p>Function composition - the foundation of structured scripts:</p>
<pre><code class="language-rust ignore">fn main() {
    install_app("myapp", "1.0.0");
}

fn install_app(name: &amp;str, version: &amp;str) {
    download(name, version);
    extract(name);
    configure(name);
}

fn download(n: &amp;str, v: &amp;str) {}
fn extract(n: &amp;str) {}
fn configure(n: &amp;str) {}</code></pre>
<p><strong>Generated Shell Output:</strong></p>
<pre><code class="language-sh">#!/bin/sh
# Generated by bashrs

download() {
    n="$1"
    v="$2"
}

extract() {
    n="$1"
}

configure() {
    n="$1"
}

install_app() {
    name="$1"
    version="$2"
    download "$name" "$version"
    extract "$name"
    configure "$name"
}

main() {
    install_app "myapp" "1.0.0"
}

main "$@"
</code></pre>
<p><strong>Key Points:</strong></p>
<ul>
<li>Functions can call other functions</li>
<li>Parameters are forwarded with proper quoting</li>
<li>Execution order: top to bottom</li>
<li>Clean separation of concerns</li>
</ul>
<h3 id="example-6-multiple-helper-functions"><a class="header" href="#example-6-multiple-helper-functions">Example 6: Multiple Helper Functions</a></h3>
<p>Organizing code with helper functions:</p>
<pre><code class="language-rust ignore">fn main() {
    setup_environment();
    install_dependencies();
    configure_system();
    start_services();
}

fn setup_environment() {}
fn install_dependencies() {}
fn configure_system() {}
fn start_services() {}</code></pre>
<p><strong>Generated Shell Output:</strong></p>
<pre><code class="language-sh">#!/bin/sh
# Generated by bashrs

setup_environment() {
    :
}

install_dependencies() {
    :
}

configure_system() {
    :
}

start_services() {
    :
}

main() {
    setup_environment
    install_dependencies
    configure_system
    start_services
}

main "$@"
</code></pre>
<p><strong>Key Points:</strong></p>
<ul>
<li>Empty functions generate <code>:</code> (POSIX no-op)</li>
<li>Clear execution flow</li>
<li>Each function is a logical step</li>
<li>Easy to add implementation later</li>
</ul>
<h3 id="example-7-nested-function-calls"><a class="header" href="#example-7-nested-function-calls">Example 7: Nested Function Calls</a></h3>
<p>Deep function call chains for complex logic:</p>
<pre><code class="language-rust ignore">fn main() {
    deploy();
}

fn deploy() {
    prepare();
}

fn prepare() {
    validate();
}

fn validate() {
    check_requirements();
}

fn check_requirements() {}</code></pre>
<p><strong>Generated Shell Output:</strong></p>
<pre><code class="language-sh">#!/bin/sh
# Generated by bashrs

check_requirements() {
    :
}

validate() {
    check_requirements
}

prepare() {
    validate
}

deploy() {
    prepare
}

main() {
    deploy
}

main "$@"
</code></pre>
<p><strong>Key Points:</strong></p>
<ul>
<li>Arbitrary nesting depth supported</li>
<li>Call stack: main ‚Üí deploy ‚Üí prepare ‚Üí validate ‚Üí check_requirements</li>
<li>Functions defined in dependency order</li>
<li>Clean, readable shell output</li>
</ul>
<h3 id="example-8-bootstrap-installer-pattern"><a class="header" href="#example-8-bootstrap-installer-pattern">Example 8: Bootstrap Installer Pattern</a></h3>
<p>Real-world installer with multiple stages:</p>
<pre><code class="language-rust ignore">fn main() {
    let app = "myapp";
    let version = "1.0.0";
    let prefix = "/usr/local";

    check_prerequisites(app);
    download_binary(app, version);
    verify_checksum(app, version);
    install_binary(app, prefix);
    create_config(app, prefix);
    setup_service(app);
}

fn check_prerequisites(name: &amp;str) {}
fn download_binary(name: &amp;str, ver: &amp;str) {}
fn verify_checksum(name: &amp;str, ver: &amp;str) {}
fn install_binary(name: &amp;str, prefix: &amp;str) {}
fn create_config(name: &amp;str, prefix: &amp;str) {}
fn setup_service(name: &amp;str) {}</code></pre>
<p><strong>Generated Shell Output:</strong></p>
<pre><code class="language-sh">#!/bin/sh
# Generated by bashrs

check_prerequisites() {
    name="$1"
}

download_binary() {
    name="$1"
    ver="$2"
}

verify_checksum() {
    name="$1"
    ver="$2"
}

install_binary() {
    name="$1"
    prefix="$2"
}

create_config() {
    name="$1"
    prefix="$2"
}

setup_service() {
    name="$1"
}

main() {
    app="myapp"
    version="1.0.0"
    prefix="/usr/local"

    check_prerequisites "$app"
    download_binary "$app" "$version"
    verify_checksum "$app" "$version"
    install_binary "$app" "$prefix"
    create_config "$app" "$prefix"
    setup_service "$app"
}

main "$@"
</code></pre>
<p><strong>Key Points:</strong></p>
<ul>
<li>Variables passed to multiple functions</li>
<li>Each function has clear responsibility</li>
<li>Parameters reused across function calls</li>
<li>Installer pattern: check ‚Üí download ‚Üí verify ‚Üí install ‚Üí configure</li>
</ul>
<h3 id="example-9-many-parameters-complex-functions"><a class="header" href="#example-9-many-parameters-complex-functions">Example 9: Many Parameters (Complex Functions)</a></h3>
<p>Handling functions with many configuration parameters:</p>
<pre><code class="language-rust ignore">fn main() {
    deploy_service(
        "myapp",
        "1.0.0",
        "/usr/local",
        8080,
        443,
        true,
        false,
        "production"
    );
}

fn deploy_service(
    name: &amp;str,
    version: &amp;str,
    prefix: &amp;str,
    http_port: i32,
    https_port: i32,
    ssl_enabled: bool,
    debug: bool,
    env: &amp;str
) {}</code></pre>
<p><strong>Generated Shell Output:</strong></p>
<pre><code class="language-sh">#!/bin/sh
# Generated by bashrs

deploy_service() {
    name="$1"
    version="$2"
    prefix="$3"
    http_port="$4"
    https_port="$5"
    ssl_enabled="$6"
    debug="$7"
    env="$8"
}

main() {
    deploy_service "myapp" "1.0.0" "/usr/local" 8080 443 true false "production"
}

main "$@"
</code></pre>
<p><strong>Key Points:</strong></p>
<ul>
<li>Support for many parameters (8 shown, more possible)</li>
<li>Positional parameters: <code>$1</code> through <code>$8</code></li>
<li>Clear parameter assignment in function body</li>
<li>Types are enforced at transpile-time</li>
</ul>
<h3 id="example-10-parameter-naming-patterns"><a class="header" href="#example-10-parameter-naming-patterns">Example 10: Parameter Naming Patterns</a></h3>
<p>Clear, descriptive parameter names:</p>
<pre><code class="language-rust ignore">fn main() {
    create_database("mydb", "localhost", 5432, "admin", "secure_pass");
}

fn create_database(
    database_name: &amp;str,
    host: &amp;str,
    port: i32,
    admin_user: &amp;str,
    admin_password: &amp;str
) {
    connect(host, port);
    authenticate(admin_user, admin_password);
    initialize(database_name);
}

fn connect(h: &amp;str, p: i32) {}
fn authenticate(u: &amp;str, pwd: &amp;str) {}
fn initialize(db: &amp;str) {}</code></pre>
<p><strong>Generated Shell Output:</strong></p>
<pre><code class="language-sh">#!/bin/sh
# Generated by bashrs

connect() {
    h="$1"
    p="$2"
}

authenticate() {
    u="$1"
    pwd="$2"
}

initialize() {
    db="$1"
}

create_database() {
    database_name="$1"
    host="$2"
    port="$3"
    admin_user="$4"
    admin_password="$5"
    connect "$host" "$port"
    authenticate "$admin_user" "$admin_password"
    initialize "$database_name"
}

main() {
    create_database "mydb" "localhost" 5432 "admin" "secure_pass"
}

main "$@"
</code></pre>
<p><strong>Key Points:</strong></p>
<ul>
<li>Descriptive names improve readability</li>
<li>Short aliases in helper functions (h, p, u, pwd, db)</li>
<li>Parameters forwarded with full names</li>
<li>Self-documenting code</li>
</ul>
<h3 id="example-11-variadic-style-pattern-fixed-parameters"><a class="header" href="#example-11-variadic-style-pattern-fixed-parameters">Example 11: Variadic-Style Pattern (Fixed Parameters)</a></h3>
<p>Simulating variadic functions with fixed parameter count:</p>
<pre><code class="language-rust ignore">fn main() {
    install_packages("pkg1", "pkg2", "pkg3", "pkg4", "pkg5");
}

fn install_packages(p1: &amp;str, p2: &amp;str, p3: &amp;str, p4: &amp;str, p5: &amp;str) {
    install_one(p1);
    install_one(p2);
    install_one(p3);
    install_one(p4);
    install_one(p5);
}

fn install_one(pkg: &amp;str) {}</code></pre>
<p><strong>Generated Shell Output:</strong></p>
<pre><code class="language-sh">#!/bin/sh
# Generated by bashrs

install_one() {
    pkg="$1"
}

install_packages() {
    p1="$1"
    p2="$2"
    p3="$3"
    p4="$4"
    p5="$5"
    install_one "$p1"
    install_one "$p2"
    install_one "$p3"
    install_one "$p4"
    install_one "$p5"
}

main() {
    install_packages "pkg1" "pkg2" "pkg3" "pkg4" "pkg5"
}

main "$@"
</code></pre>
<p><strong>Key Points:</strong></p>
<ul>
<li>Fixed parameter count (no true varargs in v1.0)</li>
<li>Pattern: wrapper function ‚Üí multiple calls to worker</li>
<li>Type-safe: all parameters must be provided</li>
<li>Common pattern for batch operations</li>
</ul>
<h3 id="example-12-two-stage-deployment-pattern"><a class="header" href="#example-12-two-stage-deployment-pattern">Example 12: Two-Stage Deployment Pattern</a></h3>
<p>Common deployment workflow with separate prepare/execute stages:</p>
<pre><code class="language-rust ignore">fn main() {
    let app = "webapp";
    let env = "production";
    let version = "2.1.0";

    prepare_deployment(app, env, version);
    execute_deployment(app, env);
}

fn prepare_deployment(name: &amp;str, environment: &amp;str, ver: &amp;str) {
    fetch_artifacts(name, ver);
    validate_artifacts(name);
    backup_current(name, environment);
}

fn execute_deployment(name: &amp;str, environment: &amp;str) {
    stop_services(name, environment);
    deploy_artifacts(name);
    start_services(name, environment);
    verify_deployment(name);
}

fn fetch_artifacts(n: &amp;str, v: &amp;str) {}
fn validate_artifacts(n: &amp;str) {}
fn backup_current(n: &amp;str, e: &amp;str) {}
fn stop_services(n: &amp;str, e: &amp;str) {}
fn deploy_artifacts(n: &amp;str) {}
fn start_services(n: &amp;str, e: &amp;str) {}
fn verify_deployment(n: &amp;str) {}</code></pre>
<p><strong>Generated Shell Output:</strong></p>
<pre><code class="language-sh">#!/bin/sh
# Generated by bashrs

fetch_artifacts() {
    n="$1"
    v="$2"
}

validate_artifacts() {
    n="$1"
}

backup_current() {
    n="$1"
    e="$2"
}

stop_services() {
    n="$1"
    e="$2"
}

deploy_artifacts() {
    n="$1"
}

start_services() {
    n="$1"
    e="$2"
}

verify_deployment() {
    n="$1"
}

prepare_deployment() {
    name="$1"
    environment="$2"
    ver="$3"
    fetch_artifacts "$name" "$ver"
    validate_artifacts "$name"
    backup_current "$name" "$environment"
}

execute_deployment() {
    name="$1"
    environment="$2"
    stop_services "$name" "$environment"
    deploy_artifacts "$name"
    start_services "$name" "$environment"
    verify_deployment "$name"
}

main() {
    app="webapp"
    env="production"
    version="2.1.0"

    prepare_deployment "$app" "$env" "$version"
    execute_deployment "$app" "$env"
}

main "$@"
</code></pre>
<p><strong>Key Points:</strong></p>
<ul>
<li>Two-phase deployment (prepare, then execute)</li>
<li>Functions organized by responsibility</li>
<li>Parameters passed through call hierarchy</li>
<li>Easy to add rollback logic</li>
</ul>
<h2 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h2>
<h3 id="function-definitions"><a class="header" href="#function-definitions">Function Definitions</a></h3>
<p>In bashrs, all functions are defined with <code>fn</code>:</p>
<pre><code class="language-rust ignore">fn function_name(param1: Type1, param2: Type2) {
    // body
}</code></pre>
<p>Transpiles to:</p>
<pre><code class="language-sh">function_name() {
    param1="$1"
    param2="$2"
    # body
}
</code></pre>
<h3 id="parameter-types"><a class="header" href="#parameter-types">Parameter Types</a></h3>
<p>bashrs v1.0 supports these parameter types:</p>
<div class="table-wrapper"><table><thead><tr><th>Rust Type</th><th>Shell Access</th><th>Example</th></tr></thead><tbody>
<tr><td><code>&amp;str</code></td><td><code>$1</code>, <code>$2</code>, ‚Ä¶</td><td><code>name="$1"</code></td></tr>
<tr><td><code>i32</code></td><td><code>$1</code>, <code>$2</code>, ‚Ä¶</td><td><code>port="$1"</code></td></tr>
<tr><td><code>bool</code></td><td><code>$1</code>, <code>$2</code>, ‚Ä¶</td><td><code>enabled="$1"</code></td></tr>
</tbody></table>
</div>
<p><strong>Important</strong>: All parameters become strings in shell, but Rust type checking ensures correct usage at transpile-time.</p>
<h3 id="function-calls"><a class="header" href="#function-calls">Function Calls</a></h3>
<p>Function calls are transpiled with automatic quoting:</p>
<pre><code class="language-rust ignore">// Rust
greet(name);

// Shell
greet "$name"</code></pre>
<p>Arguments are always quoted for safety.</p>
<h3 id="parameter-limits"><a class="header" href="#parameter-limits">Parameter Limits</a></h3>
<p>POSIX shells support positional parameters <code>$1</code> through <code>$9</code>, with <code>${10}</code> onwards requiring braces. bashrs v1.0:</p>
<ul>
<li>‚úÖ Supports any number of parameters</li>
<li>‚úÖ Uses <code>$1</code>, <code>$2</code>, ‚Ä¶ <code>$9</code></li>
<li>‚úÖ Uses <code>${10}</code>, <code>${11}</code>, ‚Ä¶ for 10+</li>
<li>‚úÖ Automatic brace wrapping</li>
</ul>
<h3 id="empty-functions"><a class="header" href="#empty-functions">Empty Functions</a></h3>
<p>Functions with no body emit POSIX no-op:</p>
<pre><code class="language-rust ignore">fn placeholder() {}

// Generates:
placeholder() {
    :
}</code></pre>
<p>The <code>:</code> is a POSIX built-in that always succeeds.</p>
<h2 id="how-transpilation-works"><a class="header" href="#how-transpilation-works">How Transpilation Works</a></h2>
<pre><code class="language-text">Rust: fn greet(name: &amp;str) { println(name); }
      ‚Üì
AST: FnDef { name: "greet", params: [(name, &amp;str)], body: [Call(println, [name])] }
      ‚Üì
IR: FunctionDef { name: "greet", params: [(name, String)], body: [FuncCall(println, [Var(name)])] }
      ‚Üì
Shell:
greet() {
    name="$1"
    println "$name"
}
</code></pre>
<h3 id="safety-guarantees"><a class="header" href="#safety-guarantees">Safety Guarantees</a></h3>
<ol>
<li>
<p><strong>Type Checking</strong> (compile-time):</p>
<ul>
<li>Parameter count must match</li>
<li>Parameter types must match</li>
<li>No implicit conversions</li>
</ul>
</li>
<li>
<p><strong>Parameter Assignment</strong>:</p>
<ul>
<li>All parameters get local variables</li>
<li>Positional params: <code>$1</code>, <code>$2</code>, ‚Ä¶</li>
<li>Automatic quoting in assignments</li>
</ul>
</li>
<li>
<p><strong>Call Safety</strong>:</p>
<ul>
<li>All arguments quoted: <code>func "$arg1" "$arg2"</code></li>
<li>No word splitting</li>
<li>No glob expansion</li>
</ul>
</li>
</ol>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="installer-pipeline"><a class="header" href="#installer-pipeline">Installer Pipeline</a></h3>
<pre><code class="language-rust ignore">fn main() {
    let pkg = "myapp";
    check(pkg);
    download(pkg);
    install(pkg);
    configure(pkg);
}

fn check(p: &amp;str) {}
fn download(p: &amp;str) {}
fn install(p: &amp;str) {}
fn configure(p: &amp;str) {}</code></pre>
<h3 id="configuration-wrapper"><a class="header" href="#configuration-wrapper">Configuration Wrapper</a></h3>
<pre><code class="language-rust ignore">fn main() {
    setup_app("myapp", "/opt", 8080, true);
}

fn setup_app(name: &amp;str, prefix: &amp;str, port: i32, ssl: bool) {
    setup_directories(prefix);
    setup_network(port, ssl);
    setup_config(name, prefix);
}</code></pre>
<h3 id="error-handling-stages"><a class="header" href="#error-handling-stages">Error-Handling Stages</a></h3>
<pre><code class="language-rust ignore">fn main() {
    if !validate() {
        return;  // Chapter 4: Control Flow
    }
    execute();
}

fn validate() -&gt; bool { true }
fn execute() {}</code></pre>
<h2 id="edge-cases-and-limitations"><a class="header" href="#edge-cases-and-limitations">Edge Cases and Limitations</a></h2>
<h3 id="-supported"><a class="header" href="#-supported">‚úÖ Supported</a></h3>
<ul>
<li>Functions with 0-N parameters</li>
<li>Mixed parameter types (&amp;str, i32, bool)</li>
<li>Nested function calls (any depth)</li>
<li>Empty functions</li>
<li>Multiple functions calling same function</li>
</ul>
<h3 id="-partial-support"><a class="header" href="#-partial-support">‚ö†Ô∏è Partial Support</a></h3>
<ul>
<li><strong>Return values</strong>: Only via exit codes (v1.0), not direct values</li>
<li><strong>Recursion</strong>: Supported but no tail-call optimization</li>
<li><strong>Default parameters</strong>: Not supported</li>
</ul>
<h3 id="-not-supported-v10"><a class="header" href="#-not-supported-v10">‚ùå Not Supported (v1.0)</a></h3>
<ul>
<li>Varargs: <code>fn foo(items: &amp;[&amp;str])</code> - use fixed params</li>
<li>Generic functions: <code>fn foo&lt;T&gt;(x: T)</code> - not applicable</li>
<li>Return values: <code>fn add(a: i32, b: i32) -&gt; i32</code> - planned for v1.1</li>
<li>Closures/lambdas: <code>let f = |x| x + 1</code> - not in scope</li>
<li>Methods: <code>impl Foo { fn bar() {} }</code> - use standalone functions</li>
<li>Associated functions: <code>Foo::new()</code> - use regular functions</li>
</ul>
<h3 id="shell-compatibility"><a class="header" href="#shell-compatibility">Shell Compatibility</a></h3>
<p>All function features work on:</p>
<ul>
<li>‚úÖ POSIX sh</li>
<li>‚úÖ Dash (Debian/Ubuntu)</li>
<li>‚úÖ Bash (3.2+)</li>
<li>‚úÖ Ash (BusyBox)</li>
</ul>
<h2 id="testing-your-examples"><a class="header" href="#testing-your-examples">Testing Your Examples</a></h2>
<p>Create a test file with multiple functions:</p>
<pre><code class="language-rust ignore">// test_funcs.rs
fn main() {
    deploy("myapp", "1.0.0");
}

fn deploy(name: &amp;str, version: &amp;str) {
    check(name);
    install(name, version);
}

fn check(n: &amp;str) {}
fn install(n: &amp;str, v: &amp;str) {}</code></pre>
<p>Build and verify:</p>
<pre><code class="language-bash">$ bashrs build test_funcs.rs -o test_funcs.sh
‚úì Transpiled successfully

$ cat test_funcs.sh
#!/bin/sh
# Generated by bashrs

check() {
    n="$1"
}

install() {
    n="$1"
    v="$2"
}

deploy() {
    name="$1"
    version="$2"
    check "$name"
    install "$name" "$version"
}

main() {
    deploy "myapp" "1.0.0"
}

main "$@"

$ shellcheck -s sh test_funcs.sh
‚úì No issues detected
</code></pre>
<h2 id="verification-levels"><a class="header" href="#verification-levels">Verification Levels</a></h2>
<p>Function call safety varies by verification level:</p>
<pre><code class="language-bash"># Basic: Standard quoting
$ bashrs build funcs.rs --verify basic

# Strict: Paranoid quoting (default)
$ bashrs build funcs.rs --verify strict

# Paranoid: Rejects dynamic calls
$ bashrs build funcs.rs --verify paranoid
</code></pre>
<p>For production installers, use <code>--verify strict</code>.</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Now that you understand functions, let‚Äôs explore <a href="ch04-control-flow-tdd.html">Chapter 4: Control Flow</a> to learn about:</p>
<ul>
<li>If/else conditionals</li>
<li>Match expressions (limited)</li>
<li>Loops (for, while)</li>
<li>Early returns</li>
<li>Error handling</li>
</ul>
<h2 id="reference"><a class="header" href="#reference">Reference</a></h2>
<ul>
<li>Test files: <code>tests/ch03-functions/</code></li>
<li>Example files: <code>examples/ch03-*.rs</code></li>
<li>Generated output: <code>target/test-examples/ch03-*.sh</code></li>
<li>ShellCheck reports: <code>target/shellcheck-reports/ch03-*.txt</code></li>
<li>Related: <a href="ch02-variables-tdd.html">Chapter 2: Variables</a></li>
<li>Related: <a href="ch04-control-flow-tdd.html">Chapter 4: Control Flow</a></li>
<li>Related: <a href="ch18-limitations.html">Chapter 18: Limitations</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="ch02-variables-tdd.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="ch04-control-flow-tdd.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="ch02-variables-tdd.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="ch04-control-flow-tdd.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
