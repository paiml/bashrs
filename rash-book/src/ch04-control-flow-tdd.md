# Chapter 4: Control Flow

<!-- DOC_STATUS_START -->
**Chapter Status**: ‚úÖ 100% Working (15/15 examples)

| Status | Count | Examples |
|--------|-------|----------|
| ‚úÖ Working | 15 | Ready for production use |
| ‚ö†Ô∏è Partial | 0 | Some edge cases not covered |
| ‚ùå Broken | 0 | Known issues, needs fixing |
| üìã Planned | 0 | Future roadmap features |

*Last updated: 2025-10-04*
*bashrs version: 0.9.3*
<!-- DOC_STATUS_END -->

---

## The Problem

Shell scripts need conditional logic, but bash's `if [ ... ]` syntax is error-prone: missing spaces, wrong operators, unquoted variables. bashrs brings Rust's clean `if/else` syntax with compile-time validation.

In this chapter, you'll learn how bashrs transpiles Rust control flow into POSIX-compliant shell conditionals with verified safety.

## Test-Driven Examples

### Example 1: Basic If Statement

The simplest conditional - check and act:

```rust
fn main() {
    let x = 10;
    if x > 5 {
        println("x is greater than 5");
    }
}

fn println(msg: &str) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

println() {
    printf '%s\n' "$1"
}

main() {
    x=10
    if [ "$x" -gt 5 ]; then
        println "x is greater than 5"
    fi
}

main "$@"
```

**Key Points:**
- `if` becomes `if [ ... ]; then ... fi`
- `>` becomes `-gt` (integer greater-than)
- Variables are quoted: `"$x"`
- POSIX test syntax: `[ ... ]`

### Example 2: If-Else

Basic branching with two paths:

```rust
fn main() {
    let enabled = true;
    if enabled {
        println("Feature enabled");
    } else {
        println("Feature disabled");
    }
}

fn println(msg: &str) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

println() {
    printf '%s\n' "$1"
}

main() {
    enabled=true
    if [ "$enabled" = true ]; then
        println "Feature enabled"
    else
        println "Feature disabled"
    fi
}

main "$@"
```

**Key Points:**
- Boolean comparison: `[ "$enabled" = true ]`
- `else` block is optional
- Both branches are properly indented
- Clean shell structure

### Example 3: If-Else-If-Else Chain

Multiple conditions with fallback:

```rust
fn main() {
    let x = 42;
    if x < 0 {
        println("negative");
    } else if x == 0 {
        println("zero");
    } else if x < 100 {
        println("positive, less than 100");
    } else {
        println("100 or greater");
    }
}

fn println(msg: &str) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

println() {
    printf '%s\n' "$1"
}

main() {
    x=42
    if [ "$x" -lt 0 ]; then
        println "negative"
    elif [ "$x" -eq 0 ]; then
        println "zero"
    elif [ "$x" -lt 100 ]; then
        println "positive, less than 100"
    else
        println "100 or greater"
    fi
}

main "$@"
```

**Key Points:**
- `else if` becomes `elif`
- Chained conditions work correctly
- `-lt` (less than), `-eq` (equal) operators
- Final `else` is the default case

### Example 4: Integer Comparison Operators

All numeric comparison operators:

```rust
fn main() {
    let x = 10;
    let y = 20;

    if x == y {
        println("equal");
    }

    if x != y {
        println("not equal");
    }

    if x < y {
        println("less than");
    }

    if x <= y {
        println("less or equal");
    }

    if x > y {
        println("greater than");
    }

    if x >= y {
        println("greater or equal");
    }
}

fn println(msg: &str) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

println() {
    printf '%s\n' "$1"
}

main() {
    x=10
    y=20

    if [ "$x" -eq "$y" ]; then
        println "equal"
    fi

    if [ "$x" -ne "$y" ]; then
        println "not equal"
    fi

    if [ "$x" -lt "$y" ]; then
        println "less than"
    fi

    if [ "$x" -le "$y" ]; then
        println "less or equal"
    fi

    if [ "$x" -gt "$y" ]; then
        println "greater than"
    fi

    if [ "$x" -ge "$y" ]; then
        println "greater or equal"
    fi
}

main "$@"
```

**Operator Mapping:**
- `==` ‚Üí `-eq` (equal)
- `!=` ‚Üí `-ne` (not equal)
- `<` ‚Üí `-lt` (less than)
- `<=` ‚Üí `-le` (less or equal)
- `>` ‚Üí `-gt` (greater than)
- `>=` ‚Üí `-ge` (greater or equal)

### Example 5: String Comparison

Comparing string values:

```rust
fn main() {
    let env = "production";

    if env == "production" {
        println("Running in production");
    }

    if env != "development" {
        println("Not in development");
    }
}

fn println(msg: &str) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

println() {
    printf '%s\n' "$1"
}

main() {
    env="production"

    if [ "$env" = "production" ]; then
        println "Running in production"
    fi

    if [ "$env" != "development" ]; then
        println "Not in development"
    fi
}

main "$@"
```

**Key Points:**
- String equality: `=` (not `==`)
- String inequality: `!=`
- Both operands are quoted
- POSIX-compliant string comparison

### Example 6: Logical AND (&&)

Multiple conditions must all be true:

```rust
fn main() {
    let x = 10;
    let y = 20;

    if x > 5 && y > 15 {
        println("Both conditions true");
    }
}

fn println(msg: &str) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

println() {
    printf '%s\n' "$1"
}

main() {
    x=10
    y=20

    if [ "$x" -gt 5 ] && [ "$y" -gt 15 ]; then
        println "Both conditions true"
    fi
}

main "$@"
```

**Key Points:**
- `&&` becomes ` && ` between test commands
- Each condition in separate `[ ]`
- Short-circuit evaluation (shell standard)

### Example 7: Logical OR (||)

At least one condition must be true:

```rust
fn main() {
    let mode = "debug";

    if mode == "debug" || mode == "test" {
        println("Development mode");
    }
}

fn println(msg: &str) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

println() {
    printf '%s\n' "$1"
}

main() {
    mode="debug"

    if [ "$mode" = "debug" ] || [ "$mode" = "test" ]; then
        println "Development mode"
    fi
}

main "$@"
```

**Key Points:**
- `||` becomes ` || ` between test commands
- Separate `[ ]` for each condition
- Short-circuit: if first is true, second not evaluated

### Example 8: NOT Operator (!)

Negating conditions:

```rust
fn main() {
    let enabled = false;

    if !enabled {
        println("Feature is disabled");
    }
}

fn println(msg: &str) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

println() {
    printf '%s\n' "$1"
}

main() {
    enabled=false

    if [ "$enabled" != true ]; then
        println "Feature is disabled"
    fi
}

main "$@"
```

**Key Points:**
- `!` (not) is converted to appropriate shell test
- For booleans: `!x` ‚Üí `x != true`
- Clean negation without `!` in shell (more portable)

### Example 9: Nested If Statements

Conditions within conditions:

```rust
fn main() {
    let x = 15;
    let y = 20;

    if x > 10 {
        if y > 15 {
            println("Both x > 10 and y > 15");
        } else {
            println("x > 10 but y <= 15");
        }
    } else {
        println("x <= 10");
    }
}

fn println(msg: &str) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

println() {
    printf '%s\n' "$1"
}

main() {
    x=15
    y=20

    if [ "$x" -gt 10 ]; then
        if [ "$y" -gt 15 ]; then
            println "Both x > 10 and y > 15"
        else
            println "x > 10 but y <= 15"
        fi
    else
        println "x <= 10"
    fi
}

main "$@"
```

**Key Points:**
- Arbitrary nesting depth supported
- Proper indentation maintained
- Inner `if` has own `fi`
- Clear block structure

### Example 10: Conditional Function Calls

Using if to control which functions execute:

```rust
fn main() {
    let mode = "install";

    if mode == "install" {
        install();
    } else if mode == "uninstall" {
        uninstall();
    } else if mode == "upgrade" {
        upgrade();
    } else {
        show_help();
    }
}

fn install() {}
fn uninstall() {}
fn upgrade() {}
fn show_help() {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

install() {
    :
}

uninstall() {
    :
}

upgrade() {
    :
}

show_help() {
    :
}

main() {
    mode="install"

    if [ "$mode" = "install" ]; then
        install
    elif [ "$mode" = "uninstall" ]; then
        uninstall
    elif [ "$mode" = "upgrade" ]; then
        upgrade
    else
        show_help
    fi
}

main "$@"
```

**Key Points:**
- Functions called conditionally
- Common pattern for command dispatch
- Clean switch-like behavior (without match)
- Each branch calls different function

### Example 11: Early Return Pattern

Exit function early on condition:

```rust
fn main() {
    validate_and_execute();
}

fn validate_and_execute() {
    let valid = check_preconditions();

    if !valid {
        println("Preconditions failed");
        return;
    }

    println("Executing main logic");
    execute();
}

fn check_preconditions() -> bool {
    true
}

fn execute() {}
fn println(msg: &str) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

println() {
    printf '%s\n' "$1"
}

check_preconditions() {
    echo true
}

execute() {
    :
}

validate_and_execute() {
    valid="$(check_preconditions)"

    if [ "$valid" != true ]; then
        println "Preconditions failed"
        return
    fi

    println "Executing main logic"
    execute
}

main() {
    validate_and_execute
}

main "$@"
```

**Key Points:**
- `return` statement exits function early
- Guards against invalid states
- Boolean functions use `echo` for return value
- Call site captures with `$(...)`

### Example 12: Guard Clauses Pattern

Multiple guard clauses for validation:

```rust
fn main() {
    deploy("myapp", "production");
}

fn deploy(app: &str, env: &str) {
    if app == "" {
        println("Error: app name required");
        return;
    }

    if env != "production" && env != "staging" {
        println("Error: invalid environment");
        return;
    }

    println("Deploying...");
    execute_deploy(app, env);
}

fn execute_deploy(a: &str, e: &str) {}
fn println(msg: &str) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

println() {
    printf '%s\n' "$1"
}

execute_deploy() {
    a="$1"
    e="$2"
}

deploy() {
    app="$1"
    env="$2"

    if [ "$app" = "" ]; then
        println "Error: app name required"
        return
    fi

    if [ "$env" != "production" ] && [ "$env" != "staging" ]; then
        println "Error: invalid environment"
        return
    fi

    println "Deploying..."
    execute_deploy "$app" "$env"
}

main() {
    deploy "myapp" "production"
}

main "$@"
```

**Key Points:**
- Guard clauses validate inputs
- Early returns prevent execution
- Complex condition: `!=` with `&&`
- Clean error handling pattern

### Example 13: Complex Boolean Logic

Combining AND, OR, and NOT:

```rust
fn main() {
    let x = 10;
    let y = 20;
    let z = 30;

    if (x > 5 && y < 25) || z == 30 {
        println("Complex condition satisfied");
    }
}

fn println(msg: &str) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

println() {
    printf '%s\n' "$1"
}

main() {
    x=10
    y=20
    z=30

    if [ "$x" -gt 5 ] && [ "$y" -lt 25 ] || [ "$z" -eq 30 ]; then
        println "Complex condition satisfied"
    fi
}

main "$@"
```

**Key Points:**
- Parentheses in Rust control precedence
- Shell evaluates left-to-right with proper precedence
- `&&` has higher precedence than `||`
- Complex logic transpiles correctly

### Example 14: Boolean Variable Conditions

Using boolean variables directly:

```rust
fn main() {
    let ssl_enabled = true;
    let debug_mode = false;

    if ssl_enabled {
        println("SSL is enabled");
    }

    if !debug_mode {
        println("Debug mode is off");
    }

    if ssl_enabled && !debug_mode {
        println("Production-ready");
    }
}

fn println(msg: &str) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

println() {
    printf '%s\n' "$1"
}

main() {
    ssl_enabled=true
    debug_mode=false

    if [ "$ssl_enabled" = true ]; then
        println "SSL is enabled"
    fi

    if [ "$debug_mode" != true ]; then
        println "Debug mode is off"
    fi

    if [ "$ssl_enabled" = true ] && [ "$debug_mode" != true ]; then
        println "Production-ready"
    fi
}

main "$@"
```

**Key Points:**
- Boolean `true`/`false` values
- Direct boolean check: `= true`
- Negated: `!= true`
- Combine with `&&`/`||`

### Example 15: Installer Conditional Logic

Real-world bootstrap installer pattern:

```rust
fn main() {
    let mode = "install";
    let force = false;
    let version = "1.0.0";

    if mode == "install" {
        if !check_already_installed() {
            install_package(version);
        } else if force {
            println("Forcing reinstall");
            reinstall_package(version);
        } else {
            println("Already installed");
        }
    } else if mode == "uninstall" {
        if check_already_installed() {
            uninstall_package();
        } else {
            println("Not installed");
        }
    }
}

fn check_already_installed() -> bool {
    false
}

fn install_package(v: &str) {}
fn reinstall_package(v: &str) {}
fn uninstall_package() {}
fn println(msg: &str) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

println() {
    printf '%s\n' "$1"
}

check_already_installed() {
    echo false
}

install_package() {
    v="$1"
}

reinstall_package() {
    v="$1"
}

uninstall_package() {
    :
}

main() {
    mode="install"
    force=false
    version="1.0.0"

    if [ "$mode" = "install" ]; then
        if [ "$(check_already_installed)" != true ]; then
            install_package "$version"
        elif [ "$force" = true ]; then
            println "Forcing reinstall"
            reinstall_package "$version"
        else
            println "Already installed"
        fi
    elif [ "$mode" = "uninstall" ]; then
        if [ "$(check_already_installed)" = true ]; then
            uninstall_package
        else
            println "Not installed"
        fi
    fi
}

main "$@"
```

**Key Points:**
- Nested conditionals for complex logic
- Function return values in conditions
- Multiple modes with different logic
- Force flag override pattern
- Real-world installer structure

## Core Concepts

### If Statements

bashrs if statements map directly to shell conditionals:

```rust
if condition {
    // then block
} else {
    // else block
}
```

Becomes:
```sh
if [ condition ]; then
    # then block
else
    # else block
fi
```

### Comparison Operators

| Rust | Shell (int) | Shell (str) | Meaning |
|------|------------|-------------|---------|
| `==` | `-eq` | `=` | Equal |
| `!=` | `-ne` | `!=` | Not equal |
| `<` | `-lt` | N/A | Less than |
| `<=` | `-le` | N/A | Less or equal |
| `>` | `-gt` | N/A | Greater than |
| `>=` | `-ge` | N/A | Greater or equal |

**Important**: bashrs chooses the correct operator based on operand types (compile-time).

### Logical Operators

- `&&` (AND): Both conditions must be true
- `||` (OR): At least one condition must be true
- `!` (NOT): Negates condition

```rust
if x > 0 && y < 100 { }   // AND
if a == 1 || b == 2 { }   // OR
if !enabled { }            // NOT
```

### Boolean Values

Boolean variables are compared explicitly:

```rust
let flag = true;
if flag { }        // ‚Üí [ "$flag" = true ]
if !flag { }       // ‚Üí [ "$flag" != true ]
```

### Return Statements

Early exit from functions:

```rust
fn validate() {
    if error {
        return;  // Exit function early
    }
    // Continue...
}
```

### Operator Precedence

Shell follows standard precedence:
1. NOT (`!`)
2. AND (`&&`)
3. OR (`||`)

Use Rust parentheses `()` to control precedence (transpiled correctly).

## How Transpilation Works

```
Rust: if x > 10 { println("big"); }
      ‚Üì
AST: If { cond: BinaryOp(Gt, Var(x), Lit(10)), then: [Call(println, ...)] }
      ‚Üì
IR: If { cond: Greater(Var(x), Int(10)), then: [...], else: None }
      ‚Üì
Shell:
if [ "$x" -gt 10 ]; then
    println "big"
fi
```

### Safety Guarantees

1. **Type Checking** (compile-time):
   - Comparison operand types must match
   - Boolean context validated
   - Operator compatibility checked

2. **Shell Safety**:
   - All variables quoted: `"$var"`
   - Correct test operators: `-eq`, `-lt`, `=`
   - POSIX-compliant syntax

3. **Logical Safety**:
   - No unquoted `$?` (use return values)
   - No `[[ ]]` (Bash-only, not POSIX)
   - Clean `[ ]` test syntax

## Common Patterns

### Mode Dispatcher

```rust
fn main() {
    let mode = "install";
    if mode == "install" {
        install();
    } else if mode == "uninstall" {
        uninstall();
    }
}
```

### Feature Flags

```rust
fn main() {
    let ssl = true;
    let debug = false;

    if ssl {
        enable_ssl();
    }
    if !debug {
        optimize();
    }
}
```

### Validation Chain

```rust
fn deploy() {
    if !check_network() {
        return;
    }
    if !check_disk() {
        return;
    }
    execute_deploy();
}
```

## Edge Cases and Limitations

### ‚úÖ Supported

- If/else/else-if chains
- Integer comparisons: ==, !=, <, <=, >, >=
- String comparisons: ==, !=
- Boolean values: true, false
- Logical operators: &&, ||, !
- Nested if statements
- Early return
- Function calls in conditions (bool return)

### ‚ö†Ô∏è Partial Support

- **Complex parenthesized expressions**: May not preserve all grouping
- **Mixed type comparisons**: Not allowed (compile error)

### ‚ùå Not Supported (v1.0)

- `for` loops - planned for v1.1
- `while` loops - planned for v1.1
- `loop` - planned for v1.1
- `match` expressions - planned for v1.2
- `break`/`continue` - requires loops
- Ternary operator `? :` - use if/else
- Pattern matching `if let` - use regular if

### Shell Compatibility

All control flow features work on:
- ‚úÖ POSIX sh
- ‚úÖ Dash (Debian/Ubuntu)
- ‚úÖ Bash (3.2+)
- ‚úÖ Ash (BusyBox)

## Testing Your Examples

Create a test file with conditionals:

```rust
// test_control.rs
fn main() {
    let x = 10;

    if x > 5 {
        greet("big");
    } else {
        greet("small");
    }
}

fn greet(msg: &str) {}
```

Build and verify:

```bash
$ bashrs build test_control.rs -o test_control.sh
‚úì Transpiled successfully

$ cat test_control.sh
#!/bin/sh
# Generated by bashrs

greet() {
    msg="$1"
}

main() {
    x=10

    if [ "$x" -gt 5 ]; then
        greet "big"
    else
        greet "small"
    fi
}

main "$@"

$ shellcheck -s sh test_control.sh
‚úì No issues detected

$ ./test_control.sh
```

## Verification Levels

Conditional safety varies by verification level:

```bash
# Basic: Standard quoting
$ bashrs build control.rs --verify basic

# Strict: Paranoid quoting (default)
$ bashrs build control.rs --verify strict

# Paranoid: Rejects dynamic conditions
$ bashrs build control.rs --verify paranoid
```

## Next Steps

Now that you understand control flow, let's explore [Appendix A: Installation](appendix-a-installation.md) to learn about:
- Installing bashrs from source
- Installing from crates.io
- Binary releases
- Shell completion setup

## Reference

- Test files: `tests/ch04-control-flow/`
- Example files: `examples/ch04-*.rs`
- Generated output: `target/test-examples/ch04-*.sh`
- ShellCheck reports: `target/shellcheck-reports/ch04-*.txt`
- Related: [Chapter 3: Functions](ch03-functions-tdd.md)
- Related: [Chapter 5: Error Handling](ch05-error-handling-tdd.md)
- Related: [Chapter 18: Limitations](ch18-limitations.md)
