# Chapter 1: Hello Shell Script

<!-- DOC_STATUS_START -->
**Chapter Status**: ‚úÖ 100% Working (5/5 examples)

| Status | Count | Examples |
|--------|-------|----------|
| ‚úÖ Working | 5 | Ready for production use |
| ‚ö†Ô∏è Partial | 0 | Some edge cases not covered |
| ‚ùå Broken | 0 | Known issues, needs fixing |
| üìã Planned | 0 | Future roadmap features |

*Last updated: 2025-10-02*
*bashrs version: 0.1.0*
<!-- DOC_STATUS_END -->

---

## The Problem

Every bashrs journey begins with "Hello, Shell!" - your first proof that Rust can generate safe, POSIX-compliant shell scripts.

Unlike traditional shell scripting where you write raw shell code, bashrs lets you write in familiar Rust syntax and transpiles to verified, deterministic shell output.

## Test-Driven Examples

### Example 1: Basic Hello World

This example is tested in `tests/ch01-hello-shell/test_01_basic.rs`:

```rust
// examples/hello.rs
#[bashrs::main]
fn main() {
    println!("Hello, Shell!");
}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

rash_println() {
    printf '%s\n' "$1"
}

main() {
    rash_println "Hello, Shell!"
}

main "$@"
```

**ShellCheck Validation:**
```bash
$ bashrs build examples/hello.rs -o hello.sh
‚úì Transpiled successfully
$ shellcheck -s sh hello.sh
‚úì No issues detected (POSIX compliant)
$ ./hello.sh
Hello, Shell!
```

**Key Points:**
- `#[bashrs::main]` marks the entry point
- `println!` transpiles to safe `printf` wrapper
- Output is POSIX-compliant and passes ShellCheck
- Deterministic: same Rust ‚Üí same shell output

### Example 2: Multiple Print Statements

This example is tested in `tests/ch01-hello-shell/test_02_multiple_prints.rs`:

```rust
#[bashrs::main]
fn main() {
    println!("Installing dependencies...");
    println!("Configuring system...");
    println!("Done!");
}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

rash_println() {
    printf '%s\n' "$1"
}

main() {
    rash_println "Installing dependencies..."
    rash_println "Configuring system..."
    rash_println "Done!"
}

main "$@"
```

**Output:**
```
Installing dependencies...
Configuring system...
Done!
```

### Example 3: Using Variables

This example is tested in `tests/ch01-hello-shell/test_03_with_variable.rs`:

```rust
#[bashrs::main]
fn main() {
    let greeting = "Hello from bashrs!";
    println!(greeting);
}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

rash_println() {
    printf '%s\n' "$1"
}

main() {
    greeting="Hello from bashrs!"
    rash_println "$greeting"
}

main "$@"
```

**Key Points:**
- Variables are properly quoted (`"$greeting"`)
- No injection risk (quotes are mandatory)
- POSIX-compliant variable assignment

### Example 4: String Literals with Special Characters

This example is tested in `tests/ch01-hello-shell/test_04_special_chars.rs`:

```rust
#[bashrs::main]
fn main() {
    println!("Hello, \"World\"!");
    println!("Path: /usr/local/bin");
    println!("Price: $100");
}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

rash_println() {
    printf '%s\n' "$1"
}

main() {
    rash_println "Hello, \"World\"!"
    rash_println "Path: /usr/local/bin"
    rash_println "Price: \$100"
}

main "$@"
```

**Output:**
```
Hello, "World"!
Path: /usr/local/bin
Price: $100
```

**Key Points:**
- Double quotes inside strings are escaped
- Dollar signs are escaped to prevent variable expansion
- Paths with special characters are safe

### Example 5: Unicode Support

This example is tested in `tests/ch01-hello-shell/test_05_unicode.rs`:

```rust
#[bashrs::main]
fn main() {
    println!("Hello, ‰∏ñÁïå!");
    println!("emoji: ü¶Ä");
}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

rash_println() {
    printf '%s\n' "$1"
}

main() {
    rash_println "Hello, ‰∏ñÁïå!"
    rash_println "emoji: ü¶Ä"
}

main "$@"
```

**Output:**
```
Hello, ‰∏ñÁïå!
emoji: ü¶Ä
```

**Key Points:**
- Unicode characters are preserved
- UTF-8 encoding is maintained
- Works on all POSIX-compliant shells

## Core Concepts

### The `#[bashrs::main]` Attribute
- Marks the entry point function
- Must be applied to exactly one function
- Function must be named `main()` or have this attribute
- Generates wrapper that calls your function

### The `println!` Macro
- Transpiles to safe `printf` wrapper
- Automatically escapes special characters
- Adds newline after output
- Injection-proof by design

### Variable Quoting
- All variables are double-quoted: `"$var"`
- Prevents word splitting and globbing
- POSIX-compliant and ShellCheck-approved
- No way to accidentally create injection vulnerabilities

### Runtime Functions
bashrs generates helper functions for common operations:
- `rash_println()`: Safe printing with printf
- More helpers in later chapters

## How Transpilation Works

```
Rust Source Code
      ‚Üì
   Parser (syn)
      ‚Üì
Restricted AST
      ‚Üì
  IR Generation
      ‚Üì
  Verification
      ‚Üì
Shell Emission
      ‚Üì
ShellCheck Validation
      ‚Üì
POSIX Shell Script
```

## Verification Levels

bashrs supports multiple verification levels:

```bash
# Basic (default): Essential safety checks
$ bashrs build hello.rs -o hello.sh

# Strict: Paranoid quoting and escaping
$ bashrs build hello.rs -o hello.sh --verify strict

# Paranoid: Maximum safety, no dynamic content
$ bashrs build hello.rs -o hello.sh --verify paranoid
```

## Common Patterns

### Bootstrap Installer Header
```rust
#[bashrs::main]
fn main() {
    println!("=== System Bootstrap Installer ===");
    println!("Version: 1.0.0");
    println!("");
    // ... installation logic
}
```

### Progress Messages
```rust
#[bashrs::main]
fn main() {
    println!("[1/3] Downloading packages...");
    println!("[2/3] Installing...");
    println!("[3/3] Configuring...");
    println!("‚úì Installation complete!");
}
```

## Edge Cases and Limitations

### ‚úÖ Supported
- UTF-8 string literals
- Escaped quotes and special chars
- Variables with safe quoting
- Multiple print statements

### ‚ö†Ô∏è Partial Support
- Format strings (coming in Chapter 2)
- String interpolation (coming in Chapter 2)

### ‚ùå Not Supported
- `print!` (use `println!` instead)
- Raw strings `r#"..."#` (use regular strings)
- Byte strings `b"..."` (not applicable to shell)

## Testing Your Examples

Run all Chapter 1 examples:

```bash
$ cd bashrs
$ make test-ch01
‚úì test_01_basic ... ok
‚úì test_02_multiple_prints ... ok
‚úì test_03_with_variable ... ok
‚úì test_04_special_chars ... ok
‚úì test_05_unicode ... ok

5 tests passed
```

## Next Steps

Now that you can print to the console, let's explore [Chapter 2: Variables and Assignment](ch02-variables-tdd.md) to learn about:
- Variable types (strings, integers, booleans)
- Assignments and mutations
- Scope and shadowing
- Type conversions

## Reference

- Test files: `tests/ch01-hello-shell/`
- Example files: `examples/ch01-*.rs`
- Generated output: `target/test-examples/ch01-*.sh`
- ShellCheck reports: `target/shellcheck-reports/ch01-*.txt`
