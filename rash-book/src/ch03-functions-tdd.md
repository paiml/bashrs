# Chapter 3: Functions and Parameters

<!-- DOC_STATUS_START -->
**Chapter Status**: ‚úÖ 100% Working (12/12 examples)

| Status | Count | Examples |
|--------|-------|----------|
| ‚úÖ Working | 12 | Ready for production use |
| ‚ö†Ô∏è Partial | 0 | Some edge cases not covered |
| ‚ùå Broken | 0 | Known issues, needs fixing |
| üìã Planned | 0 | Future roadmap features |

*Last updated: 2025-10-04*
*bashrs version: 0.9.3*
<!-- DOC_STATUS_END -->

---

## The Problem

Shell functions are powerful but brittle. Missing parameter checks, unsafe variable expansion, and unclear interfaces make maintenance difficult. bashrs brings Rust's type-safe function signatures to shell scripting.

In this chapter, you'll learn how bashrs transpiles Rust functions into POSIX shell functions with verified parameter handling and type safety.

## Test-Driven Examples

### Example 1: Basic Function (No Parameters)

The simplest bashrs function - no parameters, just execution:

```rust
fn main() {
    greet();
}

fn greet() {
    println("Hello, Shell!");
}

fn println(msg: &str) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

println() {
    printf '%s\n' "$1"
}

greet() {
    println "Hello, Shell!"
}

main() {
    greet
}

main "$@"
```

**Key Points:**
- Functions without parameters are called without arguments
- Each Rust function becomes a shell function
- Functions are defined before `main()`
- Call order: `main "$@"` ‚Üí `main()` ‚Üí `greet()`

### Example 2: Function with One Parameter

Single parameter functions demonstrate type-safe passing:

```rust
fn main() {
    let name = "Alice";
    greet(name);
}

fn greet(name: &str) {
    println(name);
}

fn println(msg: &str) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

println() {
    printf '%s\n' "$1"
}

greet() {
    name="$1"
    println "$name"
}

main() {
    name="Alice"
    greet "$name"
}

main "$@"
```

**Key Points:**
- Parameters are accessed as `$1`, `$2`, etc.
- Parameters are assigned to named local variables
- Automatic quoting: `greet "$name"`
- Type safety enforced at transpile-time

### Example 3: Multiple Parameters (Same Type)

Functions can accept multiple parameters of the same type:

```rust
fn main() {
    show_info("myapp", "1.0.0", "/usr/local");
}

fn show_info(name: &str, version: &str, prefix: &str) {
    println(name);
    println(version);
    println(prefix);
}

fn println(msg: &str) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

println() {
    printf '%s\n' "$1"
}

show_info() {
    name="$1"
    version="$2"
    prefix="$3"
    println "$name"
    println "$version"
    println "$prefix"
}

main() {
    show_info "myapp" "1.0.0" "/usr/local"
}

main "$@"
```

**Key Points:**
- Parameters are positional: `$1`, `$2`, `$3`
- Order matters (Rust enforces this)
- Each parameter gets a named variable
- All literals are properly quoted

### Example 4: Mixed Type Parameters

Combining strings, integers, and booleans:

```rust
fn main() {
    configure("myapp", 8080, true);
}

fn configure(name: &str, port: i32, enabled: bool) {
    show_name(name);
    show_port(port);
    show_status(enabled);
}

fn show_name(n: &str) {}
fn show_port(p: i32) {}
fn show_status(s: bool) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

show_name() {
    n="$1"
}

show_port() {
    p="$1"
}

show_status() {
    s="$1"
}

configure() {
    name="$1"
    port="$2"
    enabled="$3"
    show_name "$name"
    show_port "$port"
    show_status "$enabled"
}

main() {
    configure "myapp" 8080 true
}

main "$@"
```

**Key Points:**
- Type mixing works seamlessly
- Integer `8080` passed without quotes (assignment)
- Boolean `true` passed as literal
- When used as arguments, all are quoted

### Example 5: Function Calling Another Function

Function composition - the foundation of structured scripts:

```rust
fn main() {
    install_app("myapp", "1.0.0");
}

fn install_app(name: &str, version: &str) {
    download(name, version);
    extract(name);
    configure(name);
}

fn download(n: &str, v: &str) {}
fn extract(n: &str) {}
fn configure(n: &str) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

download() {
    n="$1"
    v="$2"
}

extract() {
    n="$1"
}

configure() {
    n="$1"
}

install_app() {
    name="$1"
    version="$2"
    download "$name" "$version"
    extract "$name"
    configure "$name"
}

main() {
    install_app "myapp" "1.0.0"
}

main "$@"
```

**Key Points:**
- Functions can call other functions
- Parameters are forwarded with proper quoting
- Execution order: top to bottom
- Clean separation of concerns

### Example 6: Multiple Helper Functions

Organizing code with helper functions:

```rust
fn main() {
    setup_environment();
    install_dependencies();
    configure_system();
    start_services();
}

fn setup_environment() {}
fn install_dependencies() {}
fn configure_system() {}
fn start_services() {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

setup_environment() {
    :
}

install_dependencies() {
    :
}

configure_system() {
    :
}

start_services() {
    :
}

main() {
    setup_environment
    install_dependencies
    configure_system
    start_services
}

main "$@"
```

**Key Points:**
- Empty functions generate `:` (POSIX no-op)
- Clear execution flow
- Each function is a logical step
- Easy to add implementation later

### Example 7: Nested Function Calls

Deep function call chains for complex logic:

```rust
fn main() {
    deploy();
}

fn deploy() {
    prepare();
}

fn prepare() {
    validate();
}

fn validate() {
    check_requirements();
}

fn check_requirements() {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

check_requirements() {
    :
}

validate() {
    check_requirements
}

prepare() {
    validate
}

deploy() {
    prepare
}

main() {
    deploy
}

main "$@"
```

**Key Points:**
- Arbitrary nesting depth supported
- Call stack: main ‚Üí deploy ‚Üí prepare ‚Üí validate ‚Üí check_requirements
- Functions defined in dependency order
- Clean, readable shell output

### Example 8: Bootstrap Installer Pattern

Real-world installer with multiple stages:

```rust
fn main() {
    let app = "myapp";
    let version = "1.0.0";
    let prefix = "/usr/local";

    check_prerequisites(app);
    download_binary(app, version);
    verify_checksum(app, version);
    install_binary(app, prefix);
    create_config(app, prefix);
    setup_service(app);
}

fn check_prerequisites(name: &str) {}
fn download_binary(name: &str, ver: &str) {}
fn verify_checksum(name: &str, ver: &str) {}
fn install_binary(name: &str, prefix: &str) {}
fn create_config(name: &str, prefix: &str) {}
fn setup_service(name: &str) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

check_prerequisites() {
    name="$1"
}

download_binary() {
    name="$1"
    ver="$2"
}

verify_checksum() {
    name="$1"
    ver="$2"
}

install_binary() {
    name="$1"
    prefix="$2"
}

create_config() {
    name="$1"
    prefix="$2"
}

setup_service() {
    name="$1"
}

main() {
    app="myapp"
    version="1.0.0"
    prefix="/usr/local"

    check_prerequisites "$app"
    download_binary "$app" "$version"
    verify_checksum "$app" "$version"
    install_binary "$app" "$prefix"
    create_config "$app" "$prefix"
    setup_service "$app"
}

main "$@"
```

**Key Points:**
- Variables passed to multiple functions
- Each function has clear responsibility
- Parameters reused across function calls
- Installer pattern: check ‚Üí download ‚Üí verify ‚Üí install ‚Üí configure

### Example 9: Many Parameters (Complex Functions)

Handling functions with many configuration parameters:

```rust
fn main() {
    deploy_service(
        "myapp",
        "1.0.0",
        "/usr/local",
        8080,
        443,
        true,
        false,
        "production"
    );
}

fn deploy_service(
    name: &str,
    version: &str,
    prefix: &str,
    http_port: i32,
    https_port: i32,
    ssl_enabled: bool,
    debug: bool,
    env: &str
) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

deploy_service() {
    name="$1"
    version="$2"
    prefix="$3"
    http_port="$4"
    https_port="$5"
    ssl_enabled="$6"
    debug="$7"
    env="$8"
}

main() {
    deploy_service "myapp" "1.0.0" "/usr/local" 8080 443 true false "production"
}

main "$@"
```

**Key Points:**
- Support for many parameters (8 shown, more possible)
- Positional parameters: `$1` through `$8`
- Clear parameter assignment in function body
- Types are enforced at transpile-time

### Example 10: Parameter Naming Patterns

Clear, descriptive parameter names:

```rust
fn main() {
    create_database("mydb", "localhost", 5432, "admin", "secure_pass");
}

fn create_database(
    database_name: &str,
    host: &str,
    port: i32,
    admin_user: &str,
    admin_password: &str
) {
    connect(host, port);
    authenticate(admin_user, admin_password);
    initialize(database_name);
}

fn connect(h: &str, p: i32) {}
fn authenticate(u: &str, pwd: &str) {}
fn initialize(db: &str) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

connect() {
    h="$1"
    p="$2"
}

authenticate() {
    u="$1"
    pwd="$2"
}

initialize() {
    db="$1"
}

create_database() {
    database_name="$1"
    host="$2"
    port="$3"
    admin_user="$4"
    admin_password="$5"
    connect "$host" "$port"
    authenticate "$admin_user" "$admin_password"
    initialize "$database_name"
}

main() {
    create_database "mydb" "localhost" 5432 "admin" "secure_pass"
}

main "$@"
```

**Key Points:**
- Descriptive names improve readability
- Short aliases in helper functions (h, p, u, pwd, db)
- Parameters forwarded with full names
- Self-documenting code

### Example 11: Variadic-Style Pattern (Fixed Parameters)

Simulating variadic functions with fixed parameter count:

```rust
fn main() {
    install_packages("pkg1", "pkg2", "pkg3", "pkg4", "pkg5");
}

fn install_packages(p1: &str, p2: &str, p3: &str, p4: &str, p5: &str) {
    install_one(p1);
    install_one(p2);
    install_one(p3);
    install_one(p4);
    install_one(p5);
}

fn install_one(pkg: &str) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

install_one() {
    pkg="$1"
}

install_packages() {
    p1="$1"
    p2="$2"
    p3="$3"
    p4="$4"
    p5="$5"
    install_one "$p1"
    install_one "$p2"
    install_one "$p3"
    install_one "$p4"
    install_one "$p5"
}

main() {
    install_packages "pkg1" "pkg2" "pkg3" "pkg4" "pkg5"
}

main "$@"
```

**Key Points:**
- Fixed parameter count (no true varargs in v1.0)
- Pattern: wrapper function ‚Üí multiple calls to worker
- Type-safe: all parameters must be provided
- Common pattern for batch operations

### Example 12: Two-Stage Deployment Pattern

Common deployment workflow with separate prepare/execute stages:

```rust
fn main() {
    let app = "webapp";
    let env = "production";
    let version = "2.1.0";

    prepare_deployment(app, env, version);
    execute_deployment(app, env);
}

fn prepare_deployment(name: &str, environment: &str, ver: &str) {
    fetch_artifacts(name, ver);
    validate_artifacts(name);
    backup_current(name, environment);
}

fn execute_deployment(name: &str, environment: &str) {
    stop_services(name, environment);
    deploy_artifacts(name);
    start_services(name, environment);
    verify_deployment(name);
}

fn fetch_artifacts(n: &str, v: &str) {}
fn validate_artifacts(n: &str) {}
fn backup_current(n: &str, e: &str) {}
fn stop_services(n: &str, e: &str) {}
fn deploy_artifacts(n: &str) {}
fn start_services(n: &str, e: &str) {}
fn verify_deployment(n: &str) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

fetch_artifacts() {
    n="$1"
    v="$2"
}

validate_artifacts() {
    n="$1"
}

backup_current() {
    n="$1"
    e="$2"
}

stop_services() {
    n="$1"
    e="$2"
}

deploy_artifacts() {
    n="$1"
}

start_services() {
    n="$1"
    e="$2"
}

verify_deployment() {
    n="$1"
}

prepare_deployment() {
    name="$1"
    environment="$2"
    ver="$3"
    fetch_artifacts "$name" "$ver"
    validate_artifacts "$name"
    backup_current "$name" "$environment"
}

execute_deployment() {
    name="$1"
    environment="$2"
    stop_services "$name" "$environment"
    deploy_artifacts "$name"
    start_services "$name" "$environment"
    verify_deployment "$name"
}

main() {
    app="webapp"
    env="production"
    version="2.1.0"

    prepare_deployment "$app" "$env" "$version"
    execute_deployment "$app" "$env"
}

main "$@"
```

**Key Points:**
- Two-phase deployment (prepare, then execute)
- Functions organized by responsibility
- Parameters passed through call hierarchy
- Easy to add rollback logic

## Core Concepts

### Function Definitions

In bashrs, all functions are defined with `fn`:

```rust
fn function_name(param1: Type1, param2: Type2) {
    // body
}
```

Transpiles to:
```sh
function_name() {
    param1="$1"
    param2="$2"
    # body
}
```

### Parameter Types

bashrs v1.0 supports these parameter types:

| Rust Type | Shell Access | Example |
|-----------|-------------|---------|
| `&str` | `$1`, `$2`, ... | `name="$1"` |
| `i32` | `$1`, `$2`, ... | `port="$1"` |
| `bool` | `$1`, `$2`, ... | `enabled="$1"` |

**Important**: All parameters become strings in shell, but Rust type checking ensures correct usage at transpile-time.

### Function Calls

Function calls are transpiled with automatic quoting:

```rust
// Rust
greet(name);

// Shell
greet "$name"
```

Arguments are always quoted for safety.

### Parameter Limits

POSIX shells support positional parameters `$1` through `$9`, with `${10}` onwards requiring braces. bashrs v1.0:

- ‚úÖ Supports any number of parameters
- ‚úÖ Uses `$1`, `$2`, ... `$9`
- ‚úÖ Uses `${10}`, `${11}`, ... for 10+
- ‚úÖ Automatic brace wrapping

### Empty Functions

Functions with no body emit POSIX no-op:

```rust
fn placeholder() {}

// Generates:
placeholder() {
    :
}
```

The `:` is a POSIX built-in that always succeeds.

## How Transpilation Works

```
Rust: fn greet(name: &str) { println(name); }
      ‚Üì
AST: FnDef { name: "greet", params: [(name, &str)], body: [Call(println, [name])] }
      ‚Üì
IR: FunctionDef { name: "greet", params: [(name, String)], body: [FuncCall(println, [Var(name)])] }
      ‚Üì
Shell:
greet() {
    name="$1"
    println "$name"
}
```

### Safety Guarantees

1. **Type Checking** (compile-time):
   - Parameter count must match
   - Parameter types must match
   - No implicit conversions

2. **Parameter Assignment**:
   - All parameters get local variables
   - Positional params: `$1`, `$2`, ...
   - Automatic quoting in assignments

3. **Call Safety**:
   - All arguments quoted: `func "$arg1" "$arg2"`
   - No word splitting
   - No glob expansion

## Common Patterns

### Installer Pipeline

```rust
fn main() {
    let pkg = "myapp";
    check(pkg);
    download(pkg);
    install(pkg);
    configure(pkg);
}

fn check(p: &str) {}
fn download(p: &str) {}
fn install(p: &str) {}
fn configure(p: &str) {}
```

### Configuration Wrapper

```rust
fn main() {
    setup_app("myapp", "/opt", 8080, true);
}

fn setup_app(name: &str, prefix: &str, port: i32, ssl: bool) {
    setup_directories(prefix);
    setup_network(port, ssl);
    setup_config(name, prefix);
}
```

### Error-Handling Stages

```rust
fn main() {
    if !validate() {
        return;  // Chapter 4: Control Flow
    }
    execute();
}

fn validate() -> bool { true }
fn execute() {}
```

## Edge Cases and Limitations

### ‚úÖ Supported

- Functions with 0-N parameters
- Mixed parameter types (&str, i32, bool)
- Nested function calls (any depth)
- Empty functions
- Multiple functions calling same function

### ‚ö†Ô∏è Partial Support

- **Return values**: Only via exit codes (v1.0), not direct values
- **Recursion**: Supported but no tail-call optimization
- **Default parameters**: Not supported

### ‚ùå Not Supported (v1.0)

- Varargs: `fn foo(items: &[&str])` - use fixed params
- Generic functions: `fn foo<T>(x: T)` - not applicable
- Return values: `fn add(a: i32, b: i32) -> i32` - planned for v1.1
- Closures/lambdas: `let f = |x| x + 1` - not in scope
- Methods: `impl Foo { fn bar() {} }` - use standalone functions
- Associated functions: `Foo::new()` - use regular functions

### Shell Compatibility

All function features work on:
- ‚úÖ POSIX sh
- ‚úÖ Dash (Debian/Ubuntu)
- ‚úÖ Bash (3.2+)
- ‚úÖ Ash (BusyBox)

## Testing Your Examples

Create a test file with multiple functions:

```rust
// test_funcs.rs
fn main() {
    deploy("myapp", "1.0.0");
}

fn deploy(name: &str, version: &str) {
    check(name);
    install(name, version);
}

fn check(n: &str) {}
fn install(n: &str, v: &str) {}
```

Build and verify:

```bash
$ bashrs build test_funcs.rs -o test_funcs.sh
‚úì Transpiled successfully

$ cat test_funcs.sh
#!/bin/sh
# Generated by bashrs

check() {
    n="$1"
}

install() {
    n="$1"
    v="$2"
}

deploy() {
    name="$1"
    version="$2"
    check "$name"
    install "$name" "$version"
}

main() {
    deploy "myapp" "1.0.0"
}

main "$@"

$ shellcheck -s sh test_funcs.sh
‚úì No issues detected
```

## Verification Levels

Function call safety varies by verification level:

```bash
# Basic: Standard quoting
$ bashrs build funcs.rs --verify basic

# Strict: Paranoid quoting (default)
$ bashrs build funcs.rs --verify strict

# Paranoid: Rejects dynamic calls
$ bashrs build funcs.rs --verify paranoid
```

For production installers, use `--verify strict`.

## Next Steps

Now that you understand functions, let's explore [Chapter 4: Control Flow](ch04-control-flow-tdd.md) to learn about:
- If/else conditionals
- Match expressions (limited)
- Loops (for, while)
- Early returns
- Error handling

## Reference

- Test files: `tests/ch03-functions/`
- Example files: `examples/ch03-*.rs`
- Generated output: `target/test-examples/ch03-*.sh`
- ShellCheck reports: `target/shellcheck-reports/ch03-*.txt`
- Related: [Chapter 2: Variables](ch02-variables-tdd.md)
- Related: [Chapter 4: Control Flow](ch04-control-flow-tdd.md)
- Related: [Chapter 18: Limitations](ch18-limitations.md)
