# Chapter 2: Variables and Assignment

<!-- DOC_STATUS_START -->
**Chapter Status**: ‚úÖ 100% Working (10/10 examples)

| Status | Count | Examples |
|--------|-------|----------|
| ‚úÖ Working | 10 | Ready for production use |
| ‚ö†Ô∏è Partial | 0 | Some edge cases not covered |
| ‚ùå Broken | 0 | Known issues, needs fixing |
| üìã Planned | 0 | Future roadmap features |

*Last updated: 2025-10-04*
*bashrs version: 0.9.3*
<!-- DOC_STATUS_END -->

---

## The Problem

Shell scripts are notorious for variable-related bugs: missing quotes, uninitialized variables, type confusion. bashrs brings Rust's type safety and explicit declarations to shell scripting.

In this chapter, you'll learn how bashrs transpiles Rust's `let` bindings into safe, properly-quoted shell variables that are immune to injection attacks.

## Test-Driven Examples

### Example 1: Basic String Variable

The foundation of bashrs variables - simple string assignment and usage:

```rust
fn main() {
    let greeting = "Hello, bashrs!";
    println(greeting);
}

fn println(msg: &str) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

println() {
    printf '%s\n' "$1"
}

main() {
    greeting="Hello, bashrs!"
    println "$greeting"
}

main "$@"
```

**Key Points:**
- `let` bindings become shell variable assignments
- Variables are always double-quoted: `"$greeting"`
- No word splitting or globbing possible
- POSIX-compliant variable names

### Example 2: Integer Variables

bashrs handles numeric literals safely:

```rust
fn main() {
    let port = 8080;
    let workers = 4;
    let timeout = 30;

    show_config(port, workers, timeout);
}

fn show_config(port: i32, workers: i32, timeout: i32) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

show_config() {
    port="$1"
    workers="$2"
    timeout="$3"
}

main() {
    port=8080
    workers=4
    timeout=30

    show_config "$port" "$workers" "$timeout"
}

main "$@"
```

**Key Points:**
- Integer literals are emitted as-is (no quotes needed for assignment)
- When used as arguments, they're quoted for safety
- Shell treats all variables as strings (type info is compile-time only)

### Example 3: Boolean Variables

Boolean values transpile to shell-friendly representations:

```rust
fn main() {
    let enabled = true;
    let debug = false;
    let force = true;

    configure(enabled, debug, force);
}

fn configure(enabled: bool, debug: bool, force: bool) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

configure() {
    enabled="$1"
    debug="$2"
    force="$3"
}

main() {
    enabled=true
    debug=false
    force=true

    configure "$enabled" "$debug" "$force"
}

main "$@"
```

**Key Points:**
- `true` ‚Üí `true`, `false` ‚Üí `false` (shell-compatible values)
- Can be used in conditionals (Chapter 4)
- Consistently quoted when passed as arguments

### Example 4: Multiple Variable Types

Mixing different variable types in one function:

```rust
fn main() {
    let app_name = "myapp";
    let version = "1.0.0";
    let port = 3000;
    let ssl_enabled = true;

    deploy(app_name, version, port, ssl_enabled);
}

fn deploy(name: &str, ver: &str, port: i32, ssl: bool) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

deploy() {
    name="$1"
    ver="$2"
    port="$3"
    ssl="$4"
}

main() {
    app_name="myapp"
    version="1.0.0"
    port=3000
    ssl_enabled=true

    deploy "$app_name" "$version" "$port" "$ssl_enabled"
}

main "$@"
```

**Key Points:**
- String, integer, and boolean variables coexist
- All passed safely with proper quoting
- Parameter names can differ from argument names

### Example 5: Variables with Special Characters

bashrs automatically escapes special characters in variable values:

```rust
fn main() {
    let path = "/usr/local/bin";
    let price = "$100";
    let message = "He said \"hello\"";
    let pattern = "*.txt";

    show_values(path, price, message, pattern);
}

fn show_values(p: &str, pr: &str, m: &str, pat: &str) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

show_values() {
    p="$1"
    pr="$2"
    m="$3"
    pat="$4"
}

main() {
    path="/usr/local/bin"
    price="\$100"
    message="He said \"hello\""
    pattern="*.txt"

    show_values "$path" "$price" "$message" "$pattern"
}

main "$@"
```

**Key Points:**
- Dollar signs are escaped: `$100` ‚Üí `\$100`
- Quotes are escaped: `"hello"` ‚Üí `\"hello\"`
- Glob patterns are safe (quoted when used)
- Paths with special chars work correctly

### Example 6: Path Variables

Common pattern for installation scripts:

```rust
fn main() {
    let prefix = "/usr/local";
    let bin_dir = "/usr/local/bin";
    let lib_dir = "/usr/local/lib";
    let config_dir = "/etc/myapp";

    setup_directories(prefix, bin_dir, lib_dir, config_dir);
}

fn setup_directories(p: &str, b: &str, l: &str, c: &str) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

setup_directories() {
    p="$1"
    b="$2"
    l="$3"
    c="$4"
}

main() {
    prefix="/usr/local"
    bin_dir="/usr/local/bin"
    lib_dir="/usr/local/lib"
    config_dir="/etc/myapp"

    setup_directories "$prefix" "$bin_dir" "$lib_dir" "$config_dir"
}

main "$@"
```

**Key Points:**
- Path variables are safely quoted
- No globbing or expansion surprises
- Works with paths containing spaces (see Example 7)

### Example 7: Paths with Spaces

bashrs handles the notorious "path with spaces" problem:

```rust
fn main() {
    let user_dir = "/home/user/My Documents";
    let app_name = "My App";
    let install_path = "/Program Files/MyApp";

    install(user_dir, app_name, install_path);
}

fn install(user: &str, name: &str, path: &str) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

install() {
    user="$1"
    name="$2"
    path="$3"
}

main() {
    user_dir="/home/user/My Documents"
    app_name="My App"
    install_path="/Program Files/MyApp"

    install "$user_dir" "$app_name" "$install_path"
}

main "$@"
```

**Key Points:**
- Spaces in values are preserved
- Quoting is automatic and correct
- No word splitting issues
- ShellCheck SC2086 compliant

### Example 8: Configuration Variables

Bootstrap installer pattern with multiple configuration values:

```rust
fn main() {
    let repo_url = "https://github.com/user/repo";
    let branch = "main";
    let deploy_user = "appuser";
    let deploy_group = "appgroup";
    let port = 8080;
    let enable_ssl = true;

    configure_deployment(
        repo_url,
        branch,
        deploy_user,
        deploy_group,
        port,
        enable_ssl
    );
}

fn configure_deployment(
    url: &str,
    br: &str,
    user: &str,
    group: &str,
    p: i32,
    ssl: bool
) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

configure_deployment() {
    url="$1"
    br="$2"
    user="$3"
    group="$4"
    p="$5"
    ssl="$6"
}

main() {
    repo_url="https://github.com/user/repo"
    branch="main"
    deploy_user="appuser"
    deploy_group="appgroup"
    port=8080
    enable_ssl=true

    configure_deployment "$repo_url" "$branch" "$deploy_user" "$deploy_group" "$port" "$enable_ssl"
}

main "$@"
```

**Key Points:**
- Mix of string, integer, and boolean config values
- URLs are safely preserved
- Function calls can have many parameters
- All values properly quoted

### Example 9: Variable Naming Conventions

bashrs preserves Rust naming conventions in generated shell:

```rust
fn main() {
    let user_name = "alice";
    let home_directory = "/home/alice";
    let max_connections = 100;
    let is_admin = false;

    create_user(user_name, home_directory, max_connections, is_admin);
}

fn create_user(name: &str, home: &str, max_conn: i32, admin: bool) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

create_user() {
    name="$1"
    home="$2"
    max_conn="$3"
    admin="$4"
}

main() {
    user_name="alice"
    home_directory="/home/alice"
    max_connections=100
    is_admin=false

    create_user "$user_name" "$home_directory" "$max_connections" "$is_admin"
}

main "$@"
```

**Key Points:**
- Snake_case variable names are preserved
- POSIX-compliant identifiers (lowercase, underscores)
- Clear, readable shell output
- No name mangling

### Example 10: Unicode in Variable Values

bashrs supports Unicode in string values:

```rust
fn main() {
    let greeting_ja = "„Åì„Çì„Å´„Å°„ÅØ";
    let greeting_ru = "–ü—Ä–∏–≤–µ—Ç";
    let greeting_ar = "ŸÖÿ±ÿ≠ÿ®ÿß";
    let emoji = "üöÄ Deploying...";

    show_greetings(greeting_ja, greeting_ru, greeting_ar, emoji);
}

fn show_greetings(ja: &str, ru: &str, ar: &str, em: &str) {}
```

**Generated Shell Output:**
```sh
#!/bin/sh
# Generated by bashrs

show_greetings() {
    ja="$1"
    ru="$2"
    ar="$3"
    em="$4"
}

main() {
    greeting_ja="„Åì„Çì„Å´„Å°„ÅØ"
    greeting_ru="–ü—Ä–∏–≤–µ—Ç"
    greeting_ar="ŸÖÿ±ÿ≠ÿ®ÿß"
    emoji="üöÄ Deploying..."

    show_greetings "$greeting_ja" "$greeting_ru" "$greeting_ar" "$emoji"
}

main "$@"
```

**Key Points:**
- UTF-8 strings are fully supported
- Unicode is preserved in generated shell
- Works on all modern POSIX shells
- Emoji support for user-friendly output

## Core Concepts

### The `let` Binding

In bashrs, all variables are declared with `let`:

```rust
let variable_name = value;
```

This transpiles to shell variable assignment:
```sh
variable_name=value    # For literals
variable_name="value"  # For strings
```

### Variable Types

bashrs supports these types (compile-time only):

| Rust Type | Shell Representation | Example |
|-----------|---------------------|---------|
| `&str` | Quoted string | `name="alice"` |
| `i32` | Unquoted number | `port=8080` |
| `bool` | `true`/`false` | `enabled=true` |

**Important**: Shell treats everything as strings. Type info exists only during transpilation for safety checks.

### Automatic Quoting

bashrs follows the "quote everything" principle:

- **Variable assignment**: Only quoted if it's a string literal
- **Variable usage**: Always quoted: `"$var"`
- **Function arguments**: Always quoted: `func "$arg1" "$arg2"`

This eliminates entire categories of shell bugs:
- ‚úÖ No word splitting
- ‚úÖ No glob expansion
- ‚úÖ No injection attacks
- ‚úÖ ShellCheck clean

### Variable Scope

bashrs v1.0 has simple scoping rules:

- Variables in `main()` are in main function scope
- Variables in other functions are local to that function
- Function parameters are local variables
- No global variables (by design - safer)

```rust
fn main() {
    let x = "main scope";
    foo();  // Can't access x
}

fn foo() {
    let y = "foo scope";  // Can't access x
}
```

### Immutability

All bashrs variables are **immutable** (v1.0):

```rust
let x = 10;
x = 20;  // ‚ùå ERROR: Cannot mutate immutable variable
```

This is intentional:
- Prevents complex state mutations
- Makes bootstrap scripts more predictable
- Aligns with functional shell scripting style

**Note**: Mutability (`let mut`) is planned for v1.1+

## How Transpilation Works

```
Rust: let name = "value";
      ‚Üì
AST: LetStmt { pat: Ident("name"), init: Lit("value") }
      ‚Üì
IR: VarDecl { name: "name", value: Literal("value"), ty: String }
      ‚Üì
Shell: name="value"

Rust: function_call(name)
      ‚Üì
AST: ExprCall { func: "function_call", args: [Ident("name")] }
      ‚Üì
IR: FuncCall { name: "function_call", args: [Var("name")] }
      ‚Üì
Shell: function_call "$name"
```

### Safety Guarantees

1. **Type Checking** (compile-time):
   - Function parameter types must match argument types
   - No implicit conversions

2. **Escaping** (emission-time):
   - `$` ‚Üí `\$`
   - `"` ‚Üí `\"`
   - Backslash escaping for special chars

3. **Quoting** (always):
   - Variable references: `"$var"`
   - Function arguments: `func "$arg"`
   - Prevents all injection vectors

## Common Patterns

### Bootstrap Installer Variables

```rust
fn main() {
    let version = "1.0.0";
    let binary = "myapp";
    let prefix = "/usr/local";
    let download_url = "https://releases.example.com/myapp-1.0.0.tar.gz";

    install(version, binary, prefix, download_url);
}
```

### Configuration File Paths

```rust
fn main() {
    let config_file = "/etc/myapp/config.toml";
    let log_dir = "/var/log/myapp";
    let data_dir = "/var/lib/myapp";

    setup_config(config_file, log_dir, data_dir);
}
```

### Service Configuration

```rust
fn main() {
    let service_name = "myapp";
    let service_user = "myapp";
    let service_port = 8080;
    let enable_auto_start = true;

    configure_service(service_name, service_user, service_port, enable_auto_start);
}
```

## Edge Cases and Limitations

### ‚úÖ Supported

- String literals with any UTF-8 characters
- Integer literals (i32 range)
- Boolean literals (`true`, `false`)
- Variables with underscores (snake_case)
- Special characters in string values
- Paths with spaces

### ‚ö†Ô∏è Partial Support

- **Variable mutation**: Not supported in v1.0 (all variables are immutable)
- **Global variables**: Not supported (scoped to functions only)
- **Shadowing**: Limited support (within different scopes)

### ‚ùå Not Supported (v1.0)

- `let mut` (mutable variables) - planned for v1.1
- Variable shadowing within same scope
- Destructuring: `let (x, y) = ...`
- Pattern matching in let: `let Some(x) = ...`
- Type annotations: `let x: i32 = 10;` (inferred only)
- Floating point numbers (`f32`, `f64`)
- References other than `&str`

### Shell Compatibility

All variable features work on:
- ‚úÖ POSIX sh
- ‚úÖ Dash (Debian/Ubuntu default)
- ‚úÖ Bash (3.2+)
- ‚úÖ Ash (BusyBox)

## Testing Your Examples

To verify variable handling, create a test file:

```rust
// test_vars.rs
fn main() {
    let name = "test";
    let count = 42;
    let active = true;

    show(name, count, active);
}

fn show(n: &str, c: i32, a: bool) {}
```

Build and inspect:

```bash
$ bashrs build test_vars.rs -o test_vars.sh
‚úì Transpiled successfully

$ cat test_vars.sh
#!/bin/sh
# Generated by bashrs

show() {
    n="$1"
    c="$2"
    a="$3"
}

main() {
    name="test"
    count=42
    active=true

    show "$name" "$count" "$active"
}

main "$@"

$ shellcheck -s sh test_vars.sh
‚úì No issues detected
```

## Verification Levels

Variable quoting strictness varies by verification level:

```bash
# Basic: Standard quoting
$ bashrs build vars.rs --verify basic

# Strict: Paranoid quoting (default)
$ bashrs build vars.rs --verify strict

# Paranoid: Maximum safety, rejects any dynamic content
$ bashrs build vars.rs --verify paranoid
```

For bootstrap installers, use `--verify strict` (default).

## Next Steps

Now that you understand variables, let's explore [Chapter 3: Functions and Parameters](ch03-functions-tdd.md) to learn about:
- Function definitions
- Parameter passing
- Return values (via exit codes)
- Function composition

## Reference

- Test files: `tests/ch02-variables/`
- Example files: `examples/ch02-*.rs`
- Generated output: `target/test-examples/ch02-*.sh`
- ShellCheck reports: `target/shellcheck-reports/ch02-*.txt`
- Related: [Chapter 1: Hello Shell](ch01-hello-shell-tdd.md)
- Related: [Chapter 18: Limitations](ch18-limitations.md)
