#!/usr/bin/env python3
"""
Round 3: EXTREME pathological entries. Designed to find transpiler boundaries.
Focus: deep nesting, large programs, edge-case control flow, match expressions.
"""

NEXT_ID = 15935
EXPANSION_NUM = 181

def format_rust_string(s):
    if '"#' in s:
        return 'r##"' + s + '"##'
    return 'r#"' + s + '"#'

def gen_entries():
    entries = []
    bid = NEXT_ID

    # A3: 6-stage pipeline with error accumulation
    entries.append((f"B-{bid}", "pipe-6stage-erracc", "Six-stage pipeline with error accumulation and rollback count",
        r'''fn stage_a(x: i64) -> i64 { if x < 0 { return -1; } return x * 2; }
fn stage_b(x: i64) -> i64 { if x == -1 { return -1; } return x + 5; }
fn stage_c(x: i64) -> i64 { if x == -1 { return -1; } if x > 100 { return -1; } return x * 3; }
fn stage_d(x: i64) -> i64 { if x == -1 { return -1; } return x - 10; }
fn stage_e(x: i64) -> i64 { if x == -1 { return -1; } return x / 2; }
fn stage_f(x: i64) -> i64 { if x == -1 { return -1; } return x % 100; }
fn run_pipeline(input: i64) -> i64 {
    return stage_f(stage_e(stage_d(stage_c(stage_b(stage_a(input))))));
}
fn main() {
    let tests: [i64; 8] = [1, 5, 10, 20, 50, -1, 0, 100];
    let mut pass: i64 = 0;
    let mut fail: i64 = 0;
    let mut i: i64 = 0;
    while i < 8 {
        let r: i64 = run_pipeline(tests[i]);
        if r == -1 { fail = fail + 1; } else { pass = pass + 1; }
        println!("in={} out={}", tests[i], r);
        i = i + 1;
    }
    println!("pass={} fail={}", pass, fail);
}''', r'''stage_a()'''))
    bid += 1

    # B3: Strings with every printable special char
    entries.append((f"B-{bid}", "quote-all-specials", "Strings containing all common shell special characters",
        r'''fn main() {
    println!("tab\there");
    println!("backslash is \\");
    println!("hash #comment");
    println!("tilde ~home");
    println!("at @user");
    println!("caret ^start");
    println!("percent 100%");
}''', r'''tab'''))
    bid += 1

    # C3: One-liner with match expression
    entries.append((f"B-{bid}", "oneliner-match-expr", "Match expression as one-liner for classification",
        r'''fn classify(x: i64) -> i64 {
    match x {
        0 => 0,
        1 => 10,
        2 => 20,
        3 => 30,
        _ => 99,
    }
}
fn main() {
    let mut i: i64 = 0;
    while i < 6 {
        println!("classify({})={}", i, classify(i));
        i = i + 1;
    }
}''', r'''classify()'''))
    bid += 1

    # D3: Wildcard matching simulation with * and ? patterns
    entries.append((f"B-{bid}", "glob-star-question", "Wildcard matching: * matches any length, ? matches one char",
        r'''fn match_question(c: i64, pattern: i64) -> i64 {
    if pattern == 63 { return 1; }
    if c == pattern { return 1; }
    return 0;
}
fn match_range(c: i64, low: i64, high: i64) -> i64 {
    if c >= low {
        if c <= high { return 1; }
    }
    return 0;
}
fn main() {
    let chars: [i64; 6] = [65, 66, 67, 49, 50, 97];
    let mut i: i64 = 0;
    while i < 6 {
        let q: i64 = match_question(chars[i], 63);
        let upper: i64 = match_range(chars[i], 65, 90);
        let lower: i64 = match_range(chars[i], 97, 122);
        let digit: i64 = match_range(chars[i], 48, 57);
        println!("c={} ?={} upper={} lower={} digit={}", chars[i], q, upper, lower, digit);
        i = i + 1;
    }
}''', r'''match_question()'''))
    bid += 1

    # E3: Heredoc with loop-generated content
    entries.append((f"B-{bid}", "heredoc-loop-gen", "Heredoc-like output generated by loops with indentation",
        r'''fn indent(level: i64) {
    let mut i: i64 = 0;
    while i < level {
        print!("  ");
        i = i + 1;
    }
}
fn emit_tree(depth: i64, max_depth: i64) {
    if depth >= max_depth { return; }
    indent(depth);
    println!("node_{}", depth);
    emit_tree(depth + 1, max_depth);
    emit_tree(depth + 1, max_depth);
}
fn main() {
    println!("tree:");
    emit_tree(0, 3);
}''', r'''emit_tree()'''))
    bid += 1

    # F3: Environment with PATH-like concatenation
    entries.append((f"B-{bid}", "env-path-concat", "PATH-like variable building with colon-separated concatenation",
        r'''fn path_entry_count(path: [i64; 10], len: i64) -> i64 {
    if len == 0 { return 0; }
    let mut count: i64 = 1;
    let mut i: i64 = 0;
    while i < len {
        if path[i] == 58 {
            count = count + 1;
        }
        i = i + 1;
    }
    return count;
}
fn main() {
    let p1: [i64; 10] = [47, 58, 47, 98, 58, 47, 99, 0, 0, 0];
    let p2: [i64; 10] = [47, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    let p3: [i64; 10] = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
    println!("entries: {} {} {}", path_entry_count(p1, 7), path_entry_count(p2, 1), path_entry_count(p3, 0));
}''', r'''path_entry_count()'''))
    bid += 1

    # G3: SSH batch execution with retry
    entries.append((f"B-{bid}", "ssh-batch-retry", "SSH batch execution with retry logic and backoff",
        r'''fn ssh_try(host: i64, cmd: i64, attempt: i64) -> i64 {
    if attempt > 3 { return -1; }
    let fail_chance: i64 = (host * 7 + cmd * 3 + attempt * 11) % 10;
    if fail_chance < 3 { return -1; }
    return host * 100 + cmd;
}
fn ssh_with_retry(host: i64, cmd: i64) -> i64 {
    let mut attempt: i64 = 1;
    while attempt <= 3 {
        let r: i64 = ssh_try(host, cmd, attempt);
        if r >= 0 { return r; }
        println!("  retry host={} cmd={} attempt={}", host, cmd, attempt);
        attempt = attempt + 1;
    }
    return -1;
}
fn main() {
    let hosts: [i64; 4] = [1, 2, 3, 4];
    let cmds: [i64; 3] = [10, 20, 30];
    let mut i: i64 = 0;
    while i < 4 {
        let mut j: i64 = 0;
        while j < 3 {
            let r: i64 = ssh_with_retry(hosts[i], cmds[j]);
            println!("host={} cmd={} result={}", hosts[i], cmds[j], r);
            j = j + 1;
        }
        i = i + 1;
    }
}''', r'''ssh_try()'''))
    bid += 1

    # H3: Printf with escape sequences
    entries.append((f"B-{bid}", "print-escape-seq", "Printing with embedded escape-like sequences",
        r'''fn print_header(width: i64, ch: i64) {
    let mut i: i64 = 0;
    while i < width {
        print!("{}", ch);
        i = i + 1;
    }
    println!("");
}
fn print_centered(text: &str, width: i64) {
    let text_len: i64 = 5;
    let pad: i64 = (width - text_len) / 2;
    let mut i: i64 = 0;
    while i < pad {
        print!(" ");
        i = i + 1;
    }
    println!("{}", text);
}
fn main() {
    print_header(20, 61);
    print_centered("TITLE", 20);
    print_header(20, 61);
    println!("line 1");
    println!("line 2");
    print_header(20, 45);
}''', r'''print_header()'''))
    bid += 1

    # I3: Sed-like substitution simulation
    entries.append((f"B-{bid}", "sed-substitute-sim", "Sed-like character substitution with global/first-only mode",
        r'''fn substitute_first(data: [i64; 8], len: i64, from: i64, to: i64) -> i64 {
    let mut i: i64 = 0;
    while i < len {
        if data[i] == from { return i; }
        i = i + 1;
    }
    return -1;
}
fn count_occurrences(data: [i64; 8], len: i64, target: i64) -> i64 {
    let mut count: i64 = 0;
    let mut i: i64 = 0;
    while i < len {
        if data[i] == target { count = count + 1; }
        i = i + 1;
    }
    return count;
}
fn main() {
    let data: [i64; 8] = [65, 66, 65, 67, 65, 68, 65, 69];
    let first_pos: i64 = substitute_first(data, 8, 65, 88);
    let count: i64 = count_occurrences(data, 8, 65);
    println!("first_A_at={} total_A={}", first_pos, count);
    let count_none: i64 = count_occurrences(data, 8, 90);
    println!("count_Z={}", count_none);
}''', r'''substitute_first()'''))
    bid += 1

    # J3: Priority queue simulation
    entries.append((f"B-{bid}", "ds-priority-queue", "Priority queue with array-based binary heap operations",
        r'''fn parent(i: i64) -> i64 { return (i - 1) / 2; }
fn left_child(i: i64) -> i64 { return 2 * i + 1; }
fn right_child(i: i64) -> i64 { return 2 * i + 2; }
fn heap_peek(heap: [i64; 8]) -> i64 { return heap[0]; }
fn sift_up_steps(heap: [i64; 8], pos: i64) -> i64 {
    let mut steps: i64 = 0;
    let mut i: i64 = pos;
    while i > 0 {
        let p: i64 = parent(i);
        if heap[i] >= heap[p] { break; }
        steps = steps + 1;
        i = p;
    }
    return steps;
}
fn main() {
    let heap: [i64; 8] = [1, 3, 5, 7, 9, 11, 13, 2];
    let peek: i64 = heap_peek(heap);
    let steps: i64 = sift_up_steps(heap, 7);
    println!("min={} sift_steps={}", peek, steps);
    println!("parent(3)={} left(1)={} right(1)={}", parent(3), left_child(1), right_child(1));
}''', r'''parent()'''))
    bid += 1

    # K3: Module system with version checks
    entries.append((f"B-{bid}", "source-version-check", "Module loading with version compatibility checks",
        r'''fn version_major(v: i64) -> i64 { return v / 10000; }
fn version_minor(v: i64) -> i64 { return (v / 100) % 100; }
fn version_patch(v: i64) -> i64 { return v % 100; }
fn compatible(required: i64, available: i64) -> i64 {
    let req_maj: i64 = version_major(required);
    let avl_maj: i64 = version_major(available);
    if req_maj != avl_maj { return 0; }
    let req_min: i64 = version_minor(required);
    let avl_min: i64 = version_minor(available);
    if avl_min < req_min { return 0; }
    return 1;
}
fn main() {
    let r1: i64 = compatible(20300, 20500);
    let r2: i64 = compatible(20300, 20200);
    let r3: i64 = compatible(20300, 30300);
    let r4: i64 = compatible(10000, 10001);
    println!("compat: {} {} {} {}", r1, r2, r3, r4);
    println!("v20500: {}.{}.{}", version_major(20500), version_minor(20500), version_patch(20500));
}''', r'''version_major()'''))
    bid += 1

    # L3: 15-function program with deep call graph
    entries.append((f"B-{bid}", "script-15fn-deep-call", "15-function program with call depth 8",
        r'''fn f1(x: i64) -> i64 { return x + 1; }
fn f2(x: i64) -> i64 { return f1(x) * 2; }
fn f3(x: i64) -> i64 { return f2(x) + 3; }
fn f4(x: i64) -> i64 { return f3(x) - 1; }
fn f5(x: i64) -> i64 { return f4(x) * f4(x); }
fn f6(x: i64) -> i64 { return f5(x) % 1000; }
fn f7(x: i64) -> i64 { return f6(x) + f1(x); }
fn f8(x: i64) -> i64 { return f7(x) / 3; }
fn abs_val(x: i64) -> i64 { if x < 0 { return 0 - x; } return x; }
fn sign(x: i64) -> i64 { if x > 0 { return 1; } if x < 0 { return -1; } return 0; }
fn clamp(x: i64, lo: i64, hi: i64) -> i64 {
    if x < lo { return lo; }
    if x > hi { return hi; }
    return x;
}
fn scale(x: i64, factor: i64) -> i64 { return x * factor / 100; }
fn combine(a: i64, b: i64) -> i64 { return a * 1000 + b; }
fn split_hi(packed: i64) -> i64 { return packed / 1000; }
fn split_lo(packed: i64) -> i64 { return packed % 1000; }
fn main() {
    let r: i64 = f8(5);
    let a: i64 = abs_val(-42);
    let s: i64 = sign(-7);
    let c: i64 = clamp(150, 0, 100);
    let sc: i64 = scale(200, 75);
    let packed: i64 = combine(42, 99);
    let hi: i64 = split_hi(packed);
    let lo: i64 = split_lo(packed);
    println!("f8(5)={} abs={} sign={} clamp={} scale={}", r, a, s, c, sc);
    println!("packed={} hi={} lo={}", packed, hi, lo);
}''', r'''f1()'''))
    bid += 1

    # M3: Match with 10 arms
    entries.append((f"B-{bid}", "brace-match-10arm", "Match expression with 10 arms and complex bodies",
        r'''fn day_type(day: i64) -> i64 {
    match day {
        1 => 1,
        2 => 1,
        3 => 1,
        4 => 1,
        5 => 1,
        6 => 2,
        7 => 2,
        0 => 3,
        8 => 4,
        _ => 0,
    }
}
fn main() {
    let mut i: i64 = 0;
    while i < 10 {
        let dt: i64 = day_type(i);
        println!("day={} type={}", i, dt);
        i = i + 1;
    }
}''', r'''day_type()'''))
    bid += 1

    # N3: Double-cleanup trap pattern
    entries.append((f"B-{bid}", "trap-double-cleanup", "Double trap handler with primary and fallback cleanup",
        r'''fn create_resource(id: i64) -> i64 {
    println!("create res_{}", id);
    return id;
}
fn cleanup_primary(r1: i64, r2: i64) -> i64 {
    println!("cleanup primary: {} {}", r1, r2);
    return 0;
}
fn cleanup_fallback(r1: i64, r2: i64) -> i64 {
    println!("cleanup fallback: {} {}", r1, r2);
    return 0;
}
fn do_work(r1: i64, r2: i64) -> i64 {
    if r1 == 0 { return -1; }
    if r2 == 0 { return -2; }
    return r1 + r2;
}
fn main() {
    let r1: i64 = create_resource(1);
    let r2: i64 = create_resource(2);
    let result: i64 = do_work(r1, r2);
    if result < 0 {
        cleanup_fallback(r1, r2);
    } else {
        cleanup_primary(r1, r2);
    }
    println!("exit: {}", result);
}''', r'''create_resource()'''))
    bid += 1

    # O3: Argument parser with mutual exclusion
    entries.append((f"B-{bid}", "cli-mutually-exclusive", "CLI parser with mutually exclusive flags detection",
        r'''fn check_exclusive(flags: [i64; 6]) -> i64 {
    let mut group_a: i64 = 0;
    let mut group_b: i64 = 0;
    if flags[0] == 1 { group_a = group_a + 1; }
    if flags[1] == 1 { group_a = group_a + 1; }
    if flags[2] == 1 { group_b = group_b + 1; }
    if flags[3] == 1 { group_b = group_b + 1; }
    if group_a > 1 { return -1; }
    if group_b > 1 { return -2; }
    if group_a >= 1 {
        if group_b >= 1 { return -3; }
    }
    return 0;
}
fn main() {
    let f1: [i64; 6] = [1, 0, 0, 0, 0, 0];
    let f2: [i64; 6] = [1, 1, 0, 0, 0, 0];
    let f3: [i64; 6] = [1, 0, 1, 0, 0, 0];
    let f4: [i64; 6] = [0, 0, 0, 0, 1, 1];
    println!("check: {} {} {} {}", check_exclusive(f1), check_exclusive(f2), check_exclusive(f3), check_exclusive(f4));
}''', r'''check_exclusive()'''))
    bid += 1

    # Q3: Bisection method
    entries.append((f"B-{bid}", "num-bisection-method", "Bisection method root finding with convergence tracking",
        r'''fn f_poly(x: i64) -> i64 { return x * x * x - 2 * x - 5; }
fn bisect_step(lo: i64, hi: i64) -> i64 {
    return (lo + hi) / 2;
}
fn main() {
    let mut lo: i64 = 1;
    let mut hi: i64 = 3;
    let mut i: i64 = 0;
    while i < 10 {
        let mid: i64 = bisect_step(lo, hi);
        let fmid: i64 = f_poly(mid);
        let flo: i64 = f_poly(lo);
        println!("iter={} lo={} hi={} mid={} f(mid)={}", i, lo, hi, mid, fmid);
        if fmid == 0 { break; }
        if flo > 0 {
            if fmid > 0 { lo = mid; } else { hi = mid; }
        } else {
            if fmid < 0 { lo = mid; } else { hi = mid; }
        }
        i = i + 1;
    }
}''', r'''f_poly()'''))
    bid += 1

    # R3: Symbolic - operator precedence evaluator
    entries.append((f"B-{bid}", "symbolic-precedence", "Operator precedence evaluator with add/mul/parentheses",
        r'''fn eval_add(a: i64, b: i64) -> i64 { return a + b; }
fn eval_mul(a: i64, b: i64) -> i64 { return a * b; }
fn eval_sub(a: i64, b: i64) -> i64 { return a - b; }
fn eval_div(a: i64, b: i64) -> i64 { if b == 0 { return 0; } return a / b; }
fn eval_mod(a: i64, b: i64) -> i64 { if b == 0 { return 0; } return a % b; }
fn main() {
    let r1: i64 = eval_add(eval_mul(2, 3), eval_mul(4, 5));
    let r2: i64 = eval_mul(eval_add(2, 3), eval_add(4, 5));
    let r3: i64 = eval_sub(eval_mul(10, 10), eval_div(100, 4));
    let r4: i64 = eval_mod(eval_add(17, 8), 7);
    println!("2*3+4*5={}", r1);
    println!("(2+3)*(4+5)={}", r2);
    println!("10*10-100/4={}", r3);
    println!("(17+8)%7={}", r4);
}''', r'''eval_add()'''))
    bid += 1

    # S3: Editor - undo stack simulation
    entries.append((f"B-{bid}", "editor-undo-stack", "Editor undo/redo stack with operation tracking",
        r'''fn push_op(stack: [i64; 8], top: i64, op: i64) -> i64 {
    return top + 1;
}
fn pop_op(stack: [i64; 8], top: i64) -> i64 {
    if top < 0 { return -1; }
    return stack[top];
}
fn main() {
    let mut undo_stack: [i64; 8] = [0, 0, 0, 0, 0, 0, 0, 0];
    let mut undo_top: i64 = -1;
    undo_stack[0] = 1;
    undo_top = push_op(undo_stack, undo_top, 1);
    undo_stack[1] = 2;
    undo_top = push_op(undo_stack, undo_top, 2);
    undo_stack[2] = 3;
    undo_top = push_op(undo_stack, undo_top, 3);
    println!("stack depth: {}", undo_top + 1);
    let op3: i64 = pop_op(undo_stack, undo_top);
    undo_top = undo_top - 1;
    let op2: i64 = pop_op(undo_stack, undo_top);
    undo_top = undo_top - 1;
    println!("undo: {} then {}", op3, op2);
    println!("remaining: {}", undo_top + 1);
}''', r'''push_op()'''))
    bid += 1

    # T3: Recursive descent parser (tiny)
    entries.append((f"B-{bid}", "fp-recursive-descent", "Tiny recursive descent parser for arithmetic expressions",
        r'''fn parse_num(tokens: [i64; 8], pos: i64) -> i64 {
    return tokens[pos];
}
fn parse_add(tokens: [i64; 8], pos: i64, len: i64) -> i64 {
    let left: i64 = parse_num(tokens, pos);
    if pos + 2 >= len { return left; }
    let op: i64 = tokens[pos + 1];
    let right: i64 = parse_num(tokens, pos + 2);
    if op == 43 { return left + right; }
    if op == 45 { return left - right; }
    if op == 42 { return left * right; }
    return left;
}
fn main() {
    let expr1: [i64; 8] = [3, 43, 4, 0, 0, 0, 0, 0];
    let expr2: [i64; 8] = [10, 45, 3, 0, 0, 0, 0, 0];
    let expr3: [i64; 8] = [5, 42, 6, 0, 0, 0, 0, 0];
    let expr4: [i64; 8] = [42, 0, 0, 0, 0, 0, 0, 0];
    println!("3+4={}", parse_add(expr1, 0, 3));
    println!("10-3={}", parse_add(expr2, 0, 3));
    println!("5*6={}", parse_add(expr3, 0, 3));
    println!("42={}", parse_add(expr4, 0, 1));
}''', r'''parse_num()'''))
    bid += 1

    # U3: Array bounds verification
    entries.append((f"B-{bid}", "prove-array-bounds", "Provably bounds-safe array access with checked indexing",
        r'''fn checked_get(arr: [i64; 8], idx: i64, len: i64) -> i64 {
    if idx < 0 { return -1; }
    if idx >= len { return -1; }
    return arr[idx];
}
fn checked_set_val(old: i64, new_val: i64, idx: i64, len: i64) -> i64 {
    if idx < 0 { return old; }
    if idx >= len { return old; }
    return new_val;
}
fn main() {
    let arr: [i64; 8] = [10, 20, 30, 40, 50, 0, 0, 0];
    let len: i64 = 5;
    println!("get(0)={}", checked_get(arr, 0, len));
    println!("get(4)={}", checked_get(arr, 4, len));
    println!("get(5)={}", checked_get(arr, 5, len));
    println!("get(-1)={}", checked_get(arr, -1, len));
    let r: i64 = checked_set_val(arr[2], 99, 2, len);
    println!("set(2,99)={}", r);
    let bad: i64 = checked_set_val(arr[0], 99, 10, len);
    println!("set(10,99)={}", bad);
}''', r'''checked_get()'''))
    bid += 1

    # V3: Clippy-pedantic - explicit error handling
    entries.append((f"B-{bid}", "clippy-error-handling", "Explicit error handling with result codes (no unwrap/panic)",
        r'''fn divide(a: i64, b: i64) -> i64 {
    if b == 0 { return -9999; }
    return a / b;
}
fn sqrt_approx(n: i64) -> i64 {
    if n < 0 { return -9999; }
    if n == 0 { return 0; }
    let mut guess: i64 = n / 2;
    if guess == 0 { guess = 1; }
    let mut i: i64 = 0;
    while i < 20 {
        let next: i64 = divide(guess + divide(n, guess), 2);
        if next == -9999 { return -9999; }
        if next == guess { break; }
        guess = next;
        i = i + 1;
    }
    return guess;
}
fn main() {
    println!("div(10,3)={}", divide(10, 3));
    println!("div(10,0)={}", divide(10, 0));
    println!("sqrt(100)={}", sqrt_approx(100));
    println!("sqrt(2)={}", sqrt_approx(2));
    println!("sqrt(0)={}", sqrt_approx(0));
    println!("sqrt(-4)={}", sqrt_approx(-4));
}''', r'''divide()'''))
    bid += 1

    # W3: C-style linked list traversal
    entries.append((f"B-{bid}", "c-style-linked-list", "Linked list traversal using array-based next pointers",
        r'''fn list_next(next_ptrs: [i64; 8], current: i64) -> i64 {
    if current < 0 { return -1; }
    if current >= 8 { return -1; }
    return next_ptrs[current];
}
fn list_value(values: [i64; 8], idx: i64) -> i64 {
    if idx < 0 { return -1; }
    return values[idx];
}
fn list_length(next_ptrs: [i64; 8], head: i64) -> i64 {
    let mut len: i64 = 0;
    let mut cur: i64 = head;
    while cur >= 0 {
        len = len + 1;
        cur = list_next(next_ptrs, cur);
        if len > 8 { break; }
    }
    return len;
}
fn main() {
    let values: [i64; 8] = [10, 20, 30, 40, 50, 0, 0, 0];
    let next_ptrs: [i64; 8] = [1, 2, 3, 4, -1, -1, -1, -1];
    let head: i64 = 0;
    let len: i64 = list_length(next_ptrs, head);
    println!("list length: {}", len);
    let mut cur: i64 = head;
    while cur >= 0 {
        println!("node[{}]={}", cur, list_value(values, cur));
        cur = list_next(next_ptrs, cur);
    }
}''', r'''list_next()'''))
    bid += 1

    return entries, bid


def gen_makefile_r3(start_bid):
    entries = []
    bid = start_bid

    entries.append((f"M-{bid}", "make-multiline-recipe", "Makefile with complex multiline recipe and shell variables",
        "Makefile",
        '''VERSION := $(shell git describe --tags --always 2>/dev/null || echo "dev")
BUILD_DATE := $(shell date -u +%Y-%m-%dT%H:%M:%SZ)
GIT_HASH := $(shell git rev-parse --short HEAD 2>/dev/null || echo "unknown")

LDFLAGS := -X main.version=$(VERSION) -X main.buildDate=$(BUILD_DATE) -X main.gitHash=$(GIT_HASH)

.PHONY: build test lint

build:
\t@echo "Building version $(VERSION)"
\tgo build -ldflags "$(LDFLAGS)" -o bin/app ./cmd/app

test:
\t@echo "Running tests..."
\tgo test -race -coverprofile=coverage.out ./...
\t@echo "Coverage:"
\tgo tool cover -func=coverage.out | tail -1

lint:
\tgolangci-lint run --timeout 5m''',
        '''VERSION :='''))
    bid += 1

    entries.append((f"M-{bid}", "make-phony-pattern", "Makefile with pattern rules and multiple phony targets",
        "Makefile",
        '''PROTOS := $(wildcard proto/*.proto)
GO_PROTOS := $(PROTOS:proto/%.proto=gen/%.pb.go)

.PHONY: all proto clean fmt check

all: proto fmt check

proto: $(GO_PROTOS)

gen/%.pb.go: proto/%.proto
\t@mkdir -p gen
\tprotoc --go_out=gen --go_opt=paths=source_relative $<

fmt:
\tgofmt -w .

check:
\tgo vet ./...

clean:
\trm -rf gen''',
        '''PROTOS :='''))
    bid += 1

    entries.append((f"M-{bid}", "make-target-specific-var", "Makefile with target-specific variable assignments",
        "Makefile",
        '''CC := gcc
CFLAGS := -Wall

debug: CFLAGS += -g -O0 -DDEBUG
debug: all

release: CFLAGS += -O2 -DNDEBUG
release: all

.PHONY: all debug release clean

all: app

app: main.o utils.o
\t$(CC) $(CFLAGS) -o $@ $^

%.o: %.c
\t$(CC) $(CFLAGS) -c $< -o $@

clean:
\trm -f *.o app''',
        '''CC :='''))
    bid += 1

    return entries, bid


def gen_dockerfile_r3(start_bid):
    entries = []
    bid = start_bid

    entries.append((f"D-{bid}", "docker-4stage-pipeline", "Dockerfile with 4 build stages and cross-stage COPY",
        "Dockerfile",
        '''FROM rust:1.75 AS planner
WORKDIR /app
COPY . .
RUN cargo install cargo-chef && cargo chef prepare --recipe-path recipe.json

FROM rust:1.75 AS cacher
WORKDIR /app
COPY --from=planner /app/recipe.json recipe.json
RUN cargo install cargo-chef && cargo chef cook --release --recipe-path recipe.json

FROM rust:1.75 AS builder
WORKDIR /app
COPY --from=cacher /app/target target
COPY . .
RUN cargo build --release

FROM debian:bookworm-slim
RUN apt-get update && apt-get install -y --no-install-recommends ca-certificates && rm -rf /var/lib/apt/lists/*
COPY --from=builder /app/target/release/app /usr/local/bin/
EXPOSE 8080
CMD ["app"]''',
        '''FROM rust:'''))
    bid += 1

    entries.append((f"D-{bid}", "docker-conditional-build", "Dockerfile with ARG-driven conditional build logic",
        "Dockerfile",
        '''ARG BUILD_ENV=production
FROM node:20-alpine AS base
WORKDIR /app

FROM base AS deps-production
COPY package.json package-lock.json ./
RUN npm ci --production

FROM base AS deps-development
COPY package.json package-lock.json ./
RUN npm ci

FROM deps-${BUILD_ENV} AS runtime
COPY . .
ARG BUILD_ENV
ENV NODE_ENV=${BUILD_ENV}
RUN if [ "$BUILD_ENV" = "production" ]; then npm run build; fi
EXPOSE 3000
CMD ["node", "src/index.js"]''',
        '''ARG BUILD_ENV'''))
    bid += 1

    entries.append((f"D-{bid}", "docker-security-harden", "Security-hardened Dockerfile with non-root user and read-only FS",
        "Dockerfile",
        '''FROM alpine:3.19 AS builder
RUN apk add --no-cache go gcc musl-dev
WORKDIR /build
COPY . .
RUN CGO_ENABLED=0 go build -trimpath -ldflags="-s -w" -o /app

FROM scratch
COPY --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/
COPY --from=builder /app /app
USER 65534:65534
EXPOSE 8080
ENTRYPOINT ["/app"]''',
        '''FROM alpine:'''))
    bid += 1

    return entries, bid


def emit_rust_code(bash_entries, makefile_entries, dockerfile_entries, expansion_num):
    lines = []
    lines.append(f"    fn load_expansion{expansion_num}_bash(&mut self) {{")
    for bid, name, desc, code, expected in bash_entries:
        rust_code = format_rust_string(code)
        rust_expected = format_rust_string(expected)
        lines.append(f'        self.entries.push(CorpusEntry::new("{bid}", "{name}", "{desc}",')
        lines.append(f'            CorpusFormat::Bash, CorpusTier::Adversarial,')
        lines.append(f'            {rust_code},')
        lines.append(f'            {rust_expected}));')
    lines.append("    }")
    lines.append("")
    lines.append(f"    pub fn load_expansion{expansion_num}_makefile(&mut self) {{")
    for bid, name, desc, fmt, code, expected in makefile_entries:
        rust_code = format_rust_string(code)
        rust_expected = format_rust_string(expected)
        lines.append(f'        self.entries.push(CorpusEntry::new("{bid}", "{name}", "{desc}",')
        lines.append(f'            CorpusFormat::Makefile, CorpusTier::Adversarial,')
        lines.append(f'            {rust_code},')
        lines.append(f'            {rust_expected}));')
    lines.append("    }")
    lines.append("")
    lines.append(f"    pub fn load_expansion{expansion_num}_dockerfile(&mut self) {{")
    for bid, name, desc, fmt, code, expected in dockerfile_entries:
        rust_code = format_rust_string(code)
        rust_expected = format_rust_string(expected)
        lines.append(f'        self.entries.push(CorpusEntry::new("{bid}", "{name}", "{desc}",')
        lines.append(f'            CorpusFormat::Dockerfile, CorpusTier::Adversarial,')
        lines.append(f'            {rust_code},')
        lines.append(f'            {rust_expected}));')
    lines.append("    }")
    return "\n".join(lines)


if __name__ == "__main__":
    bash_entries, next_bid = gen_entries()
    makefile_entries, next_bid = gen_makefile_r3(next_bid)
    dockerfile_entries, next_bid = gen_dockerfile_r3(next_bid)
    total = len(bash_entries) + len(makefile_entries) + len(dockerfile_entries)
    print(f"// Round 3: {len(bash_entries)} bash + {len(makefile_entries)} makefile + {len(dockerfile_entries)} dockerfile = {total} entries")
    print(f"// B-IDs: B-{NEXT_ID}..{next_bid - 1}")
    print(f"// Expansion function: {EXPANSION_NUM}")
    print()
    print(emit_rust_code(bash_entries, makefile_entries, dockerfile_entries, EXPANSION_NUM))
